<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>余一叶知秋尽</title>
  
  
  <link href="https://pengline.github.io/atom.xml" rel="self"/>
  
  <link href="https://pengline.github.io/"/>
  <updated>2025-09-09T09:01:49.386Z</updated>
  <id>https://pengline.github.io/</id>
  
  <author>
    <name>余一叶知秋尽</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Ubuntu 安装 Kubernetes 集群的详细教程</title>
    <link href="https://pengline.github.io/2025/09/09/84c118df8b3e4db4a1e3557e7633f8e8/"/>
    <id>https://pengline.github.io/2025/09/09/84c118df8b3e4db4a1e3557e7633f8e8/</id>
    <published>2025-09-09T02:43:40.646Z</published>
    <updated>2025-09-09T09:01:49.386Z</updated>
    
    <content type="html"><![CDATA[<p>在Ubuntu24 上安装 Kubernetes 集群的详细过程，包括：节点安装调试、网络插件安装、Dashboard安装、Nginx 部署测试。</p><h2 id="基础安装">基础安装</h2><h3 id="系统环境设置">系统环境设置</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 永久关闭防火墙：</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">disable</span> --now ufw</span><br><span class="line"><span class="comment"># 设置为亚洲的上海时区</span></span><br><span class="line"><span class="built_in">sudo</span> timedatectl set-timezone Asia/Shanghai</span><br><span class="line"><span class="comment"># 重启时间同步服务</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl restart systemd-timesyncd.service</span><br><span class="line"><span class="comment"># 确保时间同步服务正常运行</span></span><br><span class="line">timedatectl status</span><br><span class="line"></span><br><span class="line"><span class="comment"># 闭Swap分区</span></span><br><span class="line"><span class="built_in">sudo</span> swapoff -a</span><br><span class="line"><span class="built_in">sudo</span> sed -i <span class="string">&#x27;/swap/d&#x27;</span> /etc/fstab</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装policycoreutils软件包</span></span><br><span class="line"><span class="built_in">sudo</span> apt install -y policycoreutils</span><br><span class="line"><span class="comment"># 检查selinux关闭状态</span></span><br><span class="line">sestatus</span><br></pre></td></tr></table></figure><h3 id="系统参数配置">系统参数配置</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加主机名映射</span></span><br><span class="line"><span class="built_in">sudo</span> vi /etc/hosts</span><br><span class="line">    192.168.159.200 master200</span><br><span class="line">    192.168.159.201 slave201</span><br><span class="line">    192.168.159.202 slave202</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置内核参数：</span></span><br><span class="line"><span class="built_in">cat</span> &lt;&lt;<span class="string">EOF | sudo tee /etc/sysctl.d/k8s.conf</span></span><br><span class="line"><span class="string">net.bridge.bridge-nf-call-ip6tables = 1</span></span><br><span class="line"><span class="string">net.bridge.bridge-nf-call-iptables = 1</span></span><br><span class="line"><span class="string">net.ipv4.ip_forward = 1</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> sysctl --system</span><br><span class="line"></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="built_in">cat</span> &lt;&lt;<span class="string">EOF | sudo tee /etc/modules-load.d/k8s.conf</span></span><br><span class="line"><span class="string">overlay</span></span><br><span class="line"><span class="string">br_netfilter</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> modprobe overlay</span><br><span class="line"><span class="built_in">sudo</span> modprobe br_netfilter</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置所需的 sysctl 参数，参数在重新启动后保持不变</span></span><br><span class="line"><span class="built_in">cat</span> &lt;&lt;<span class="string">EOF | sudo tee /etc/sysctl.d/k8s.conf</span></span><br><span class="line"><span class="string">net.bridge.bridge-nf-call-iptables  = 1</span></span><br><span class="line"><span class="string">net.bridge.bridge-nf-call-ip6tables = 1</span></span><br><span class="line"><span class="string">net.ipv4.ip_forward                 = 1</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 应用 sysctl 参数而不重新启动</span></span><br><span class="line"><span class="built_in">sudo</span> sysctl --system</span><br><span class="line"></span><br><span class="line"><span class="comment"># 系统变量在你的 sysctl 配置中被设置为 1：</span></span><br><span class="line">sysctl net.bridge.bridge-nf-call-iptables net.bridge.bridge-nf-call-ip6tables net.ipv4.ip_forward</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指令确认 br_netfilter 和 overlay 模块被加载：</span></span><br><span class="line">lsmod | grep br_netfilter</span><br><span class="line">lsmod | grep overlay</span><br></pre></td></tr></table></figure><h3 id="安装containerd容器">安装containerd容器</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装Containerd：</span></span><br><span class="line"><span class="built_in">sudo</span> apt install -y containerd</span><br><span class="line"><span class="comment"># curl -LO https://github.com/containerd/containerd/releases/download/v1.7.13/cri-containerd-cni-1.7.13-linux-amd64.tar.gz</span></span><br><span class="line"><span class="comment"># sudo tar -zxvf cri-containerd-cni-1.7.13-linux-amd64.tar.gz -C /</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看版本</span></span><br><span class="line">containerd -v</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成配置文件：</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">mkdir</span> -p /etc/containerd</span><br><span class="line">containerd config default | <span class="built_in">sudo</span> <span class="built_in">tee</span> /etc/containerd/config.toml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改配置文件： 将SystemdCgroup设置为true</span></span><br><span class="line"><span class="built_in">sudo</span> sed -i <span class="string">&#x27;s/SystemdCgroup = false/SystemdCgroup = true/&#x27;</span> /etc/containerd/config.toml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改镜像</span></span><br><span class="line"><span class="built_in">sudo</span> vi /etc/containerd/config.toml</span><br><span class="line"><span class="comment"># 修改 sandbox_image 值为 registry.aliyuncs.com/google_containers/pause:3.9</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">enable</span> --now containerd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl restart containerd</span><br><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">enable</span> containerd</span><br><span class="line"><span class="built_in">sudo</span> systemctl status containerd</span><br><span class="line"></span><br><span class="line"><span class="comment">############################################## 使用（安装nginx）</span></span><br><span class="line"><span class="comment"># 拉取镜像</span></span><br><span class="line">ctr image pull docker.io/library/nginx:latest</span><br><span class="line"><span class="comment"># 列出镜像</span></span><br><span class="line">ctr image <span class="built_in">ls</span></span><br><span class="line"><span class="comment"># 删除镜像</span></span><br><span class="line">ctr image <span class="built_in">rm</span> docker.io/library/nginx:latest</span><br><span class="line"><span class="comment"># 导入镜像</span></span><br><span class="line">ctr image import image.tar</span><br><span class="line"><span class="comment"># 导出镜像</span></span><br><span class="line">ctr image <span class="built_in">export</span> image.tar docker.io/library/nginx:latest</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建容器</span></span><br><span class="line">ctr container create docker.io/library/nginx:latest my-nginx</span><br><span class="line"><span class="comment"># 启动容器任务</span></span><br><span class="line">ctr task start my-nginx</span><br><span class="line"><span class="comment"># 停止容器任务</span></span><br><span class="line">ctr task <span class="built_in">kill</span> my-nginx</span><br><span class="line"><span class="comment"># 删除容器</span></span><br><span class="line">ctr container <span class="built_in">rm</span> my-nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看任务列表</span></span><br><span class="line">ctr task <span class="built_in">ls</span></span><br><span class="line"><span class="comment"># 进入容器</span></span><br><span class="line">ctr task <span class="built_in">exec</span> --<span class="built_in">tty</span> --exec-id shell my-nginx /bin/sh</span><br><span class="line"><span class="comment"># 查看容器日志</span></span><br><span class="line">ctr task logs my-nginx</span><br></pre></td></tr></table></figure><h3 id="安装Kubernetes组件">安装Kubernetes组件</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 必要组件</span></span><br><span class="line"><span class="built_in">sudo</span> apt-get update</span><br><span class="line"><span class="built_in">sudo</span> apt-get install -y apt-transport-https ca-certificates curl gpg</span><br><span class="line"></span><br><span class="line"><span class="comment">#Kubernetes 软件包仓库的公共签名密钥</span></span><br><span class="line">curl -fsSL https://pkgs.k8s.io/core:/stable:/v1.28/deb/Release.key | <span class="built_in">sudo</span> gpg --dearmor -o /etc/apt/keyrings/kubernetes-apt-keyring.gpg</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加 Kubernetes apt 仓库</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;deb [signed-by=/etc/apt/keyrings/kubernetes-apt-keyring.gpg] https://pkgs.k8s.io/core:/stable:/v1.28/deb/ /&#x27;</span> | <span class="built_in">sudo</span> <span class="built_in">tee</span> /etc/apt/sources.list.d/kubernetes.list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新安装</span></span><br><span class="line"><span class="built_in">sudo</span> apt-get update</span><br><span class="line"><span class="built_in">sudo</span> apt-get install -y kubelet kubeadm kubectl</span><br><span class="line"><span class="built_in">sudo</span> apt-mark hold kubelet kubeadm kubectl</span><br><span class="line"></span><br><span class="line">kubeadm version</span><br></pre></td></tr></table></figure><h2 id="集群安装">集群安装</h2><h3 id="初始化集群">初始化集群</h3><p>在主节点上执行这行命令将主节点的镜像拉取下来：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过 kubeadm version 确定版本号</span></span><br><span class="line"><span class="built_in">sudo</span> kubeadm config images pull \</span><br><span class="line">--image-repository=registry.aliyuncs.com/google_containers \</span><br><span class="line">--kubernetes-version=v1.28.15 \</span><br><span class="line">--cri-socket=unix:///run/containerd/containerd.sock</span><br></pre></td></tr></table></figure><p>执行集群初始化，注意IP和版本以及网络地址（network、service 可保持默认，需要与其他对应）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> kubeadm init \</span><br><span class="line">--apiserver-advertise-address=192.168.159.200 \</span><br><span class="line">--image-repository=registry.aliyuncs.com/google_containers \</span><br><span class="line">--kubernetes-version=v1.28.15 \</span><br><span class="line">--service-cidr=10.96.0.0/12 \</span><br><span class="line">--pod-network-cidr=10.244.0.0/16 \</span><br><span class="line">--cri-socket=unix:///run/containerd/containerd.sock</span><br></pre></td></tr></table></figure><p>相关参数解释：</p><blockquote><ul class="lvl-1"><li class="lvl-2"><p>apiserver-advertise-address：集群广播地址，用 master 节点的内网 IP。</p></li><li class="lvl-2"><p>image-repository：由于默认拉取镜像地址 <a href="http://k8s.gcr.io">k8s.gcr.io</a> 国内无法访问，这里指定阿里云镜像仓库地址。</p></li><li class="lvl-2"><p>kubernetes-version： K8s 版本，与上面安装的软件版本一致。</p></li><li class="lvl-2"><p>service-cidr：集群 Service 网段。</p></li><li class="lvl-2"><p>pod-network-cidr：集群 Pod 网段。</p></li><li class="lvl-2"><p>cri-socket：指定 cri-socket 接口，我们这里使用 unix:///var/run/cri-dockerd.sock。</p></li></ul></blockquote><p>初始化完成后如图所示：会出现两条命令，需要记录下来。</p><img src="/imgs/image-20250719175104305.png" alt="image-20250719175104305" style="zoom:50%;" /><p>在主节点上执行以下操作：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这个命令句是  kubeadm init 执行后打印的：看上图</span></span><br><span class="line"><span class="built_in">mkdir</span> -p <span class="variable">$HOME</span>/.kube</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">cp</span> -i /etc/kubernetes/admin.conf <span class="variable">$HOME</span>/.kube/config</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">chown</span> $(<span class="built_in">id</span> -u):$(<span class="built_in">id</span> -g) <span class="variable">$HOME</span>/.kube/config</span><br></pre></td></tr></table></figure><h3 id="节点安装">节点安装</h3><p>在所有工作节点上执行这行命令（注意修改为自己的token）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这个命令句是  kubeadm init 执行后打印的：看上图，初始化完后的视图</span></span><br><span class="line">kubeadm <span class="built_in">join</span> 192.168.159.200:6443 \</span><br><span class="line">--token kxzrga.d74axaspi1patvof \</span><br><span class="line">--discovery-token-ca-cert-hash sha256:062b1ad988e637ae9cbeaacf0a89a35fbb5fe582ebb55768fe0ac7c7e6f2ee45 \</span><br><span class="line">--cri-socket=unix:///run/containerd/containerd.sock</span><br></pre></td></tr></table></figure><h3 id="集群查看">集群查看</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在主节点上查看所有节点：</span></span><br><span class="line">kubectl get nodes -o wide</span><br><span class="line"></span><br><span class="line"><span class="comment"># 节点</span></span><br><span class="line">kubectl get nodes</span><br><span class="line"></span><br><span class="line"><span class="comment"># 集群和dns信息</span></span><br><span class="line">kubectl cluster-info</span><br></pre></td></tr></table></figure><p><img src="/imgs/image-20250720172436281.png" alt="image-20250720172436281"></p><h3 id="网络问题">网络问题</h3><p>couldn’t get current server API group list: Get “<a href="http://localhost:8080/api?timeout=32s">http://localhost:8080/api?timeout=32s</a>”: dial tcp 127.0.0.1:8080: connect: connection refused</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment"># kubectl 没有使用到证书与k8s api通信，在初始化集群的时候要想使用kubectl</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 解决方法</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;export KUBECONFIG=/etc/kubernetes/kubelet.conf&quot;</span> &gt;&gt; /etc/profile</span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure><h3 id="NotReady（pod）">NotReady（pod）</h3><p>某些关键的 pod 没有运行起来，可以用以下方式调查原因：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看pod运行状态</span></span><br><span class="line"><span class="built_in">sudo</span> kubectl get pods</span><br><span class="line"><span class="built_in">sudo</span> kubectl get pod --all-namespaces</span><br><span class="line"></span><br><span class="line"><span class="comment">#kube-system的 pod 状态</span></span><br><span class="line"><span class="built_in">sudo</span> kubectl get pod -n kube-system</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看pod节点详情 sudo kubectl describe pod &lt;NAMESPACE_NAME&gt; -n kube-system</span></span><br><span class="line"><span class="built_in">sudo</span> kubectl describe pod coredns-66f779496c-fjq22 -n kube-system</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看容器日志运行日志sudo kubectl logs -f -n &lt;NAMESPACE&gt; &lt;NAMESPACE_NAME&gt;</span></span><br><span class="line"><span class="built_in">sudo</span> kubectl logs -f -n kube-system coredns-66f779496c-fjq22</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查资源限制：检查Pod的资源配置是否合理sudo kubectl get pod &lt;pod-name&gt; -o yaml</span></span><br><span class="line"><span class="comment"># 查看resources字段，确认CPU和内存限制是否满足容器需求。</span></span><br><span class="line"><span class="built_in">sudo</span> kubectl get pod coredns-66f779496c-fjq22 -o yaml</span><br></pre></td></tr></table></figure><p>资源查看：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 检查节点Taints配置</span></span><br><span class="line">kubectl describe node slave201 |grep Taint</span><br><span class="line"><span class="comment"># 如果输出中包含类似 Taints: node-role.kubernetes.io/master:NoSchedule，则说明节点设置了Taints</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证CoreDNS Toleration设置</span></span><br><span class="line"><span class="built_in">sudo</span> kubectl edit deployment coredns -n kube-system</span><br><span class="line"><span class="comment"># 检查CoreDNS的Deployment或DaemonSet YAML文件，确保其包含正确的Toleration配置。以下是示例配置：</span></span><br><span class="line"><span class="comment"># tolerations:</span></span><br><span class="line"><span class="comment">#   - key: CriticalAddonsOnly</span></span><br><span class="line"><span class="comment">#     operator: Exists</span></span><br><span class="line"><span class="comment">#   - effect: NoSchedule</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 确认资源充足</span></span><br><span class="line"><span class="built_in">sudo</span> kubectl describe pod coredns-66f779496c-rhnb9 -n kube-system</span><br><span class="line"><span class="comment"># 如果输出中包含Insufficient cpu，则说明节点资源不足</span></span><br></pre></td></tr></table></figure><h3 id="Pending（CoreDNS）"><a href="http://docs.kubernetes.org.cn/827.html">Pending（CoreDNS）</a></h3><blockquote><p><strong>问题</strong>：coredns Pending</p><p>3 node(s) had untolerated taint {<a href="http://node.kubernetes.io/not-ready:">node.kubernetes.io/not-ready:</a> }. preemption: 0/3 nodes are available: 3 Preemption is not helpful for scheduling.</p><img src="/imgs/image-20250719214020713.png" alt="image-20250719214020713" style="zoom:67%;" /><p><strong>解决</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#########################################  查看 CoreDNS 状态</span></span><br><span class="line"><span class="built_in">sudo</span> kubectl get pod --all-namespaces</span><br><span class="line"><span class="built_in">sudo</span> kubectl get pod -n kube-system</span><br><span class="line"><span class="built_in">sudo</span> kubectl get pods -n kube-system | grep coredns</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查 CoreDNS 服务是否正常运行：</span></span><br><span class="line"><span class="built_in">sudo</span> kubectl get svc -n kube-system | grep kube-dns</span><br><span class="line"></span><br><span class="line"><span class="comment">#  CoreDNS 配置</span></span><br><span class="line"><span class="built_in">sudo</span> kubectl edit configmap coredns -n kube-system</span><br><span class="line"><span class="comment"># 常见配置项说明</span></span><br><span class="line"><span class="comment"># kubernetes：解析 Kubernetes 内部域名。</span></span><br><span class="line"><span class="comment"># forward：将未匹配的域名请求转发到上游 DNS。</span></span><br><span class="line"><span class="comment"># cache：启用 DNS 缓存，提高查询效率。</span></span><br><span class="line"><span class="comment"># reload：自动加载配置变更。</span></span><br><span class="line"><span class="built_in">sudo</span> kubectl edit deployment coredns -n kube-system</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">######################################### 解决 DNS 功能</span></span><br><span class="line"><span class="comment"># 报错内容：3 node(s) had untolerated taint &#123;env_role: &#125;. preemption: 0/3 nodes are available: 3 Preemption is not helpful for scheduling..</span></span><br><span class="line"><span class="built_in">sudo</span> kubectl describe pod coredns-58fbbbd8c5-9f9hl -n kube-system</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查一下看看节点是否被打污点了: node节点变成了NoSchedule</span></span><br><span class="line">kubectl describe node master200 |grep Taint</span><br><span class="line"></span><br><span class="line"><span class="comment"># 出错：去掉污点</span></span><br><span class="line"><span class="built_in">sudo</span> kubectl taint node master200 env_role:NoSchedule-</span><br><span class="line"><span class="built_in">sudo</span> kubectl taint node slave201 env_role:NoSchedule-</span><br><span class="line"><span class="built_in">sudo</span> kubectl taint node slave202 env_role:NoSchedule-</span><br></pre></td></tr></table></figure></blockquote><h3 id="启动">启动</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl restart kubelet</span><br><span class="line"><span class="built_in">sudo</span> systemctl restart containerd</span><br></pre></td></tr></table></figure><h2 id="网络插件"><a href="https://kubernetes.io/zh-cn/docs/concepts/cluster-administration/addons/">网络插件</a></h2><p>除了coredns必选外，其他三个插件选其一即可。</p><p><strong>检查 <code>kubelet</code> 是否正常</strong></p><p>CNI 插件依赖 <code>kubelet</code>，如果 <code>kubelet</code> 没有正确指定 CNI 目录，则会失败：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">journalctl -u kubelet -f | grep cni</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果看到如下报错：failed to read CNI config /etc/cni/net.d: no such file or directory</span></span><br><span class="line"><span class="comment"># 则说明 CNI 目录没有配置正确，需要重启 `kubelet`：</span></span><br><span class="line">systemctl restart kubelet</span><br><span class="line"></span><br><span class="line"><span class="comment"># Kubelet 需要在 /opt/cni/bin/ 目录找到 CNI 可执行文件：如果为空，则 CNI 没有正确安装，需要重新安装 CNI 插件。</span></span><br><span class="line"><span class="built_in">ls</span> -l /opt/cni/bin/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 /etc/cni/net.d/ 是否有 CNI 配置文件：正常情况下应有 CNI 配置文件,如果没有，请重新安装 CNI 插件。</span></span><br><span class="line"><span class="built_in">ls</span> -l /etc/cni/net.d/</span><br></pre></td></tr></table></figure><h3 id="coredns">coredns</h3><p>DNS 是使用集群插件 管理器自动启动的内置的 Kubernetes 服务。</p><blockquote><p>从 Kubernetes v1.12 开始，CoreDNS 是推荐的 DNS 服务器，取代了 kube-dns。 如果 你的集群原来使用 kube-dns，你可能部署的仍然是 kube-dns 而不是 CoreDNS。</p></blockquote><p>重新安装  <a href="https://docker.aityp.com/image/quay.io/prometheus/busybox:latest">镜像</a></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除Deployment和ConfigMap</span></span><br><span class="line"><span class="built_in">sudo</span> kubectl delete deployment coredns -n kube-system \</span><br><span class="line"><span class="built_in">sudo</span> kubectl delete configmaps coredns -n kube-system</span><br><span class="line"><span class="comment"># 清理集群角色和绑定</span></span><br><span class="line"><span class="built_in">sudo</span> kubectl delete clusterrolebindings system:coredns \</span><br><span class="line"><span class="built_in">sudo</span> kubectl delete clusterroles system:coredns</span><br><span class="line"><span class="comment"># 删除ServiceAccount</span></span><br><span class="line"><span class="built_in">sudo</span> kubectl delete serviceaccounts coredns -n kube-system</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新CoreDNS配置并验证，Kubernetes会自动重新创建CoreDNS Pod</span></span><br><span class="line"><span class="comment"># sudo kubectl delete pod -l k8s-app=kube-dns -n kube-system</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载部署脚本文件：</span></span><br><span class="line">wget https://raw.githubusercontent.com/coredns/deployment/master/kubernetes/deploy.sh</span><br><span class="line"><span class="built_in">chmod</span> +x deploy.sh</span><br><span class="line">apt -y install jq</span><br><span class="line"><span class="comment"># 下载coredns.yaml.sed文件： -O coredns.yaml</span></span><br><span class="line">wget https://raw.githubusercontent.com/coredns/deployment/master/kubernetes/coredns.yaml.sed</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改clusterIP（如果需要）： 默认的clusterIP为10.96.0.10，如果需要修改，可以执行以下命令：</span></span><br><span class="line">./deploy.sh -i 10.96.0.10 &gt; coredns.yaml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更换源 image: coredns/coredns:1.9.4  </span></span><br><span class="line"><span class="comment"># 为    image: swr.cn-north-4.myhuaweicloud.com/ddn-k8s/docker.io/coredns/coredns:1.9.4</span></span><br><span class="line"><span class="built_in">sudo</span> kubectl apply -f coredns.yaml</span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> kubectl get pod --all-namespaces</span><br><span class="line"><span class="built_in">sudo</span> kubectl get pods -n kube-system -w</span><br><span class="line"><span class="built_in">sudo</span> kubectl get pods -n kube-system -l k8s-app=kube-dns</span><br><span class="line"></span><br><span class="line"><span class="comment">######################################### 验证 DNS 功能</span></span><br><span class="line">vim busybox.yaml</span><br><span class="line"><span class="comment"># 输入 :set paste解决编辑YML文件时，遇到自动缩进导致格式混乱的问题</span></span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">name: busybox</span><br><span class="line">namespace: default</span><br><span class="line">spec:</span><br><span class="line">containers:</span><br><span class="line">  - name: busybox</span><br><span class="line">    image: swr.cn-north-4.myhuaweicloud.com/ddn-k8s/quay.io/prometheus/busybox</span><br><span class="line">    <span class="built_in">command</span>:</span><br><span class="line">      - <span class="built_in">sleep</span></span><br><span class="line">      - <span class="string">&quot;3600&quot;</span></span><br><span class="line">    imagePullPolicy: IfNotPresent</span><br><span class="line">  restartPolicy: Always</span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> kubectl apply -f busybox.yaml</span><br><span class="line"><span class="built_in">sudo</span> watch kubectl get pods busybox</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一旦该 pod 运行，您就可以在环境中执行 nslookup。如果您看到Server的内容，则 DNS 工作正常</span></span><br><span class="line"><span class="built_in">sudo</span> kubectl <span class="built_in">exec</span> -ti busybox -- nslookup kubernetes.default</span><br></pre></td></tr></table></figure><h3 id="flannel"><a href="https://github.com/flannel-io/flannel">flannel</a></h3><p>由 CoreOS 开发的项目 Flannel，可能是最直接和最受欢迎的 CNI 插件。</p><blockquote><p>它是容器编排系统中最成熟的网络结构示例之一，旨在实现更好的容器间和主机间网络。随着 CNI 概念的兴起，Flannel CNI 插件算是早期的入门。</p><p>与其他方案相比，Flannel 相对容易安装和配置。</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">curl -LO https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml</span><br><span class="line"><span class="comment"># 修改 kube-flannel.yml </span></span><br><span class="line"><span class="comment"># 将 image: quay.io/coreos/flannel:v0.13.1-rc2 修改为 </span></span><br><span class="line"><span class="comment">#  image: swr.cn-north-4.myhuaweicloud.com/ddn-k8s/quay.io/coreos/flannel:v0.13.1-rc2</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> kubectl apply -f kube-flannel.yml</span><br><span class="line"></span><br><span class="line"><span class="comment">#监控安装过程</span></span><br><span class="line"><span class="built_in">sudo</span> watch kubectl get all -o wide -n kube-flannel</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看pod状态</span></span><br><span class="line"><span class="built_in">sudo</span> kubectl get pod -n kube-flannel</span><br><span class="line"><span class="built_in">sudo</span> kubectl get pod --all-namespaces</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看服务节点状态</span></span><br><span class="line">kubectl get nodes</span><br><span class="line">kubectl get nodes -o wide</span><br></pre></td></tr></table></figure><h3 id="calico"><a href="https://docs.tigera.io/calico/latest/getting-started/kubernetes/quickstart">calico</a></h3><p>Calico 是 Kubernetes 生态系统中另一种流行的网络选择。</p><blockquote><p>虽然 Flannel 被公认为是最简单的选择，但 Calico 以其性能、灵活性而闻名。Calico 的功能更为全面，不仅提供主机和 pod 之间的网络连接，还涉及网络安全和管理。Calico CNI 插件在 CNI 框架内封装了 Calico 的功能。</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#安装Tigera Calico操作符和自定义资源</span></span><br><span class="line">curl -LO https://raw.githubusercontent.com/projectcalico/calico/v3.30.2/manifests/tigera-operator.yaml</span><br><span class="line"><span class="comment"># 修改镜像quay.io/tigera/operator:v1.38.3 到国内 https://docker.aityp.com/</span></span><br><span class="line"><span class="comment"># image: swr.cn-north-4.myhuaweicloud.com/ddn-k8s/quay.io/tigera/operator:v1.38.3</span></span><br><span class="line"><span class="built_in">sudo</span> kubectl apply -f tigera-operator.yaml</span><br><span class="line"><span class="built_in">sudo</span> kubectl delete -f tigera-operator.yaml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载客户端资源文件</span></span><br><span class="line">curl -LO https://raw.githubusercontent.com/projectcalico/calico/v3.30.2/manifests/custom-resources.yaml</span><br><span class="line"><span class="comment"># 修改pod的网段地址</span></span><br><span class="line">sed -i <span class="string">&#x27;s/cidr: 192.168.0.0/cidr: 10.244.0.0/g&#x27;</span> custom-resources.yaml</span><br><span class="line"><span class="built_in">sudo</span> kubectl apply -f custom-resources.yaml</span><br><span class="line"><span class="built_in">sudo</span> kubectl delete -f custom-resources.yaml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 监控</span></span><br><span class="line"><span class="built_in">sudo</span> watch kubectl get all -o wide -n calico-system</span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> kubectl describe pod csi-node-driver-ks4k9 -n calico-system</span><br><span class="line"><span class="built_in">sudo</span> kubectl get pod -n calico-system</span><br><span class="line"><span class="built_in">sudo</span> kubectl get pod --all-namespaces</span><br></pre></td></tr></table></figure><h3 id="cilium">cilium</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f https://raw.githubusercontent.com/cilium/cilium/v1.12/install/kubernetes/quick-install.yaml</span><br></pre></td></tr></table></figure><h2 id="Dashboard"><a href="https://github.com/kubernetes/dashboard/releases">Dashboard</a></h2><p>一定要与k8s版本对应，在官网查看支持的版本。</p><p><img src="/imgs/image-20250720163701810.png" alt="image-20250720163701810"></p><h3 id="安装插件">安装插件</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看k8s 版本Version: v1.28.15</span></span><br><span class="line">kubectl version</span><br><span class="line"></span><br><span class="line">wget https://raw.githubusercontent.com/kubernetes/dashboard/v2.7.0/aio/deploy/recommended.yaml</span><br><span class="line"><span class="comment"># 把recommended.yaml里访问方式调整为nodeport,是集群外部能否访问</span></span><br><span class="line"><span class="comment"># 添加 type 和 nodePort 节点</span></span><br><span class="line">spec:</span><br><span class="line">  <span class="built_in">type</span>: NodePort</span><br><span class="line">  ports:</span><br><span class="line">    - port: 443</span><br><span class="line">      targetPort: 8443</span><br><span class="line">      nodePort: 30012</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改镜像</span></span><br><span class="line"><span class="comment"># image 前加 swr.cn-north-4.myhuaweicloud.com/ddn-k8s/docker.io/， 如下：</span></span><br><span class="line"><span class="comment"># image: swr.cn-north-4.myhuaweicloud.com/ddn-k8s/docker.io/kubernetesui/dashboard:v2.7.0</span></span><br><span class="line"><span class="comment"># image: swr.cn-north-4.myhuaweicloud.com/ddn-k8s/docker.io/kubernetesui/metrics-scraper:v1.0.8</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> kubectl apply -f recommended.yaml</span><br><span class="line"><span class="comment"># 查看状态</span></span><br><span class="line"><span class="built_in">sudo</span> kubectl get all -n kubernetes-dashboard</span><br><span class="line"><span class="comment"># 端口信息</span></span><br><span class="line"><span class="built_in">sudo</span> kubectl get pod,svc -n kubernetes-dashboard</span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问： https://192.168.159.200:30012/</span></span><br></pre></td></tr></table></figure><h3 id="获取token：方式一">获取token：方式一</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 输入 :set paste解决编辑YML文件时，遇到自动缩进导致格式混乱的问题</span></span><br><span class="line">vim admin-token.yaml</span><br><span class="line"><span class="comment"># 粘贴以下内容</span></span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: ServiceAccount</span><br><span class="line">metadata:</span><br><span class="line">  name: admin</span><br><span class="line">  namespace: kubernetes-dashboard</span><br><span class="line">---</span><br><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">kind: ClusterRoleBinding</span><br><span class="line">metadata:</span><br><span class="line">  name: admin</span><br><span class="line">roleRef:</span><br><span class="line">  apiGroup: rbac.authorization.k8s.io</span><br><span class="line">  kind: ClusterRole</span><br><span class="line">  name: cluster-admin</span><br><span class="line">subjects:</span><br><span class="line">  - kind: ServiceAccount</span><br><span class="line">    name: admin</span><br><span class="line">    namespace: kubernetes-dashboard</span><br><span class="line">  </span><br><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Secret</span><br><span class="line">metadata:</span><br><span class="line">  name: kubernetes-dashboard-token</span><br><span class="line">  namespace: kubernetes-dashboard</span><br><span class="line">  annotations:</span><br><span class="line">    kubernetes.io/service-account.name: <span class="string">&quot;admin&quot;</span></span><br><span class="line"><span class="built_in">type</span>: kubernetes.io/service-account-token</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> kubectl apply -f admin-token.yaml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看kubernetes-dashboard下面的secret</span></span><br><span class="line"><span class="built_in">sudo</span> kubectl get secret -n kubernetes-dashboard</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看登录token(获取令牌)</span></span><br><span class="line"><span class="built_in">sudo</span> kubectl describe secret kubernetes-dashboard-token -n kubernetes-dashboard</span><br><span class="line"><span class="built_in">sudo</span> kubectl -n kubernetes-dashboard describe secret $(kubectl -n kubernetes-dashboard get secret | grep admin-user | awk <span class="string">&#x27;&#123;print $1&#125;&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="获取token：方式二">获取token：方式二</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建Service Account</span></span><br><span class="line">kubectl create serviceaccount dashboard-admin-sa -n kubernetes-dashboard</span><br><span class="line"><span class="comment"># 绑定ClusterRole</span></span><br><span class="line">kubectl create clusterrolebinding dashboard-admin-sa-binding \</span><br><span class="line">  --clusterrole=cluster-admin \</span><br><span class="line">  --serviceaccount=kubernetes-dashboard:dashboard-admin-sa</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 获取Token信息</span></span><br><span class="line">kubectl -n kubernetes-dashboard get secret $(kubectl -n kubernetes-dashboard get sa dashboard-admin-sa -o jsonpath=<span class="string">&quot;&#123;.secrets[0].name&#125;&quot;</span>) -o jsonpath=<span class="string">&quot;&#123;.data.token&#125;&quot;</span> | <span class="built_in">base64</span> --decode</span><br></pre></td></tr></table></figure><h3 id="常见问题及解答">常见问题及解答</h3><table><thead><tr><th>问题</th><th>答案</th></tr></thead><tbody><tr><td>1. 创建Service Account时提示权限不足</td><td>确保你有足够的权限在集群中创建Service Account。如果你是集群管理员，可以尝试使用<code>cluster-admin</code>权限。</td></tr><tr><td>2. 获取Token信息时提示找不到Secret</td><td>确认Service Account名称是否正确，且是否已经成功创建。可以通过<code>kubectl get sa</code>命令查看Service Account列表。</td></tr><tr><td>3. 登录时提示Token无效</td><td>确认Token信息是否正确复制，且Token是否已经过期。Token的有效期通常是24小时，过期后需要重新创建。</td></tr><tr><td>4. 无法打开Kubernetes Dashboard</td><td>确认Kubernetes Dashboard是否已经正确安装并启动。可以通过<code>kubectl get pods -n kubernetes-dashboard</code>命令查看Dashboard的运行状态。</td></tr><tr><td>5. 登录后无法看到集群资源</td><td>确认Service Account是否已经绑定到正确的ClusterRole，且ClusterRole是否拥有足够的权限。</td></tr></tbody></table><h3 id="效果展示">效果展示</h3><p><img src="/imgs/image-20250720172611409.png" alt="image-20250720172611409"></p><p><img src="/imgs/image-20250720172701262.png" alt="image-20250720172701262"></p><h2 id="部署nginx">部署nginx</h2><p><code>vim nginx-deploy.yaml</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx-deploy</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-deploy</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx-deploy</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx-deploy</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">registry.cn-shenzhen.aliyuncs.com/xiaohh-docker/nginx:1.25.4</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx-deploy</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-svc</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">nodePort:</span> <span class="number">30080</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx-deploy</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span></span><br></pre></td></tr></table></figure><p>部署并查看</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> kubectl apply -f nginx-deploy.yaml</span><br><span class="line"><span class="built_in">sudo</span> kubectl get all -o wide</span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问</span></span><br><span class="line">kubectl get svc</span><br><span class="line">kubectl describe service nginx-svc</span><br><span class="line">kubectl get nodes</span><br><span class="line"></span><br><span class="line"><span class="comment"># 页面  http://192.168.159.200:30080/</span></span><br></pre></td></tr></table></figure><img src="/imgs/image-20250720161241610.png" alt="image-20250720161241610" style="zoom:57%;" />]]></content>
    
    
    <summary type="html">Ubuntu24安装k8s集群，配置网络插件，使用containerd容器搭建Nginx服务，安装Dashboard可视化插件。</summary>
    
    
    
    <category term="CICD" scheme="https://pengline.github.io/categories/CICD/"/>
    
    <category term="k8s" scheme="https://pengline.github.io/categories/CICD/k8s/"/>
    
    
    <category term="docker-compose" scheme="https://pengline.github.io/tags/docker-compose/"/>
    
    <category term="containerd" scheme="https://pengline.github.io/tags/containerd/"/>
    
    <category term="k8s" scheme="https://pengline.github.io/tags/k8s/"/>
    
    <category term="Ubuntu" scheme="https://pengline.github.io/tags/Ubuntu/"/>
    
    <category term="Kubernetes" scheme="https://pengline.github.io/tags/Kubernetes/"/>
    
    <category term="CoreDNS" scheme="https://pengline.github.io/tags/CoreDNS/"/>
    
    <category term="Calico" scheme="https://pengline.github.io/tags/Calico/"/>
    
    <category term="Dashboard" scheme="https://pengline.github.io/tags/Dashboard/"/>
    
  </entry>
  
  <entry>
    <title>Web 系统中 CPU 飙高的可能原因分析</title>
    <link href="https://pengline.github.io/2025/09/08/957a28884b7b4f9b92591bf81eb174fd/"/>
    <id>https://pengline.github.io/2025/09/08/957a28884b7b4f9b92591bf81eb174fd/</id>
    <published>2025-09-08T03:51:36.694Z</published>
    <updated>2025-09-09T01:43:21.270Z</updated>
    
    <content type="html"><![CDATA[<p>CPU 飙高（CPU 使用率持续超过 80%，甚至接近100%）是系统性能中最常见的问题，可能影响系统响应速度、服务可用性甚至导致宕机。</p><p>在 Java Web 系统中，若同时使用 Redis、MySQL、ES等中间件，CPU 飙升的原因可能不仅来自 Java 应用本身，也可能由这些外部组件的交互、配置或异常行为引发，需结合相关工具，进行<strong>端到端根因分析</strong>，才能精准定位和解决。。</p><blockquote><ul class="lvl-1"><li class="lvl-2"><p>Java 线程堆栈（jstack/Arthas）</p></li><li class="lvl-2"><p>GC 情况（jstat）</p></li><li class="lvl-2"><p>中间件慢查询日志（Redis/MySQL/ES）</p></li><li class="lvl-2"><p>连接池/线程池监控</p></li><li class="lvl-2"><p>系统资源指标（CPU、上下文切换、I/O）</p></li></ul></blockquote><p>以下从 <strong>Java 应用层、Redis、MySQL、系统交互层</strong> 等维度深入分析 CPU 飙升的可能原因。</p><h2 id="Java-应用层">Java 应用层</h2><p>高并发、高吞吐的业务消耗较多CPU资源，如果CPU资源未达到瓶颈，属于正常业务场景。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看 cpu 占用率高的线程</span></span><br><span class="line">ps H -eo user,pid,ppid,tid,<span class="keyword">time</span>,%cpu,cmd --<span class="built_in">sort</span>=%cpu</span><br><span class="line"></span><br><span class="line"><span class="comment">#  查看占用内存最多的程序</span></span><br><span class="line">ps aux|<span class="built_in">head</span> -1;ps aux|grep -v PID|<span class="built_in">sort</span> -rn -k +4|<span class="built_in">head</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看占用cpu最多的程序</span></span><br><span class="line">ps aux|<span class="built_in">head</span> -1;ps aux|grep -v PID|<span class="built_in">sort</span> -rn -k +3|<span class="built_in">head</span></span><br></pre></td></tr></table></figure><h3 id="死循环或业务逻辑异常">死循环或业务逻辑异常</h3><ul class="lvl-0"><li class="lvl-2"><p>某个 Controller 或 Service 方法陷入死循环（如 while(true)、递归无终止）。</p></li><li class="lvl-2"><p>复杂业务逻辑（如多重嵌套循环、大 List 遍历、未分页的全表遍历）。</p></li><li class="lvl-2"><p>递归调用无终止条件或深度过大。</p></li><li class="lvl-2"><p>正则表达式回溯爆炸（如 <code>.*.*.*</code> 匹配长字符串）。</p></li></ul><h3 id="GC-频繁（Full-GC-Young-GC）">GC 频繁（Full GC / Young GC）</h3><ul class="lvl-0"><li class="lvl-2"><p>内存泄漏 → 对象堆积 → 触发 Full GC → STW + CPU 飙升。</p></li><li class="lvl-2"><p>大对象分配、缓存未清理、MyBatis 一级缓存过大等。</p></li><li class="lvl-2"><p>GC 线程本身是 CPU 密集型（尤其是 ParallelGC、G1 并发阶段）。</p></li><li class="lvl-2"><p>内存泄漏或对象创建过快，导致 Full GC 频繁触发。</p></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过 `jstat`、`jstack`、GC 日志分析。</span></span><br><span class="line">jstat -gcutil &lt;pid&gt; 1000  <span class="comment"># 查看 GC 频率和耗时</span></span><br><span class="line">jmap -histo:live &lt;pid&gt;    <span class="comment"># 查看对象分布</span></span><br></pre></td></tr></table></figure><h3 id="线程池配置不当-锁竞争">线程池配置不当 / 锁竞争</h3><ul class="lvl-0"><li class="lvl-2"><p>线程池过小 → 请求堆积 → 重试/超时 → CPU 忙等（瞬时大量请求涌入，线程池满负荷运行）。</p></li><li class="lvl-2"><p>synchronized / ReentrantLock 竞争激烈 → 线程 BLOCKED → 上下文切换频繁 → CPU 飙升。</p></li><li class="lvl-2"><p>数据库连接池耗尽 → 线程阻塞等待 → 后续请求堆积。</p></li><li class="lvl-2"><p>未做限流、降级或熔断机制，导致 CPU 被打满。</p></li><li class="lvl-2"><p>同步阻塞操作过多（如同步 I/O、锁竞争），线程频繁切换。</p></li></ul><blockquote><p>排查：<code>jstack</code> 查看大量 BLOCKED/WAITING 线程；</p><p>Arthas <code>thread -n 3</code> 查看最忙线程。</p></blockquote><h3 id="序列化-反序列化开销大">序列化/反序列化开销大</h3><ul class="lvl-0"><li class="lvl-2"><p>大量 JSON（如 FastJSON/Jackson）解析大对象（如 ES 返回万条数据）。</p></li><li class="lvl-2"><p>对象深度嵌套、循环引用、无缓存的反射调用。</p></li></ul><h3 id="算法复杂度高">算法复杂度高</h3><ul class="lvl-0"><li class="lvl-2"><p>使用了时间复杂度为 O(n²)、O(n³) 甚至更高的算法处理大数据量。</p></li><li class="lvl-2"><p>未优化的排序、搜索、正则匹配等操作在高频调用下拖垮 CPU。</p></li></ul><h3 id="Java实例CPU过高的排查方法">Java实例CPU过高的排查方法</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">top</span><br><span class="line">top -Hp 4042</span><br><span class="line"><span class="built_in">printf</span> <span class="string">&quot;%x\n&quot;</span>  14068  <span class="comment"># 36f4</span></span><br><span class="line">jstack 4042 | grep -a 36f4</span><br><span class="line">jstack 4042 &gt; /opt/temp.txt</span><br></pre></td></tr></table></figure><ol><li class="lvl-3"><p>使用<strong>top</strong>命令找到占用CPU较高的进程，并记录下 PID（进程号）</p><p><code>ps H -eo user,pid,ppid,tid,time,%cpu,cmd --sort=%cpu</code>  得到  4042</p><blockquote><p>或者根据 <code>jps -l</code> ，或 <code>ps -ef | grep java</code> 命令找出java应用程序对应的进程ID号</p></blockquote></li><li class="lvl-3"><p>根据进程ID查找其下的全部线程</p><p><code>top -Hp PID</code>  按照CPU使用率倒序排序  ， 如：<code>top -Hp 4042</code>  得到 14068</p><blockquote><p>或者用<strong>jstack</strong> 命令，直接查询线程状态</p></blockquote></li><li class="lvl-3"><p>将线程ID，转换为16进制</p><p><code>printf &quot;%x\n&quot;  PID</code>，如：<code>printf &quot;%x\n&quot;  14068</code>  得到  36f4</p></li><li class="lvl-3"><p>定位到具体的线程</p><p><code>jstack 进程ID| grep -a 16进制线程ID</code>， 如：<code>jstack 4042 | grep -a 36f4</code></p><blockquote><p>可能出错： <code>Unable to open socket file: target process not responding or HotSpot VM not loaded</code><br>原因分析：</p><ul class="lvl-3"><li class="lvl-2">jvm运行时会生成目录<code>/tmp/hsperfdata_&lt;username&gt;/&lt;pid&gt;</code>，用于存放jvm进程信息。</li><li class="lvl-2">jps、jstack等工具读取该目录下的pid文件获取连接信息。</li><li class="lvl-2">操作系统为了防止/tmp目录文件过多，有删除管理机制：每天用tmpwatch命令检查并删除 /tmp下超过240小时未访问过的文件和目录。</li></ul><p>解决方法：</p><ol><li class="lvl-3"><p>编辑配置，<code>vim /etc/cron.daily/tmpwatch</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加排除规则。使用 --exclude 参数来排除 hsperfdata 目录</span></span><br><span class="line">/usr/sbin/tmpwatch <span class="string">&quot;<span class="variable">$flags</span>&quot;</span> 240 /tmp --exclude=/tmp/hsperfdata_*    </span><br><span class="line"></span><br><span class="line"><span class="comment"># 排除所有用户下的该目录：</span></span><br><span class="line">/usr/sbin/tmpwatch <span class="string">&quot;<span class="variable">$flags</span>&quot;</span> 240 /tmp --exclude=<span class="string">&#x27;^/tmp/hsperfdata_&#x27;</span></span><br></pre></td></tr></table></figure></li><li class="lvl-3"><p>或者 更改 JVM 的临时目录<code>java -Djava.io.tmpdir=/data/tmpdir -jar demo.jar</code></p></li></ol></blockquote></li><li class="lvl-3"><p>将某个进程的全部堆栈信息放入临时文件</p><p><code>jstack PID &gt;  /opt/temp.txt</code> ，如：<code>jstack 4042 &gt; /opt/temp.txt</code></p></li><li class="lvl-3"><p>使用vi命令查看该文件，然后输入线程转换后的16进制数字搜索，<strong>查看线程状态</strong>，如：1006</p><p><img src="/imgs/image-20210627180320327.png" alt="image-20210627180320327"></p><blockquote><ul class="lvl-3"><li class="lvl-2"><p>线程名称：SimplePauseDetectorThread_1</p></li><li class="lvl-2"><p>线程类型：daemon</p></li><li class="lvl-2"><p>优先级prio: 5，默认是5</p></li><li class="lvl-2"><p>jvm线程id：tid=0x00007f…，jvm内部线程的唯一标识（通过java.lang.Thread.getId()获取，通常用自增方式实现。）</p></li><li class="lvl-2"><p>对应系统线程id（NativeThread ID）：nid=0xbd2，和top命令查看的线程pid对应，不过一个是10进制，一个是16进制。（通过命令：top -H -p pid，可以查看该进程的所有线程信息）</p></li><li class="lvl-2"><p>线程状态：waiting on condition / Object.wait() / waiting for monitor entry</p></li><li class="lvl-2"><p>起始栈地址：[0x00007f…]</p></li></ul><p>对于<strong>thread dump</strong>信息，主要关注的是线程的状态和其执行堆栈，堆栈信息应该逆向解读（从下往上）</p></blockquote></li></ol><h2 id="DB-层相关原因">DB 层相关原因</h2><p>在使用 MySQL 的过程中会遇到各种瓶颈问题，常见的是 IO 瓶颈，但是有时候会出现服务器 CPU 使用率超过 100%，应用页面访问慢，登录服务器负载很高。</p><h3 id="慢查询导致线程阻塞">慢查询导致线程阻塞</h3><ul class="lvl-0"><li class="lvl-2"><p>未加索引、索引失效、关联查询复杂 → SQL 执行慢 → Java 线程阻塞等待 → 请求堆积 → CPU 飙升（忙等/重试）。</p></li><li class="lvl-2"><p>MyBatis 生成 N+1 查询，循环中查数据库。</p></li></ul><blockquote><ul class="lvl-1"><li class="lvl-2"><p>MySQL <code>slow_query_log</code>、<code>SHOW PROCESSLIST</code></p></li><li class="lvl-2"><p>Arthas <code>monitor</code> 或 <code>trace</code> 拦截 Mapper 方法耗时</p></li><li class="lvl-2"><p><code>EXPLAIN</code> 分析执行计划</p></li></ul></blockquote><h3 id="连接池耗尽-事务未提交">连接池耗尽 / 事务未提交</h3><ul class="lvl-0"><li class="lvl-2"><p>Druid/HikariCP 连接池 maxActive 设置过小 → 获取连接阻塞。</p></li><li class="lvl-2"><p>事务未提交（如忘记 commit 或异常未回滚）→ 连接占用 → 后续线程阻塞。</p></li></ul><blockquote><ul class="lvl-1"><li class="lvl-2"><p>监控活跃连接数、等待线程数。</p></li><li class="lvl-2"><p>日志搜索 “wait millis”、“getConnection timeout”。</p></li></ul></blockquote><h3 id="大结果集查询-Java-处理开销">大结果集查询 + Java 处理开销</h3><ul class="lvl-0"><li class="lvl-2"><p><code>SELECT * FROM table</code> 无分页 → 返回 10 万行 → Java 端循环处理 → CPU 飙升。</p></li><li class="lvl-2"><p>ResultSet 未及时关闭 → 内存 + CPU 双重压力。</p></li></ul><h3 id="DB实例CPU过高的排查方法">DB实例CPU过高的排查方法</h3><p>SQL 问题导致 CPU 使用率过高是最常见的现象，比如 group by、order by、join 等，这些很大程度影响 SQL 执行效率，从而占用大量的系统资源。</p><ul class="lvl-0"><li class="lvl-2"><p><strong>SQL分析</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> # 查看 MySQL 进程（两种方式）</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">full</span> processlist; </span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> information_schema.processlist;</span><br><span class="line">     # command：执行的数据库操作类型</span><br><span class="line">     # sleep：休眠状态</span><br><span class="line">     # Query：查询状态</span><br><span class="line">     # <span class="keyword">connect</span>：连接状态</span><br><span class="line">     # <span class="type">time</span>：已经执行的时间，单位秒</span><br><span class="line">     # info：已经执行的 <span class="keyword">SQL</span></span><br><span class="line">     # state：<span class="keyword">SQL</span> 执行的状态，结果是 <span class="keyword">SQL</span> 语句整个执行状态中的一个，其中包含很多状态</span><br><span class="line"></span><br><span class="line"># 根据问题线程 id 定位 MySQL 中的 <span class="keyword">SQL</span>：</span><br><span class="line"><span class="keyword">select</span> a.user,a.host,a.db,b.thread_os_id,b.thread_id,a.id processlist_id,a.command,a.time,a.state,a.info <span class="keyword">from</span> information_schema.processlist a,performance_schema.threads b </span><br><span class="line"><span class="keyword">where</span> a.id <span class="operator">=</span> b.processlist_id <span class="keyword">and</span> b.thread_os_id<span class="operator">=</span><span class="number">32272</span>;</span><br><span class="line"></span><br><span class="line">#根据问题线程 id 查看其他监控指标：</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">from</span> performance_schema.events_statements_current </span><br><span class="line"><span class="keyword">where</span> thread_id <span class="keyword">in</span> </span><br><span class="line">    (<span class="keyword">select</span> thread_id <span class="keyword">from</span> performance_schema.threads <span class="keyword">where</span> thread_os_id <span class="operator">=</span> <span class="number">32272</span>)\G;</span><br></pre></td></tr></table></figure></li><li class="lvl-2"><p><strong>慢查询日志</strong></p><p>开启慢日志记录</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 开启慢日志记录</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> slow_query_log<span class="operator">=</span><span class="keyword">ON</span>;</span><br><span class="line"></span><br><span class="line"># 查看慢日志信息，日志中记录了慢<span class="keyword">SQl</span></span><br><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;slow_query_log%&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li class="lvl-2"><p><strong>排查日志</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 更改排查日志为 <span class="keyword">TABLE</span> 方式，默认为 FILE 方式</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> log_output<span class="operator">=</span><span class="string">&#x27;TABLE&#x27;</span>;</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> general_log<span class="operator">=</span><span class="keyword">ON</span>;</span><br><span class="line"></span><br><span class="line"># 查询排查日志内容：</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">from</span> mysql.general_log <span class="keyword">ORDER</span> <span class="keyword">BY</span> event_time <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure></li><li class="lvl-2"><p><strong>其他配置</strong></p></li></ul><ol><li class="lvl-3"><p>检查 MySQL <strong>连接数</strong>当前使用是否超过限制。如果超出限制，而且之前的连接没有得到释放，那新的连接肯定会连接不到，造成连接延迟，影响效率。</p></li><li class="lvl-3"><p>MySQL 的 timeout 参数设置问题</p><ul class="lvl-2"><li class="lvl-5"><p>wait_timeout：MySQL 在关闭一个非交互的连接之前所要等待的秒数，其取值范围在 windows 系统中为 1-2147483，linux 系统中为 1-31536000，默认值 28800。</p></li><li class="lvl-5"><p>interactive_time：MySQL 在关闭一个交互的连接之前所要等待的秒数（如 mysql gui tool 中的连接），其取值范围随 wait_timeout 变动，默认值 28800。</p></li></ul><blockquote><p><strong>交互连接</strong>：即在 mysql_real_connect() 函数中使用了 CLIENT_INTERACTIVE 选项。通过 MySQL 客户端连接数据库。</p><p><strong>非交互式连接</strong>：通过 jdbc 连接数据库。</p><p>在 MySQL 默认设置下，当一个连接的空闲时间超过 8 小时后，当业务出现了高峰期，肯定会造成有太多的 TCP 连接没关闭，数据库连接数会不够用。从而会产生 CPU 占用过高，服务器告警等问题。</p><p>访问一次对数据库操作量不大，查询完数据就完成 ok 了，wait_timeout 设置在 120s 内。</p><p>在 MySQL 的官网，修改以上两个参数必须修改 interactive_timeout。如果修改 interactive_timeout，则 wait_timeout 也发生变化，如果只修改 wait_timeout，不生效。</p></blockquote></li></ol><h2 id="Redis-相关原因">Redis 相关原因</h2><p>使用不当，例如高消耗命令、热Key、大Key等，导致CPU使用率异常升高。当平均CPU使用率高于70%、连续5分钟内的CPU平均峰值使用率高于90%时。</p><p>CPU使用率高，主要分为以下三种现象：</p><blockquote><ul class="lvl-1"><li class="lvl-2"><p><strong>某个时间段</strong>，<strong>CPU使用率突然升高</strong>。高并发，数据查询操作频繁。</p></li><li class="lvl-2"><p><strong>某个数据节点的CPU使用率较高</strong>。可能是数据热点和倾斜问题。</p></li><li class="lvl-2"><p><strong>某个Proxy节点的CPU使用率较高</strong>。负载均衡问题，可能是某个IP的攻击或爬虫。</p></li></ul></blockquote><p><strong>导致CPU使用率异常的主要因素</strong>：</p><blockquote><ul class="lvl-1"><li class="lvl-2"><p><strong>高消耗命令</strong>：即时间复杂度为O(N)的命令，其中N为较大值。通常情况下，命令的时间复杂度越高，在执行时会消耗越多的资源，从而导致CPU使用率上升。例如KEYS、HGETALL或使用MGET、MSET、HMSET、HMGET一次操作大量Key等。</p><p>由于命令执行单元为单线程的特性，实例在执行高消耗命令时会引发排队导致应用响应变慢。极端情况下，甚至可能导致实例被整体阻塞，引发应用超时中断或流量跳过缓存层直接到达后端的数据库侧，引发雪崩效应。</p></li><li class="lvl-2"><p><strong>热Key</strong>：某个或某部分Key的请求访问次数显著超过其他Key时，代表此时可能产生了热Key。热Key将会消耗实例的大量CPU资源，从而影响其他Key的访问时延。并且，在集群架构中，如果热Key较为集中地分布在部分数据分片节点，可能会导致CPU使用率倾斜（个别分片的CPU使用率远超其他分片）。</p></li><li class="lvl-2"><p><strong>大Key</strong>：大Key会占用更多的内存，同时，对大Key的访问会显著增加实例的CPU负载和流量。大Key在一定程度上更容易形成热点从而造成CPU使用率高。如果大Key较为集中地分布在部分数据分片节点，可能会导致CPU使用率倾斜、带宽使用率倾斜及内存使用率倾斜。</p></li><li class="lvl-2"><p><strong>短连接</strong>：频繁地建立连接，导致实例的大量资源消耗在连接处理上。</p></li><li class="lvl-2"><p><strong>AOF</strong>：实例默认开启了AOF（append-only file），当实例处于高负载状态时，AOF的写盘行为将会导致CPU使用率升高及实例整体的响应时延增加。</p></li></ul></blockquote><h3 id="大-Key-热-Key-操作阻塞">大 Key / 热 Key 操作阻塞</h3><ul class="lvl-0"><li class="lvl-2"><p>单个 Key 数据过大（如 List 有 100 万元素），执行 <code>LRANGE</code>、<code>HGETALL</code> 等命令阻塞 Redis 单线程。</p></li><li class="lvl-2"><p>导致 Java 客户端线程长时间等待 → 超时重试 → CPU 飙升。</p></li></ul><blockquote><ul class="lvl-1"><li class="lvl-2"><p>Redis <code>SLOWLOG GET 10</code></p></li><li class="lvl-2"><p><code>redis-cli --bigkeys</code></p></li><li class="lvl-2"><p>监控 QPS、响应时间突增</p></li></ul></blockquote><h3 id="连接泄露-连接池耗尽">连接泄露 / 连接池耗尽</h3><ul class="lvl-0"><li class="lvl-2"><p>Jedis/Lettuce 连接未正确释放 → 连接池耗尽 → 获取连接阻塞 → 线程堆积 → CPU 忙等。</p></li><li class="lvl-2"><p>Lettuce 异步回调未处理异常 → 回调线程池被打满。</p></li></ul><blockquote><ul class="lvl-1"><li class="lvl-2"><p>日志中是否有 <code>Timeout waiting for connection</code>。</p></li><li class="lvl-2"><p>监控 Redis 连接数（<code>INFO clients</code>）。</p></li><li class="lvl-2"><p>Arthas <code>watch</code> 拦截 getConnection 方法。</p></li></ul></blockquote><h3 id="频繁-Pipeline-批量操作未优化">频繁 Pipeline / 批量操作未优化</h3><ul class="lvl-0"><li class="lvl-2"><p>一次 Pipeline 执行上千条命令，虽高效但若数据量大，序列化/网络开销仍高。</p></li><li class="lvl-2"><p>客户端 CPU 消耗在网络编解码或数据组装上。</p></li></ul><h3 id="Redis实例CPU过高的排查方法">Redis实例CPU过高的排查方法</h3><p>业务运行超预期，Redis开源版实例的CPU资源无法满足业务需求，可通过增加分片数、副本数。</p><h4 id="启用监控">启用监控</h4><p>可以使用metricbeat+filebeat+monitori进行监控。也可以通过redis proxy 进行代理监控。</p><h4 id="CPU使用率突然升高">CPU使用率突然升高</h4><ul class="lvl-0"><li class="lvl-2"><p><strong>排查并禁用高消耗命令</strong></p><ol><li class="lvl-5"><p>通过性能监控功能，确认CPU使用率高的具体时间段。</p></li><li class="lvl-5"><p>通过下述方法，找出高消耗的命令：</p><p>慢日志功能会记录执行超过指定时间阈值的命令。根据指定时间段和节点的慢查询语句和执行时长，可找出执行时间较长的高消耗命令。redis.conf 慢日志配置 和 查询</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 执行时间大于多少微秒(microsecond，1秒 = 1,000,000 微秒)的查询进行记录。</span></span><br><span class="line">slowlog-log-lower-than 1000</span><br><span class="line"><span class="comment">#最多能保存多少条日志</span></span><br><span class="line">slowlog-max-len 200</span><br><span class="line"></span><br><span class="line"><span class="comment">#打印所有 slow log ，最大长度取决于 slowlog-max-len 选项的值</span></span><br><span class="line">SLOWLOG GET</span><br><span class="line"><span class="comment"># 只打印指定数量的 slow log日志。</span></span><br><span class="line">SLOWLOG GET number</span><br></pre></td></tr></table></figure></li><li class="lvl-5"><p>评估并禁用高风险命令和高消耗命令，例如FLUSHALL、KEYS、HGETALL等。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改配置文件redis.conf，添加如下内容，禁用命令</span></span><br><span class="line">rename-command KEYS     &quot;&quot;</span><br><span class="line">rename-command FLUSHALL &quot;&quot;</span><br><span class="line">rename-command FLUSHDB  &quot;&quot;</span><br><span class="line">rename-command CONFIG   &quot;&quot;</span><br></pre></td></tr></table></figure></li><li class="lvl-5"><p>根据业务情况，调整实例为读写分离架构，对高消耗命令或应用进行分流。</p></li></ol></li><li class="lvl-2"><p><strong>排查并优化短连接</strong></p><ol><li class="lvl-5">通过性能监控功能，确认CPU使用率高的具体时间段。</li><li class="lvl-5">在性能监控页面，查看是否有CPU使用率较高，连接数较高，但QPS（每秒访问次数）未达到预期的现象。如果有，说明可能存在短连接</li><li class="lvl-5">将短连接调整为长连接，例如使用JedisPool连接池连接。</li></ol></li><li class="lvl-2"><p><strong>关闭AOF</strong></p><p>实例默认开启了AOF（append-only file），当实例处于高负载状态时，频繁地执行AOF会一定程度上导致CPU使用率升高。</p><p>在业务允许的前提下，您可以考虑关闭持久化。另外将实例的数据备份时间设定到低访问/维护时间窗口内，降低影响。</p></li></ul><h4 id="节点CPU使用率不一致">节点CPU使用率不一致</h4><p>如果实例为<strong>集群架构</strong>或<strong>读写分离架构</strong>，实例的部分数据分片节点的CPU使用率高，而其他数据分片节点的CPU使用率较低</p><ul class="lvl-0"><li class="lvl-2"><p><strong>排查并禁用高消耗命令</strong></p><p>方法如上</p></li><li class="lvl-2"><p><strong>排查并优化热点Key</strong></p><ol><li class="lvl-5">通过性能监控功能，确认CPU使用率高的具体时间段。</li><li class="lvl-5">在实时Top Key统计的历史页面，选择CPU使用率高的数据节点，可看到CPU使用率高的时间段内有哪些热点Key。</li></ol><blockquote><ul class="lvl-3"><li class="lvl-2"><p>启用代理查询缓存功能（Proxy Query Cache），代理节点会缓存热点Key对应的请求和查询结果，当在有效时间内收到同样的请求时直接返回结果至客户端，无需和后端的数据分片交互，可改善对热点Key的发起大量读请求导致的访问倾斜。</p></li><li class="lvl-2"><p>如果热Key的产生来自于读请求，您可以将实例改造成读写分离架构来降低每个数据分片的读请求压力。</p></li></ul></blockquote></li><li class="lvl-2"><p><strong>排查并优化大Key</strong></p></li></ul><ol><li class="lvl-3"><p>Redis自带的 <code>BIGKEYS</code> 命令可以查询当前Redis中所有key的信息，对整个数据库中的键值对大小情况进行统计分析。会输出每种数据类型中最大的 big key 的信息，对于 String 类型来说，会输出最大 big key 的字节长度，对于集合类型来说，会输出最大 big key 的元素个数。<br><strong><code>BIGKEYS</code>命令会扫描整个数据库，这个命令本身会阻塞Redis</strong>，找出所有的大键，并将其以一个列表的形式返回给客户端。<br><code>redis-cli --bigkeys</code></p></li><li class="lvl-3"><p>Redis4.0之前，使用命令<code>debug object key</code>查看某个key的详细信息，包括该key的value大小等</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; DEBUG OBJECT key1</span><br><span class="line">Value at:0xb6838d20 refcount:1 encoding:raw serializedlength:9 lru:283790 lru_seconds_idle:150</span><br><span class="line"><span class="comment"># Value at:0xb6838d20：key 所在的内存地址。</span></span><br><span class="line"><span class="comment"># refcount:1：引用计数，表示该对象被引用的次数。</span></span><br><span class="line"><span class="comment"># encoding:raw：编码类型，这里是 raw ，表示这个字符串对象的编码类型。</span></span><br><span class="line"><span class="comment"># serializedlength:9：序列化后的长度。</span></span><br><span class="line"><span class="comment"># lru:283790：LRU （Least Recently Used）信息，即最近最少使用算法的相关信息，在内存淘汰策略中会用到。</span></span><br><span class="line"><span class="comment"># lru_seconds_idle:150：该 key 已空闲多久（单位为秒），也就是自从最后一次访问已经过去多少秒。</span></span><br></pre></td></tr></table></figure></li><li class="lvl-3"><p>4.0版本及以上，更推荐使用<code>memory usag</code>命令。memory usage命令采用抽样的方式，默认抽样5个元素，所以计算是近似值，我们也可以手动指定抽样的个数。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; memory usage k1</span><br><span class="line">(<span class="built_in">integer</span>) 57<span class="comment"># 这里k1 value占用57字节内存</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; MEMORY usage hkey SAMPLES  1000</span><br><span class="line">(<span class="built_in">integer</span>) 617977753<span class="comment"># 指定SAMPLES为1000，分析hkey键内存占用617977753字节</span></span><br></pre></td></tr></table></figure></li><li class="lvl-3"><p>通过工具 rdbtools 分析大key，可以分析静态rdb文件并生成csv格式的内存报告<br><code>rdb -c memory dump.rdb &gt; memory.csv</code></p></li></ol><p><strong>解决方法</strong></p><blockquote><ol><li class="lvl-3"><p>避免使用过大的value。如果需要存储大量的数据，可以将其拆分成多个小的value。</p></li><li class="lvl-3"><p>避免使用不必要的数据结构。例如，如果只需要存储一个字符串，就不要使用Hash或者List等数据结构。</p></li><li class="lvl-3"><p>定期清理过期的key。如果Redis中存在大量的过期key，就会导致Redis的性能下降。</p></li><li class="lvl-3"><p>对象压缩。</p></li></ol></blockquote><p>当发现存在Big Key问题时，我们需要及时采取措施来解决这个问题。下面列出几种可行的解决思路：</p><ul class="lvl-0"><li class="lvl-2"><p><strong>分割大key</strong><br>将Big Key拆分成多个小key。这个方法比较简单，但是需要修改应用程序的代码。就像是把一个大蛋糕切成小蛋糕一样。或者尝试将Big Key转换成Redis的其他数据结构。例如，将Big Key转换成Hash，List或者Set等数据结构。</p></li><li class="lvl-2"><p><strong>对象压缩</strong><br>如果大key的产生原因主要是由于对象序列化后的体积过大，可以考虑使用压缩算法来减小对象的大小。需要在客户端使用一些压缩算法对数据进行压缩和解压缩操作，例如LZF、Snappy等。</p></li><li class="lvl-2"><p><strong>直接删除</strong><br>Redis 4.0+的版本，直接使用 <code>unlink</code>命令异步删除大key。<br>4.0以下的版本 可以考虑使用 <code>scan</code>命令，分批次删除。</p></li></ul><h2 id="系统交互与架构层面">系统交互与架构层面</h2><h3 id="缓存穿透-缓存雪崩">缓存穿透 / 缓存雪崩</h3><ul class="lvl-0"><li class="lvl-2"><p>Redis 缓存穿透 → 大量请求打到 MySQL → MySQL 压力大 → 响应慢 → Java 线程阻塞 → CPU 飙升。</p></li><li class="lvl-2"><p>缓存雪崩 → 同时失效 → 所有请求查 DB → DB 崩 → 应用重试 → CPU 打满。</p></li></ul><blockquote><p>解决方式：布隆过滤器、空值缓存、随机过期时间。</p></blockquote><h3 id="服务雪崩-级联故障">服务雪崩 / 级联故障</h3><ul class="lvl-0"><li class="lvl-2"><p>ES 查询慢 → 接口超时 → 重试 → MySQL 被拖慢 → Redis 连接池耗尽 → 整个系统线程阻塞 → CPU 飙升。</p></li></ul><blockquote><p>解决方式：熔断（Hystrix/Sentinel）、降级、超时控制。</p></blockquote><h3 id="异步任务堆积">异步任务堆积</h3><ul class="lvl-0"><li class="lvl-2"><p>使用 <code>@Async</code> 或线程池处理异步任务（如写 ES、发消息），若任务执行慢 → 任务堆积 → 线程持续运行 → CPU 飙升。</p></li></ul><blockquote><p>排查方式：监控线程池队列大小、活跃线程数。</p></blockquote><h2 id="诊断工具链">诊断工具链</h2><table><thead><tr><th>场景</th><th>工具</th></tr></thead><tbody><tr><td>Java 线程分析</td><td><code>jstack</code>、Arthas<code>thread</code>、`jstack</td></tr><tr><td>GC 分析</td><td><code>jstat -gcutil</code>、GC 日志 + GCeasy 分析</td></tr><tr><td>方法耗时</td><td>Arthas<code>trace</code>、<code>monitor</code>、<code>watch</code></td></tr><tr><td>Redis 诊断</td><td><code>redis-cli --bigkeys</code>、<code>SLOWLOG</code>、<code>INFO</code>、RedisInsight</td></tr><tr><td>MySQL 诊断</td><td><code>slow_query_log</code>、<code>SHOW PROCESSLIST</code>、<code>EXPLAIN</code>、Arthas 拦截 SQL</td></tr><tr><td>ES 诊断</td><td>Kibana Monitoring、慢日志、<code>_nodes/hot_threads</code></td></tr><tr><td>系统级</td><td><code>top -H</code>、<code>pidstat -t -p &lt;java_pid&gt;</code>、<code>perf record</code>、<code>vmstat 1</code></td></tr></tbody></table><h2 id="典型排查流程（实战步骤）">典型排查流程（实战步骤）</h2><ol><li class="lvl-3"><p><code>top</code> → 找到 Java 进程 PID，确认 CPU 高的是 Java 进程。</p></li><li class="lvl-4"><p><code>top -H -p &lt;pid&gt;</code> → 找到最耗 CPU 的线程 TID。</p></li><li class="lvl-4"><p><code>printf &quot;%x\n&quot; &lt;tid&gt;</code> → 转为 16 进制。</p></li><li class="lvl-3"><p>查看线程堆栈：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstack &lt;pid&gt; | grep &lt;hex_tid&gt; -A 30</span><br></pre></td></tr></table></figure><blockquote><ul class="lvl-3"><li class="lvl-2"><p>如果是 <code>GC task thread</code> → 查 GC。</p></li><li class="lvl-2"><p>如果是业务线程 → 看是否在循环、等锁、处理大对象。</p></li></ul></blockquote></li><li class="lvl-4"><p>检查 GC：<code>jstat -gcutil &lt;pid&gt; 1000</code> → 看 YGC/FGC 频率。</p></li><li class="lvl-4"><p>检查外部调用：</p></li></ol><ul class="lvl-0"><li class="lvl-5"><p>Arthas <code>trace com.xxx.service.* *</code> → 看哪个方法耗时高。</p></li><li class="lvl-5"><p>检查 Redis/MySQL/ES 慢日志。</p></li></ul><ol start="7"><li class="lvl-4"><p>检查连接池、线程池监控指标（如 Druid 监控页、HikariCP JMX）。</p></li><li class="lvl-4"><p>检查系统日志、业务日志是否有异常堆栈或超时记录。</p></li></ol><h2 id="优化与预防建议">优化与预防建议</h2><ul class="lvl-0"><li class="lvl-3"><p><strong>代码层</strong>：避免大循环、大对象、深递归；合理分页；异步化耗时操作。</p></li><li class="lvl-3"><p><strong>缓存层</strong>：避免大 Key；设置过期时间；使用本地缓存（Caffeine）减轻 Redis 压力。</p></li><li class="lvl-3"><p><strong>数据库层</strong>：SQL 优化 + 索引；避免 SELECT *，避免深度分页；使用连接池监控。</p></li><li class="lvl-2"><p><strong>架构层</strong>：</p><ul class="lvl-2"><li class="lvl-4">加入熔断降级（Sentinel）。</li><li class="lvl-4">设置合理的超时（Feign、RestTemplate、Redis、DB）。</li><li class="lvl-4">异步化 + 削峰填谷（MQ）。</li></ul></li><li class="lvl-2"><p><strong>监控层</strong>：</p><ul class="lvl-2"><li class="lvl-4">接入 Prometheus + Grafana + AlertManager。</li><li class="lvl-4">APM（SkyWalking/Pinpoint）监控全链路性能。</li><li class="lvl-4">日志中心（ELK）分析异常模式。</li></ul></li></ul>]]></content>
    
    
    <summary type="html">CPU 飙高通常是多因素导致，通常需要从“代码 → 线程 → 进程 → 系统 → 网络/外部”逐层排查。</summary>
    
    
    
    <category term="Java" scheme="https://pengline.github.io/categories/Java/"/>
    
    <category term="性能" scheme="https://pengline.github.io/categories/Java/%E6%80%A7%E8%83%BD/"/>
    
    
    <category term="锁竞争" scheme="https://pengline.github.io/tags/%E9%94%81%E7%AB%9E%E4%BA%89/"/>
    
    <category term="CPU飙高" scheme="https://pengline.github.io/tags/CPU%E9%A3%99%E9%AB%98/"/>
    
    <category term="CPU密集型" scheme="https://pengline.github.io/tags/CPU%E5%AF%86%E9%9B%86%E5%9E%8B/"/>
    
    <category term="阻塞" scheme="https://pengline.github.io/tags/%E9%98%BB%E5%A1%9E/"/>
    
    <category term="长连接" scheme="https://pengline.github.io/tags/%E9%95%BF%E8%BF%9E%E6%8E%A5/"/>
    
    <category term="GC频繁" scheme="https://pengline.github.io/tags/GC%E9%A2%91%E7%B9%81/"/>
    
  </entry>
  
  <entry>
    <title>缓存淘汰之 LRU 算法的几种实现方案</title>
    <link href="https://pengline.github.io/2025/09/08/0ef61c38eadc4998bd8330a817b4f01d/"/>
    <id>https://pengline.github.io/2025/09/08/0ef61c38eadc4998bd8330a817b4f01d/</id>
    <published>2025-09-08T03:47:25.473Z</published>
    <updated>2025-09-09T08:52:28.711Z</updated>
    
    <content type="html"><![CDATA[<p>LRU，全称 <strong>Least Recently Used</strong>，即<strong>最近最少使用</strong>。它是一种常用的缓存淘汰算法，也常用于虚拟内存管理。</p><p><strong>核心思想</strong>：LRU 认为“<strong>最近被使用过的数据，在将来被再次访问的概率更高；而很久没被访问的数据，将来被访问的概率也更低</strong>”。因此，当缓存空间已满，需要淘汰旧数据来存入新数据时，它会优先淘汰那个“最近最少使用”的数据。</p><h2 id="算法原理与数据结构">算法原理与数据结构</h2><p>为了实现 LRU，我们需要高效地完成两件事：</p><ol><li class="lvl-3"><p><strong>快速查找</strong>：判断一个数据是否在缓存中。</p></li><li class="lvl-3"><p><strong>快速排序</strong>：能清晰地记录数据的访问顺序（最近使用的和很久未使用的），并在需要时快速淘汰最久未使用的数据。</p></li></ol><p>单纯使用数组或链表都无法同时满足这两点。因此，LRU 通常由 <strong>哈希表（Hash Table）</strong> 和 <strong>双向链表（Doubly Linked List）</strong> 两种数据结构结合实现。</p><blockquote><ul class="lvl-1"><li class="lvl-2"><p><strong>双向链表（用于排序）</strong>：</p><ul class="lvl-3"><li class="lvl-4"><strong>作用</strong>：模拟访问顺序。链表头部是 <strong>最近使用的（Most Recently Used, MRU）</strong>，尾部是 <strong>最久未使用的（LRU）</strong>。</li><li class="lvl-4"><strong>操作</strong>：<ul class="lvl-5"><li class="lvl-6">每当一个数据被访问（<code>get</code>）或添加（<code>put</code>），它就被移动到链表头部。</li><li class="lvl-6">当需要淘汰数据时，直接删除链表尾部的节点。</li></ul></li><li class="lvl-4"><strong>为什么是双向链表？</strong> 因为删除一个节点（尤其是中间节点）需要知道其前驱节点，单链表无法在 O(1) 时间内完成。</li></ul></li><li class="lvl-2"><p><strong>哈希表（用于快速查找）</strong>：</p><ul class="lvl-3"><li class="lvl-4"><strong>作用</strong>：提供 Key 到 <strong>链表节点</strong> 的快速映射。</li><li class="lvl-4"><strong>操作</strong>：通过 Key 可以立刻找到对应的链表节点，从而在 O(1) 时间内获取值或定位节点以便将其移动到头部。</li></ul></li></ul></blockquote><h2 id="三种实现方案">三种实现方案</h2><p>可以选择链表或者是数组来构建</p><blockquote><ol><li class="lvl-3"><p><strong>数组实现</strong>，构建数组，其中每一个数据项标记一个访问时间戳，每次插入新数据项的时候，先把数组中存在的数据项的时间戳自增，并将新数据项的时间戳置为0并插入到数组中。每次访问数组中的数据项的时候，将被访问的数据项的时间戳置为0。当数组空间已满时，将时间戳最大的数据项淘汰（<em>插入、删除，时间复杂度O(n)</em>）。</p></li><li class="lvl-3"><p><strong>链表实现</strong>，每次新插入数据的时候将新数据插到链表的头部；每次缓存命中（即数据被访问），则将数据移到链表头部；那么当链表满的时候，就将链表尾部的数据丢弃（<em>访问时间复杂度为O(n)</em>）。</p></li><li class="lvl-3"><p><strong>链表+hash</strong>。当需要插入新的数据项的时候，如果新数据项在链表中存在（一般称为命中），则把该节点移到链表头部，如果不存在，则新建一个节点，放到链表头部，若缓存满了，则把链表最后一个节点删除即可。在访问数据的时候，如果数据项在链表中存在，则把该节点移到链表头部，否则返回-1。这样一来在链表尾部的节点就是最近最久未访问的数据项。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过HashMap中`key`存储Node的`key`,`value`存储Node来建立Map对Node的映射关系</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>&lt;K,V&gt;&#123;</span><br><span class="line">    <span class="keyword">private</span> K key;</span><br><span class="line">    <span class="keyword">private</span> V value;</span><br><span class="line">    <span class="keyword">private</span> Node&lt;K,V&gt; prev;</span><br><span class="line">    <span class="keyword">private</span> Node&lt;K,V&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote><img src="/imgs/2054920-d65a5fd3c5d276fd.png" alt="img" style="zoom: 67%;" /><blockquote><p>1、新数据插入到链表头部；<br>2、每当缓存命中（即缓存数据被访问），则将数据移到链表头部；<br>3、当链表满的时候，将链表尾部的数据丢弃。</p></blockquote><h3 id="基于数组实现">基于数组实现</h3><p>利用数组 + 时间戳 实现。避免了数组下标值的移动，但是需要遍历所有值，并比较时间戳大小。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;b&gt;   基于数组实现lru   &lt;/b&gt;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; 用一个数组来存储数据，给每一个数据项标记一个访问时间戳，每次插入新数据项的时候，先把数组中存在的数据项的时间戳自增，</span></span><br><span class="line"><span class="comment"> * 并将新数据项的时间戳置为0并插入到数组中。每次访问数组中的数据项的时候，将被访问的数据项的时间戳置为0</span></span><br><span class="line"><span class="comment"> * 当数组空间已满时，将时间戳最大的数据项淘汰。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Haeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Email</span> haeng2030@gmail.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/7/12 16:03</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrLruDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ArrLru</span> <span class="variable">arrLru</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrLru</span>(<span class="number">3</span>);</span><br><span class="line">        arrLru.add(<span class="number">11</span>);</span><br><span class="line">        arrLru.add(<span class="number">22</span>);</span><br><span class="line">        arrLru.add(<span class="number">33</span>);</span><br><span class="line">        arrLru.add(<span class="number">33</span>);</span><br><span class="line"></span><br><span class="line">        arrLru.print();</span><br><span class="line">        System.out.println(<span class="string">&quot;---------------------&quot;</span>);</span><br><span class="line">        System.out.println(arrLru.get());</span><br><span class="line">        System.out.println(arrLru.get(<span class="number">22</span>));</span><br><span class="line"></span><br><span class="line">        arrLru.add(<span class="number">44</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;---------------------&quot;</span>);</span><br><span class="line">        arrLru.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ArrLru</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ArrLruNode[] datas;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> maxSize;    <span class="comment">// 数组最大大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;       <span class="comment">// 数组实际大小</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrLru</span><span class="params">(<span class="type">int</span> maxSize)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.maxSize = maxSize;</span><br><span class="line">        <span class="built_in">this</span>.datas = <span class="keyword">new</span> <span class="title class_">ArrLruNode</span>[maxSize];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(Arrays.toString(datas));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加数据</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> size;</span><br><span class="line">        <span class="keyword">if</span> (size == maxSize) &#123;  <span class="comment">// 满了</span></span><br><span class="line">            index = maxTS();  <span class="comment">// 替换最大遗漏的</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; datas.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (datas[i] == <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (datas[i].value == value) &#123;</span><br><span class="line">                datas[i].ts = <span class="number">0</span>;</span><br><span class="line">                index = -<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span></span><br><span class="line">                datas[i].ts++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            datas[index] = <span class="keyword">new</span> <span class="title class_">ArrLruNode</span>(value);</span><br><span class="line">            size++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得最新使用的数据</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; datas.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (datas[i] == <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (datas[i].ts == <span class="number">0</span>) &#123;</span><br><span class="line">                datas[i].ts = <span class="number">0</span>;</span><br><span class="line">                index = i;</span><br><span class="line">            &#125; <span class="keyword">else</span></span><br><span class="line">                datas[i].ts++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">idnex</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; datas.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (datas[i] == <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (datas[i].value == value) &#123;</span><br><span class="line">                idnex = i;</span><br><span class="line">                datas[i].ts = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span></span><br><span class="line">                datas[i].ts++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> idnex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得时间戳最大的（下标）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxTS</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">maxUserd</span> <span class="operator">=</span> datas[index].ts;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; datas.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (datas[i].ts &gt; maxUserd) &#123;</span><br><span class="line">                index = i;</span><br><span class="line">                maxUserd = datas[i].ts;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NoArgsConstructor</span></span><br><span class="line">    <span class="meta">@ToString</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ArrLruNode</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> value;       <span class="comment">// 储存数据</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">long</span> ts;      <span class="comment">// 使用时间戳</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">ArrLruNode</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="基于链表实现">基于链表实现</h3><p>利用链表快捷的删除和插入特性实现，不涉及数据的下标移动计算。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;b&gt;   基于链表实现lru   &lt;/b&gt;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; 每次新插入数据的时候将新数据插到链表的头部；每次缓存命中（即数据被访问），则将数据移到链表头部；那么当链表满的时候，就将链表尾部的数据丢弃。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Haeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Email</span> haeng2030@gmail.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/7/24 20:27</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListLru</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        LruNode&lt;String, Integer&gt; lru = <span class="keyword">new</span> <span class="title class_">LruNode</span>&lt;&gt;(<span class="number">8</span>);</span><br><span class="line">        lru.add(<span class="string">&quot;11&quot;</span>, <span class="number">11</span>);</span><br><span class="line">        lru.add(<span class="string">&quot;22&quot;</span>, <span class="number">22</span>);</span><br><span class="line">        lru.add(<span class="string">&quot;33&quot;</span>, <span class="number">33</span>);</span><br><span class="line">        lru.add(<span class="string">&quot;55&quot;</span>, <span class="number">55</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(lru.get(<span class="string">&quot;33&quot;</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;------------------&quot;</span>);</span><br><span class="line">        System.out.println(lru.getHead());</span><br><span class="line">        System.out.println(lru.getTail());</span><br><span class="line"></span><br><span class="line"><span class="comment">//        lru.print();</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LruNode</span>&lt;K, V&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> ListLruNode&lt;K, V&gt; head;</span><br><span class="line">    <span class="keyword">private</span> ListLruNode&lt;K, V&gt; tail;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> maxSize;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LruNode</span><span class="params">(<span class="type">int</span> maxSize)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.maxSize = maxSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ListLruNode&lt;K, V&gt; <span class="title function_">getHead</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ListLruNode&lt;K, V&gt; <span class="title function_">getTail</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> tail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加（当已存在key，当满了）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(K k, V v)</span> &#123;</span><br><span class="line">        ListLruNode&lt;K, V&gt; node = <span class="keyword">new</span> <span class="title class_">ListLruNode</span>&lt;&gt;(k, v);</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            head = node;</span><br><span class="line">            head.next = tail;</span><br><span class="line">            tail = node;</span><br><span class="line">            tail.pre = head;</span><br><span class="line">            size = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListLruNode&lt;K, V&gt; parent = head;</span><br><span class="line">        <span class="keyword">if</span> (parent.key.equals(k)) &#123;</span><br><span class="line">            parent.value = v;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (parent.remove(k)) <span class="comment">// 移除已经存在的（根据key）</span></span><br><span class="line">            size--;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (size == maxSize) &#123; <span class="comment">// 满了</span></span><br><span class="line">            parent.remove();</span><br><span class="line">            size--;</span><br><span class="line">        &#125;</span><br><span class="line">        tail = parent.getTail();</span><br><span class="line"></span><br><span class="line">        node.next = parent; <span class="comment">// 插入头部</span></span><br><span class="line">        node.next.pre = node;</span><br><span class="line">        head = node;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据k获取</span></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(K k)</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        ListLruNode&lt;K, V&gt; parent = head;</span><br><span class="line">        <span class="keyword">if</span> (parent == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        ListLruNode&lt;K, V&gt; node = parent.get(k);</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (node.key.equals(head.key))</span><br><span class="line">            <span class="keyword">return</span> node.value;</span><br><span class="line"></span><br><span class="line">        tail = parent.getTail();</span><br><span class="line"></span><br><span class="line">        node.next = head; <span class="comment">// 替换头节点</span></span><br><span class="line">        head.pre = node;</span><br><span class="line">        head = node;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> node.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        ListLruNode&lt;K, V&gt; parent = head;</span><br><span class="line">        <span class="keyword">if</span> (parent == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (parent != <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(parent);</span><br><span class="line"></span><br><span class="line">            parent = parent.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链表节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ListLruNode</span>&lt;K, V&gt; <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> K key;</span><br><span class="line">    <span class="keyword">public</span> V value;</span><br><span class="line">    <span class="keyword">public</span> ListLruNode&lt;K, V&gt; pre;</span><br><span class="line">    <span class="keyword">public</span> ListLruNode&lt;K, V&gt; next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ListLruNode</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ListLruNode</span><span class="params">(ListLruNode&lt;K, V&gt; node)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.key = node.key;</span><br><span class="line">        <span class="built_in">this</span>.value = node.value;</span><br><span class="line">        <span class="built_in">this</span>.next = node.next;</span><br><span class="line">        <span class="built_in">this</span>.pre = node.pre;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;ListLruNode&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;key=&quot;</span> + key +</span><br><span class="line">                <span class="string">&quot;, value=&quot;</span> + value +</span><br><span class="line"><span class="comment">//                &quot;, pre=&quot; + pre +</span></span><br><span class="line">                <span class="string">&quot;, next=&quot;</span> + next +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> ListLruNode&lt;K, V&gt; <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line"><span class="comment">//        ListLruNode&lt;K, V&gt; node = new ListLruNode&lt;&gt;(this);</span></span><br><span class="line">        ListLruNode&lt;K, V&gt; node = (ListLruNode&lt;K, V&gt;) <span class="built_in">super</span>.clone(); <span class="comment">// 浅拷贝</span></span><br><span class="line">        node.key = <span class="built_in">this</span>.key;</span><br><span class="line">        node.value = <span class="built_in">this</span>.value;</span><br><span class="line"><span class="comment">// 深拷贝</span></span><br><span class="line">        node.pre = <span class="built_in">this</span>.pre;</span><br><span class="line">        node.next = <span class="built_in">this</span>.next;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代获取</span></span><br><span class="line">    <span class="keyword">public</span> ListLruNode&lt;K, V&gt; <span class="title function_">get</span><span class="params">(K k)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.key.equals(k)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.pre != <span class="literal">null</span>)</span><br><span class="line">                <span class="built_in">this</span>.pre.next = <span class="built_in">this</span>.next; <span class="comment">// 移除该节点</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.next == <span class="literal">null</span> ? <span class="literal">null</span> : <span class="built_in">this</span>.next.get(k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得最后一个节点</span></span><br><span class="line">    <span class="keyword">public</span> ListLruNode&lt;K, V&gt; <span class="title function_">getTail</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.next != <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.next.getTail();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除最后一个节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.next.remove();</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">this</span>.pre.next = <span class="literal">null</span>; <span class="comment">// 移除最后一个</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除已存在的key节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(K k)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.key.equals(k)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.pre != <span class="literal">null</span>) &#123; <span class="comment">// 非头部</span></span><br><span class="line">                <span class="built_in">this</span>.pre.next = <span class="built_in">this</span>.next; <span class="comment">// 移除该节点</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.next != <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.next.remove(k);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="基于链表-Hash实现">基于链表+Hash实现</h3><p>基于双链表和hash数组实现</p><p>其核心实现结合了<strong>哈希表（快速查找）<strong>和</strong>双向链表（维护访问顺序）</strong> 两种数据结构，使得所有操作都能在常数时间内完成。</p><blockquote><ul class="lvl-1"><li class="lvl-2"><p><strong>HashMap</strong>：存储 key → Node，实现 O(1) 查找。</p></li><li class="lvl-2"><p><strong>双向链表</strong>：维护访问顺序，头节点为最新访问，尾节点为最久未访问。</p></li><li class="lvl-2"><p>每次访问或插入，将节点移到头部；容量超限时，删除尾部节点。</p></li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;b&gt;   基于数组、链表和hash实现lru   &lt;/b&gt;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; 用一个数组来存储链表节点数据，每次hash直接定位到该链表。hash冲突用双向链表。</span></span><br><span class="line"><span class="comment"> * 每次将插入、最新查找的节点添加至链表头部</span></span><br><span class="line"><span class="comment"> * 当链表数量达到最大值时，将末尾链表节点移除。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Haeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Email</span> haeng2030@gmail.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/7/12 16:03</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrLruMapDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 输出结果： 1，2，null，3，4</span></span><br><span class="line">        ArrLruMap&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">ArrLruMap</span>&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">        map.add(<span class="string">&quot;1&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        map.add(<span class="string">&quot;2&quot;</span>, <span class="number">2</span>);</span><br><span class="line">        System.out.println(map.get(<span class="string">&quot;1&quot;</span>));</span><br><span class="line">        map.add(<span class="string">&quot;3&quot;</span>, <span class="number">3</span>);</span><br><span class="line">        System.out.println(map.get(<span class="string">&quot;2&quot;</span>));</span><br><span class="line">        map.add(<span class="string">&quot;4&quot;</span>, <span class="number">4</span>);</span><br><span class="line">        System.out.println(map.get(<span class="string">&quot;1&quot;</span>));</span><br><span class="line">        System.out.println(map.get(<span class="string">&quot;3&quot;</span>));</span><br><span class="line">        System.out.println(map.get(<span class="string">&quot;4&quot;</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;---------------------&quot;</span>);</span><br><span class="line">        map.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ArrLruMap</span>&lt;K, V&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ArrLruMapNode&lt;K, V&gt;[] datas;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> maxSize;    <span class="comment">// 数组最大大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> size;       <span class="comment">// 数组实际大小</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrLruMap</span><span class="params">(<span class="type">int</span> maxSize)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.maxSize = maxSize;</span><br><span class="line">        <span class="built_in">this</span>.datas = <span class="keyword">new</span> <span class="title class_">ArrLruMapNode</span>[maxSize];</span><br><span class="line">        head = <span class="keyword">new</span> <span class="title class_">ArrLruMapNode</span>&lt;&gt;();</span><br><span class="line">        tail = <span class="keyword">new</span> <span class="title class_">ArrLruMapNode</span>&lt;&gt;();</span><br><span class="line">        head.after = tail;</span><br><span class="line">        tail.before = head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ArrLruMapNode&lt;K, V&gt; head;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ArrLruMapNode&lt;K, V&gt; tail;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getIndex</span><span class="params">(K key)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> (h = (key.hashCode() ^ <span class="number">32</span>) % maxSize) &lt; <span class="number">0</span> ? (h * -<span class="number">1</span>) : h;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(Arrays.toString(datas));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加数据</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;key must not null&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> getIndex(key);</span><br><span class="line">        ArrLruMapNode&lt;K, V&gt; data = datas[index];</span><br><span class="line">        ArrLruMapNode&lt;K, V&gt; node = <span class="keyword">new</span> <span class="title class_">ArrLruMapNode</span>&lt;&gt;(key, value);</span><br><span class="line">        ArrLruMapNode&lt;K, V&gt; temp = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (data == <span class="literal">null</span>) &#123; <span class="comment">// 新添加</span></span><br><span class="line">            datas[index] = node;</span><br><span class="line">            addToHead(node);</span><br><span class="line">            temp = node;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 更新存在的</span></span><br><span class="line">            <span class="comment">// 查找是否存在，如果不存在直接加入，否则就移除并加至头部</span></span><br><span class="line">            temp = replaceAndGet(data, key, value);</span><br><span class="line">            <span class="keyword">if</span> (temp != <span class="literal">null</span>) &#123;</span><br><span class="line">                temp.next = node;</span><br><span class="line">                node.pre = temp;</span><br><span class="line"></span><br><span class="line">                addToHead(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (temp != <span class="literal">null</span>)</span><br><span class="line">            size++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (size &gt; maxSize) &#123;  <span class="comment">// 满了</span></span><br><span class="line">            removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将节点插入到头部</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addToHead</span><span class="params">(ArrLruMapNode&lt;K, V&gt; node)</span> &#123;</span><br><span class="line">        head.after.before = node;</span><br><span class="line">        node.after = head.after;</span><br><span class="line"></span><br><span class="line">        head.after = node;</span><br><span class="line">        node.before = head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除以前的，并加至头部</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">moveToHead</span><span class="params">(ArrLruMapNode&lt;K, V&gt; node, <span class="type">boolean</span> toHead)</span> &#123;</span><br><span class="line">        node.after.before = node.before;</span><br><span class="line">        node.before.after = node.after;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (toHead)</span><br><span class="line">            addToHead(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果存在，将已存在节点的值替换并移到头部。</span></span><br><span class="line">    <span class="comment">// 如贵不存在，返回拉链表的最后一个节点</span></span><br><span class="line">    <span class="keyword">private</span> ArrLruMapNode&lt;K, V&gt; <span class="title function_">replaceAndGet</span><span class="params">(ArrLruMapNode&lt;K, V&gt; root, K key, V value)</span> &#123;</span><br><span class="line">        ArrLruMapNode&lt;K, V&gt; node = root;</span><br><span class="line">        ArrLruMapNode&lt;K, V&gt; next = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node.key.equals(key)) &#123;</span><br><span class="line"></span><br><span class="line">                node.value = value;</span><br><span class="line">                moveToHead(node, <span class="literal">true</span>);</span><br><span class="line">                next = <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            next = node;</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果存在，将指定的节点移至头部并返回</span></span><br><span class="line">    <span class="keyword">private</span> ArrLruMapNode&lt;K, V&gt; <span class="title function_">moveAndGet</span><span class="params">(ArrLruMapNode&lt;K, V&gt; root, K key)</span> &#123;</span><br><span class="line">        ArrLruMapNode&lt;K, V&gt; node = root;</span><br><span class="line">        ArrLruMapNode&lt;K, V&gt; temp = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node.key.equals(key)) &#123;</span><br><span class="line"></span><br><span class="line">                moveToHead(node, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">                temp = node;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除最后一个</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">removeLast</span><span class="params">()</span> &#123;</span><br><span class="line">        remove(tail.before);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除指定节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(ArrLruMapNode&lt;K, V&gt; node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> getIndex(node.key);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (node.next == <span class="literal">null</span> &amp;&amp; node.pre == <span class="literal">null</span>) &#123;</span><br><span class="line">            datas[index] = <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (node.next != <span class="literal">null</span>)</span><br><span class="line">                node.next.pre = node.pre;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (node.pre != <span class="literal">null</span>)</span><br><span class="line">                node.pre.next = node.next;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (node.pre == <span class="literal">null</span>)</span><br><span class="line">                datas[index] = node.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 移除链表中已存在的</span></span><br><span class="line">        moveToHead(node, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        size--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得指定数据</span></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(K key)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;key must not null&quot;</span>);</span><br><span class="line"></span><br><span class="line">        ArrLruMapNode&lt;K, V&gt; node = head.after;</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">null</span> &amp;&amp; key.equals(node.key))</span><br><span class="line">            <span class="keyword">return</span> node.value;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> getIndex(key);</span><br><span class="line">        node = datas[index];</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        node = moveAndGet(node, key);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> node == <span class="literal">null</span> ? <span class="literal">null</span> : node.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ArrLruMapNode</span>&lt;K, V&gt; &#123;</span><br><span class="line">        K key;</span><br><span class="line">        <span class="type">int</span> hash;</span><br><span class="line">        <span class="keyword">volatile</span> V value;       <span class="comment">// 储存数据</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 双链表</span></span><br><span class="line">        <span class="keyword">volatile</span> ArrLruMapNode&lt;K, V&gt; before;</span><br><span class="line">        <span class="keyword">volatile</span> ArrLruMapNode&lt;K, V&gt; after;</span><br><span class="line">        <span class="comment">// hash冲突拉链链表</span></span><br><span class="line">        <span class="keyword">volatile</span> ArrLruMapNode&lt;K, V&gt; next;</span><br><span class="line">        <span class="keyword">volatile</span> ArrLruMapNode&lt;K, V&gt; pre;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">ArrLruMapNode</span><span class="params">()</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">ArrLruMapNode</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Java-中如何应用">Java 中如何应用</h2><table><thead><tr><th>方式</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td>LinkedHashMap</td><td>简单、内置、代码少</td><td>非线程安全</td><td>简单单线程场景</td></tr><tr><td>手动双向链表</td><td>可控性强，适合面试</td><td>代码复杂，易出错</td><td>学习/面试/定制需求</td></tr><tr><td>Guava Cache</td><td>功能丰富，成熟稳定</td><td>性能略逊于 Caffeine</td><td>一般项目</td></tr><tr><td>Caffeine</td><td>高性能，功能强，推荐生产使用</td><td>需要引入第三方依赖</td><td>生产环境高性能缓存</td></tr></tbody></table><h3 id="使用内置类：LinkedHashMap">使用内置类：<code>LinkedHashMap</code></h3><p>最简单、最常用的方式。<code>LinkedHashMap</code> 内部维护了插入或访问顺序，通过重写 <code>removeEldestEntry()</code> 方法可以实现自动淘汰最久未使用的元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedHashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LRUCache</span>&lt;K, V&gt; <span class="keyword">extends</span> <span class="title class_">LinkedHashMap</span>&lt;K, V&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LRUCache</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="comment">// accessOrder = true 表示按访问顺序排序（LRU核心）</span></span><br><span class="line">        <span class="built_in">super</span>(capacity, <span class="number">0.75f</span>, <span class="literal">true</span>);</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">removeEldestEntry</span><span class="params">(Map.Entry&lt;K, V&gt; eldest)</span> &#123;</span><br><span class="line">        <span class="comment">// 当 size &gt; capacity 时，移除最老的元素</span></span><br><span class="line">        <span class="keyword">return</span> size() &gt; capacity;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用第三方库">使用第三方库</h3><ul class="lvl-0"><li class="lvl-2"><p><strong>Guava</strong></p><p>Guava 的 <code>Cache</code> 支持多种淘汰策略（包括 LRU），还支持过期时间、加载函数等高级功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.common.cache.Cache;</span><br><span class="line"><span class="keyword">import</span> com.google.common.cache.CacheBuilder;</span><br><span class="line"></span><br><span class="line">Cache&lt;Integer, String&gt; cache = CacheBuilder.newBuilder()</span><br><span class="line">    .maximumSize(<span class="number">100</span>)</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line">cache.put(<span class="number">1</span>, <span class="string">&quot;A&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> cache.getIfPresent(<span class="number">1</span>);</span><br></pre></td></tr></table></figure></li><li class="lvl-2"><p><strong>Caffeine</strong></p><p>Caffeine 是目前 Java 生态中性能最好的本地缓存库，基于 Guava 改进，支持 Window TinyLFU 等更优算法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.github.benmanes.caffeine.cache.Cache;</span><br><span class="line"><span class="keyword">import</span> com.github.benmanes.caffeine.cache.Caffeine;</span><br><span class="line"></span><br><span class="line">Cache&lt;Integer, String&gt; cache = Caffeine.newBuilder()</span><br><span class="line">    .maximumSize(<span class="number">100</span>)</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line">cache.put(<span class="number">1</span>, <span class="string">&quot;A&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> cache.getIfPresent(<span class="number">1</span>);</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <summary type="html">LRU 是一种高效且实用的缓存淘汰策略，它通过“最近最少使用”的原则来最大化缓存的命中率。</summary>
    
    
    
    <category term="算法" scheme="https://pengline.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="缓存淘汰" scheme="https://pengline.github.io/categories/%E7%AE%97%E6%B3%95/%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0/"/>
    
    
    <category term="算法" scheme="https://pengline.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="LRU" scheme="https://pengline.github.io/tags/LRU/"/>
    
    <category term="缓存淘汰" scheme="https://pengline.github.io/tags/%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 数据库性能全面优化方案</title>
    <link href="https://pengline.github.io/2025/09/06/a3d9c654efa843ed8446359ed76b5d81/"/>
    <id>https://pengline.github.io/2025/09/06/a3d9c654efa843ed8446359ed76b5d81/</id>
    <published>2025-09-06T08:31:36.365Z</published>
    <updated>2025-09-06T14:06:32.392Z</updated>
    
    <content type="html"><![CDATA[<p>以下是全面、实用、分层次的 MySQL 性能优化解决方案，以及相关原理。</p><p>以 MySQL 5.7 为例说明。</p><h2 id="常用的优化方案">常用的优化方案</h2><h3 id="SQL-语句优化（最直接有效）">SQL 语句优化（最直接有效）</h3><ol><li class="lvl-3"><p><strong>避免全量查询</strong></p><p>避免查询多余的数据，尤其是敏感和 text 类型数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 不推荐</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 推荐：只查询需要的字段</span></span><br><span class="line"><span class="keyword">SELECT</span> id, name, email <span class="keyword">FROM</span> users;</span><br></pre></td></tr></table></figure></li><li class="lvl-3"><p><strong>使用 EXPLAIN 分析执行计划</strong></p><p>分析 SQL 执行情况，以及索引利用率和连表查询性能等。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 关注：`type`（是否全表扫描）、`key`（是否用索引）、`rows`（扫描行数）、`Extra`（是否用临时表/文件排序）</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> orders <span class="keyword">WHERE</span> user_id <span class="operator">=</span> <span class="number">100</span>;</span><br></pre></td></tr></table></figure></li><li class="lvl-3"><p><strong>避免在 WHERE 中对字段进行函数操作或计算</strong></p><p>低版本 MySQL 不支持函数索引，会导致索引失效。MySQL8 有所改善。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 索引失效</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> <span class="keyword">YEAR</span>(created_at) <span class="operator">=</span> <span class="number">2024</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 改写为范围查询</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> created_at <span class="operator">&gt;=</span> <span class="string">&#x27;2024-01-01&#x27;</span> <span class="keyword">AND</span> created_at <span class="operator">&lt;</span> <span class="string">&#x27;2025-01-01&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li class="lvl-3"><p><strong>避免使用 OR</strong></p><p>会导致索引失效，MySQL8 有所改善。可改写为 UNION 或 IN，或其他字段添加索引。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 可能导致索引失效</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;Alice&#x27;</span> <span class="keyword">OR</span> age <span class="operator">=</span> <span class="number">25</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 改用 UNION（如果字段都有索引）</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;Alice&#x27;</span></span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> age <span class="operator">=</span> <span class="number">25</span>;</span><br></pre></td></tr></table></figure></li><li class="lvl-3"><p><strong>使用 LIMIT 分页优化</strong>（避免 OFFSET 大偏移）</p><p>涉及&quot;深度分页&quot;问题，可参照  <a href="https://hangline.github.io/2025/09/05/b35492bf2a96482e86fe1e77b2bc7812/">海量数据的深度分页查询解决方案</a></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 慢（深度分页）：OFFSET 100000</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> orders <span class="keyword">ORDER</span> <span class="keyword">BY</span> id LIMIT <span class="number">100000</span>, <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 优化：记住上一页最大ID</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> orders <span class="keyword">WHERE</span> id <span class="operator">&gt;</span> <span class="number">100000</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> id LIMIT <span class="number">20</span>;</span><br></pre></td></tr></table></figure></li><li class="lvl-3"><p><strong>避免复杂 CASE WHEN / IF 判断</strong>（尤其在 WHERE 或 JOIN 中）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 性能差：</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> orders</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">CASE</span> </span><br><span class="line">        <span class="keyword">WHEN</span> status <span class="operator">=</span> <span class="string">&#x27;paid&#x27;</span> <span class="keyword">AND</span> amount <span class="operator">&gt;</span> <span class="number">100</span> <span class="keyword">THEN</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">WHEN</span> status <span class="operator">=</span> <span class="string">&#x27;pending&#x27;</span> <span class="keyword">AND</span> created_at <span class="operator">&gt;</span> NOW() <span class="operator">-</span> <span class="type">INTERVAL</span> <span class="number">1</span> <span class="keyword">DAY</span> <span class="keyword">THEN</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">ELSE</span> <span class="number">0</span> </span><br><span class="line">      <span class="keyword">END</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-------------------------------------------------------</span></span><br><span class="line"><span class="comment">-- 改写为逻辑表达式：</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> orders</span><br><span class="line"><span class="keyword">WHERE</span> (status <span class="operator">=</span> <span class="string">&#x27;paid&#x27;</span> <span class="keyword">AND</span> amount <span class="operator">&gt;</span> <span class="number">100</span>)</span><br><span class="line">   <span class="keyword">OR</span> (status <span class="operator">=</span> <span class="string">&#x27;pending&#x27;</span> <span class="keyword">AND</span> created_at <span class="operator">&gt;</span> NOW() <span class="operator">-</span> <span class="type">INTERVAL</span> <span class="number">1</span> <span class="keyword">DAY</span>);</span><br></pre></td></tr></table></figure></li><li class="lvl-3"><p><strong>避免高频的统计计算和字符截取</strong></p><p>如果某些计算是高频使用的，可以<strong>在写入时计算好并存储</strong>。或者定时或实时建立统计表（按天、按月）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 每次查询都计算：</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">YEAR</span>(create_time), <span class="keyword">MONTH</span>(create_time), <span class="built_in">COUNT</span>(<span class="operator">*</span>)</span><br><span class="line"><span class="keyword">FROM</span> orders</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">YEAR</span>(create_time), <span class="keyword">MONTH</span>(create_time);</span><br><span class="line"></span><br><span class="line"><span class="comment">---------------------------预计算 + 冗余字段（空间换时间）-------------------------------------</span></span><br><span class="line"><span class="comment">-- 建表时或通过触发器/应用层写入</span></span><br><span class="line"><span class="keyword">ALTER TABLE</span> orders <span class="keyword">ADD</span> <span class="keyword">COLUMN</span> order_year_month <span class="type">INT</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询时直接使用</span></span><br><span class="line"><span class="keyword">SELECT</span> order_year_month, <span class="built_in">COUNT</span>(<span class="operator">*</span>)</span><br><span class="line"><span class="keyword">FROM</span> orders</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> order_year_month;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 对该字段加索引</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_order_ym <span class="keyword">ON</span> orders(order_year_month);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 使用生成列：MySQL 支持虚拟列或存储列，自动计算并可加索引</span></span><br><span class="line"><span class="keyword">ALTER TABLE</span> orders </span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">COLUMN</span> order_year_month <span class="type">INT</span> </span><br><span class="line">GENERATED ALWAYS <span class="keyword">AS</span> (<span class="keyword">YEAR</span>(create_time) <span class="operator">*</span> <span class="number">100</span> <span class="operator">+</span> <span class="keyword">MONTH</span>(create_time)) STORED;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_order_ym <span class="keyword">ON</span> orders(order_year_month);</span><br></pre></td></tr></table></figure></li><li class="lvl-3"><p><strong>使用临时表 / 中间表预处理复杂逻辑</strong></p><p>可分步优化、避免单条 SQL 过于复杂。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Step 1: 预处理中间结果到临时表</span></span><br><span class="line"><span class="keyword">CREATE</span> TEMPORARY <span class="keyword">TABLE</span> temp_filtered_orders <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> id, user_id, amount, </span><br><span class="line">       <span class="keyword">CASE</span> <span class="keyword">WHEN</span> amount <span class="operator">&gt;</span> <span class="number">100</span> <span class="keyword">THEN</span> <span class="string">&#x27;high&#x27;</span> <span class="keyword">ELSE</span> <span class="string">&#x27;low&#x27;</span> <span class="keyword">END</span> <span class="keyword">AS</span> level</span><br><span class="line"><span class="keyword">FROM</span> orders </span><br><span class="line"><span class="keyword">WHERE</span> create_time <span class="operator">&gt;=</span> <span class="string">&#x27;2024-01-01&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Step 2: 对临时表加索引（可选）</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_temp_user <span class="keyword">ON</span> temp_filtered_orders(user_id);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Step 3: 基于临时表做后续 JOIN / GROUP / 统计</span></span><br><span class="line"><span class="keyword">SELECT</span> u.name, t.level, <span class="built_in">COUNT</span>(<span class="operator">*</span>)</span><br><span class="line"><span class="keyword">FROM</span> temp_filtered_orders t</span><br><span class="line"><span class="keyword">JOIN</span> users u <span class="keyword">ON</span> t.user_id <span class="operator">=</span> u.id</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> u.name, t.level;</span><br></pre></td></tr></table></figure></li></ol><h3 id="索引优化（性能提升关键）">索引优化（性能提升关键）</h3><p><strong>不适合建立索引的列</strong></p><blockquote><ul class="lvl-1"><li class="lvl-2"><p>tinyint 或 用以标致类型的int列。比如用以保存性别，选择性过大，最小都是超过25%了，因此没有设置索引的必要。</p></li><li class="lvl-2"><p>更新频繁的字段。</p></li><li class="lvl-2"><p>不会出现在where子句中的字段。</p></li><li class="lvl-2"><p>数据可能为null或空或0的字段</p></li><li class="lvl-2"><p>存储占用过大的，如：text，json</p></li></ul></blockquote><p><strong>适合建立索引的列</strong></p><blockquote><ul class="lvl-1"><li class="lvl-2"><p>字段离散度越高，越适合选作索引的关键字。如主键和唯一字段（主键索引自动创建）。</p></li><li class="lvl-2"><p>很少更新的字段（因为也会牵连更新索引）。</p></li><li class="lvl-2"><p>占用存储空间少的字段。</p></li><li class="lvl-2"><p>存储空间固定的字段。</p></li><li class="lvl-2"><p>Where子句中经常使用的字段，分组字段、排序字段和多表连接字段（外键索引自动创建）。</p></li><li class="lvl-2"><p>尽量使用联合索引（前缀）</p></li></ul></blockquote><ol><li class="lvl-3"><p><strong>为常用 WHERE、JOIN、ORDER BY 字段建索引</strong></p><p>索引建立的规则需要遵守以上，否则可能适得其反，会被优化器所优化。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx_user_email <span class="keyword">ON</span> users(email);</span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_order_user_status <span class="keyword">ON</span> orders(user_id, status);</span><br></pre></td></tr></table></figure></li><li class="lvl-3"><p><strong>使用复合索引</strong>（联合索引），注意最左前缀原则</p><p>优先考虑使用联合索引，尤其是有类型状态的字段。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询条件 WHERE a=? AND b=? → 建立 (a, b)</span></span><br><span class="line"><span class="comment">-- 查询条件 WHERE b=? AND a=? → 同样可用 (a, b)，MySQL 会自动优化顺序（优化器）</span></span><br><span class="line"><span class="comment">-- 查询条件 WHERE b=? → 无法使用 (a, b) 索引，MySQL8 中有所优化，可能会用到</span></span><br></pre></td></tr></table></figure></li><li class="lvl-3"><p><strong>避免过多索引</strong>（写操作变慢，空间占用大）</p><p>一般单表索引不超过 5 个，根据查询频率和区分度选择，优先使用联合索引</p></li><li class="lvl-3"><p><strong>使用覆盖索引</strong>（Covering Index）避免回表</p><p>尽量将查询字段都包含在索引中。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 如果索引包含 SELECT 所有字段，无需回表查主键</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_covering <span class="keyword">ON</span> orders(user_id, status, amount);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> user_id, status, amount <span class="keyword">FROM</span> orders <span class="keyword">WHERE</span> user_id <span class="operator">=</span> <span class="number">100</span>; <span class="comment">-- 走覆盖索引</span></span><br></pre></td></tr></table></figure></li><li class="lvl-3"><p><strong>定期分析和重建索引</strong>（碎片整理）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ANALYZE <span class="keyword">TABLE</span> orders;  <span class="comment">-- 更新统计信息</span></span><br><span class="line">OPTIMIZE <span class="keyword">TABLE</span> orders; <span class="comment">-- 重建表和索引（锁表，谨慎使用）</span></span><br><span class="line"><span class="comment">-- 或使用在线工具：pt-online-schema-change / gh-ost</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="表结构与设计优化（思想习惯）">表结构与设计优化（思想习惯）</h3><ol><li class="lvl-3"><p><strong>选择合适的数据类型</strong></p><blockquote><ul class="lvl-3"><li class="lvl-2">使用 <code>TINYINT</code> 代替 <code>INT</code> 存布尔值</li><li class="lvl-2">使用 <code>VARCHAR(N)</code> 而不是 <code>TEXT</code>（如果长度可控）</li><li class="lvl-2">使用 <code>DATETIME</code> 而不是字符串存时间</li><li class="lvl-2">使用 <code>UNSIGNED</code> 无符号整数扩大范围</li></ul></blockquote></li><li class="lvl-3"><p><strong>避免 NULL，设置默认值</strong></p><p>NULL 会增加判断复杂度，索引效率略低，且可能存在歧义性。</p></li><li class="lvl-3"><p><strong>拆分大字段或大表</strong>（垂直/水平分表）</p><p>对于半结构化 JSON 大数据，可以选择存储在非关系型数据库中。</p><blockquote><ul class="lvl-3"><li class="lvl-2"><p>TEXT/BLOB 字段可拆到扩展表</p></li><li class="lvl-2"><p>历史数据归档（如 orders → orders_2024, orders_2023）</p></li></ul></blockquote></li><li class="lvl-3"><p><strong>使用合适存储引擎</strong></p><p>只有插入和查询的 日志类数据，可以使用 MyISAM 引擎</p><blockquote><ul class="lvl-3"><li class="lvl-2"><p>一般用 <strong>InnoDB</strong>（支持事务、行锁、外键）</p></li><li class="lvl-2"><p>读多写少且无事务可用 MyISAM（已基本淘汰）</p></li></ul></blockquote></li></ol><h3 id="MySQL-配置参数优化（底层原理）">MySQL 配置参数优化（底层原理）</h3><p>MySQL的<code>innodb_flush_method</code>参数控制着innodb数据文件及redo log的打开、刷写模式</p><blockquote><ul class="lvl-1"><li class="lvl-2"><p><strong>redo log 物理日志</strong>（保证持久性），记录的是数据页的物理修改，而不是某一行或某几行修改，它用来恢复提交后的物理数据页(只能恢复到最后一次提交的位置)。</p></li><li class="lvl-2"><p><strong>undo 逻辑日志</strong> （保证原子性），用来回滚行记录到某个版本，根据每行记录进行记录。</p></li></ul></blockquote><h4 id="缓冲池（最重要）">缓冲池（最重要）</h4><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">innodb_buffer_pool_size</span> = <span class="number">70</span>%-<span class="number">80</span>% of total RAM （专用数据库服务器）</span><br></pre></td></tr></table></figure><p>Buffer Pool 大小，会影响缓存命中率</p><blockquote><ol><li class="lvl-3"><p>在事务执行过程中，所有对数据页的修改都会先生成 redo log 记录，并写入 log buffer；在事务提交时，根据配置决定是否将 log buffer 中的日志刷入磁盘上的 redo log 文件（ib_logfile）。</p></li><li class="lvl-3"><p>事务执行期间，数据页的修改是在 Buffer Pool 中的“脏页”上直接进行的；事务提交时，并不会立即将这些脏页写回磁盘，而是标记为“可刷盘”，由后台线程（如 checkpoint、LRU flusher）异步写入。</p></li></ol></blockquote><h4 id="日志与刷盘策略（平衡性能与安全）">日志与刷盘策略（平衡性能与安全）</h4><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安全（默认），设为2可提速（小概率丢数据）</span></span><br><span class="line"><span class="attr">innodb_flush_log_at_trx_commit</span> = <span class="number">1</span></span><br><span class="line"><span class="comment"># 安全，设为0或N可提速</span></span><br><span class="line"><span class="attr">sync_binlog</span> = <span class="number">1</span></span><br></pre></td></tr></table></figure><p>这两个参数是控制MySQL 磁盘写入策略以及数据安全性的关键参数：</p><blockquote><p>InnoDB默认开启内部的XA事务（基于redo log和undo log），采用日志先行的策略。</p><p>在未开启binlog的情况下，数据变更（增，删，改）会在内存中操作，并将事务顺序写入到redo log中，这时就会认为事务已经完成，响应事务提交成功。然后在以下参数设置条件下，才将内存中数据刷新合并到磁盘中。</p><p>在持久化到磁盘的过程中，如果服务器宕机等导致内存中数据丢失，该数据就会丢失。这种丢失是可以通过 recovery 重做日志，找回数据的。</p><p>缓存刷新的参数： <code>innodb_flush_log_at_trx_commit</code>（刷新方式）   <code>innodb_flush_log_at_timeout</code>（刷新频率）</p><ul class="lvl-1"><li class="lvl-2"><p><strong>innodb_flush_log_at_trx_commit=1</strong>（默认），每次事务提交，把log buffer刷到文件系统中去，并且调用文件系统的“flush”操作将缓存刷新到磁盘（如果底层硬件提供的IOPS比较差，MySQL并发会由于硬件IO而无法提升）。</p></li><li class="lvl-2"><p><strong>innodb_flush_log_at_trx_commit=0</strong>，每隔一秒，把log buffer刷到文件系统，并且调用文件系统的“flush”将缓存刷新到磁盘（可能丢失1秒的事务数据）。</p></li><li class="lvl-2"><p><strong>innodb_flush_log_at_trx_commit=2</strong>（推荐），每次事务提交，把log buffer刷到文件系统，但每隔一秒调用文件系统的“flush”将缓存刷新到磁盘（如果只是MySQL数据库挂掉了，由于文件系统没有问题，那么对应的事务数据并没有丢失。如果操作系统挂掉或重启，可能丢失1秒的事务数据）</p></li></ul></blockquote><p><strong>sync_binlog</strong></p><blockquote><p>sync_binlog 的默认值是0，像操作系统刷其他文件的机制一样，MySQL不会同步到磁盘中而是依赖操作系统来刷新binary log。</p><p>当sync_binlog =N (N&gt;0) ，MySQL 在每写 N次 二进制日志binary log时，会使用fdatasync()函数将它的写二进制日志binary log同步到磁盘中去。</p><p><mark>注:</mark>  如果启用了autocommit，那么每一个语句statement就会有一次写操作；否则每个事务对应一个写操作。</p></blockquote><h4 id="脏页控制（数据页）">脏页控制（数据页）</h4><p>把内存中被修改过，跟磁盘中的数据页不一致的数据页称为脏页</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 告知磁盘 I/O 能力：默认 200，SSD 建议 1000~5000</span></span><br><span class="line"><span class="attr">innodb_io_capacity</span>=<span class="number">2000</span></span><br><span class="line"><span class="comment"># 控制突发刷盘能力：默认 2000，可设为 io_capacity 的 2~5 倍</span></span><br><span class="line"><span class="attr">innodb_io_capacity_max</span>=<span class="number">3000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 脏页比例软上限：默认 75%（5.7）或 90%（8.0），建议 70~85%</span></span><br><span class="line"><span class="attr">innodb_max_dirty_pages_pct</span>=<span class="number">80</span></span><br><span class="line"><span class="comment"># 脏页刷盘起始水位：默认 0，建议设为 10~20，避免突增抖动</span></span><br><span class="line"><span class="attr">innodb_max_dirty_pages_pct_lwm</span>=<span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 自适应刷盘：默认 ON，推荐保持开启</span></span><br><span class="line"><span class="attr">innodb_adaptive_flushing</span>=<span class="literal">ON</span></span><br><span class="line"><span class="comment"># 监控刷盘延迟：越大表示刷盘越滞后，应 &lt; 70% of redo log size</span></span><br><span class="line">Innodb_checkpoint_age=</span><br></pre></td></tr></table></figure><blockquote><ul class="lvl-1"><li class="lvl-2"><p><code>innodb_io_capacity</code> 参数用于告诉 InnoDB 存储引擎底层磁盘设备的 I/O 能力（单位：IOPS），InnoDB 会据此控制后台线程（如 Page Cleaner）每秒刷脏页的数量，从而避免过度消耗 I/O 资源或刷盘不足。 该参数值设置过小，会导致 InnoDB 低估磁盘 I/O 能力，从而限制后台刷脏页的速度，使得脏页积累速度超过刷盘速度，最终引发 Redo Log 空间不足、Checkpoint 延迟、写入阻塞等问题。</p></li><li class="lvl-2"><p><code>innodb_max_dirty_pages_pct</code> 是 Buffer Pool 中脏页比例的“软上限”，默认值在 MySQL 5.6+ 是 75%，在 MySQL 8.0 中默认是 90%。当脏页比例达到或超过该值时，InnoDB 会主动加大刷盘力度，但不会完全禁止新脏页产生。</p></li><li class="lvl-2"><p>InnoDB 内部会根据当前脏页比例 M，结合 <code>innodb_max_dirty_pages_pct</code> 和 <code>innodb_max_dirty_pages_pct_lwm</code>（低水位线，默认 0），通过一个内部算法（非公开公式）计算出一个“刷盘压力因子”，用于动态调节 Page Cleaner 线程的刷盘速度。这个因子影响每秒刷多少页，但不是简单的 0~100 百分比映射。</p></li><li class="lvl-2"><p>页比例是监控指标，不是配置参数。通过查询 <code>Innodb_buffer_pool_pages_dirty / Innodb_buffer_pool_pages_total</code> 来监控当前脏页比例，但不能“通过它去设置”任何参数 —— 设置上限应使用 <code>innodb_max_dirty_pages_pct</code>。</p></li></ul></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 监控指标：</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">GLOBAL</span> STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;Innodb_buffer_pool_pages_dirty&#x27;</span>;</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">GLOBAL</span> STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;Innodb_checkpoint_age&#x27;</span>;</span><br><span class="line"><span class="comment">-- checkpoint_age 越大，说明刷盘越滞后</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看当前脏页比例</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    VARIABLE_VALUE <span class="keyword">AS</span> dirty_pages </span><br><span class="line"><span class="keyword">FROM</span> information_schema.GLOBAL_STATUS </span><br><span class="line"><span class="keyword">WHERE</span> VARIABLE_NAME <span class="operator">=</span> <span class="string">&#x27;Innodb_buffer_pool_pages_dirty&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    VARIABLE_VALUE <span class="keyword">AS</span> total_pages </span><br><span class="line"><span class="keyword">FROM</span> information_schema.GLOBAL_STATUS </span><br><span class="line"><span class="keyword">WHERE</span> VARIABLE_NAME <span class="operator">=</span> <span class="string">&#x27;Innodb_buffer_pool_pages_total&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 计算比例</span></span><br><span class="line"><span class="keyword">SELECT</span> ROUND(</span><br><span class="line">    (dirty_pages <span class="operator">/</span> total_pages) <span class="operator">*</span> <span class="number">100</span>, <span class="number">2</span></span><br><span class="line">) <span class="keyword">AS</span> dirty_pct</span><br><span class="line"><span class="keyword">FROM</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> </span><br><span class="line">        (<span class="keyword">SELECT</span> VARIABLE_VALUE <span class="keyword">FROM</span> information_schema.GLOBAL_STATUS <span class="keyword">WHERE</span> VARIABLE_NAME <span class="operator">=</span> <span class="string">&#x27;Innodb_buffer_pool_pages_dirty&#x27;</span>) <span class="keyword">AS</span> dirty_pages,</span><br><span class="line">        (<span class="keyword">SELECT</span> VARIABLE_VALUE <span class="keyword">FROM</span> information_schema.GLOBAL_STATUS <span class="keyword">WHERE</span> VARIABLE_NAME <span class="operator">=</span> <span class="string">&#x27;Innodb_buffer_pool_pages_total&#x27;</span>) <span class="keyword">AS</span> total_pages</span><br><span class="line">) t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">GLOBAL</span> STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;Innodb_buffer_pool_pages_%&#x27;</span>;</span><br></pre></td></tr></table></figure><p>脏页刷盘触发的条件：</p><table><thead><tr><th>触发条件</th><th>是否字段</th><th>是否阻塞用户线程</th><th>说明</th></tr></thead><tbody><tr><td>Checkpoint 推进</td><td>是</td><td>否（异步）</td><td>最主要机制，由 redo log 空间或脏页比例驱动</td></tr><tr><td>Buffer Pool 满（LRU淘汰）</td><td>是</td><td>是（可能等待）</td><td>高并发写 + 缓冲池小 → 性能瓶颈</td></tr><tr><td>脏页比例超阈值</td><td>是</td><td>否（异步）</td><td>由<code>innodb_max_dirty_pages_pct</code>控制</td></tr><tr><td>Page Cleaner 定时任务</td><td>是</td><td>否</td><td>每秒后台刷脏，受 I/O capacity 控制</td></tr><tr><td>实例关闭（SHUTDOWN）</td><td>是</td><td>是（阻塞）</td><td>Sharp Checkpoint，刷所有脏页</td></tr><tr><td>手动命令（FLUSH/OPTIMIZE）</td><td>否</td><td>是</td><td>运维操作，谨慎执行</td></tr><tr><td>Redo Log 空间不足</td><td>是</td><td>可能阻塞写入</td><td>强制推进 checkpoint，刷对应脏页</td></tr></tbody></table><blockquote><p>mysql <strong>连坐机制</strong>：如果要刷盘的脏页相邻的数据页恰好也是脏页，就一起写入磁盘，如果邻居的邻居也是如此。</p><p>在机械硬盘时代这个策略可以减少随机IO，但如果使用固态硬盘的话随机IO的性能往往比较高，所以使用这个策略反而拖累了查询性能。因此可以通过 <code>innodb_flush_neighbors</code> 关闭这个“连坐”的策略。</p></blockquote><h4 id="连接与线程">连接与线程</h4><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 根据业务调整</span></span><br><span class="line"><span class="attr">max_connections</span> = <span class="number">500</span></span><br><span class="line"><span class="comment"># 缓存线程避免频繁创建</span></span><br><span class="line"><span class="attr">thread_cache_size</span> = <span class="number">50</span></span><br></pre></td></tr></table></figure><h4 id="临时表与排序">临时表与排序</h4><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">tmp_table_size</span> = <span class="number">64</span>M</span><br><span class="line"><span class="attr">max_heap_table_size</span> = <span class="number">64</span>M</span><br><span class="line"><span class="comment"># 每连接分配，不宜过大</span></span><br><span class="line"><span class="attr">sort_buffer_size</span> = <span class="number">2</span>M</span><br></pre></td></tr></table></figure><p>修改后重启或 <code>SET GLOBAL</code> 生效，建议压测验证。</p><h3 id="监控与慢查询优化（手段穷极）">监控与慢查询优化（手段穷极）</h3><ol><li class="lvl-3"><p>开启慢查询日志</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">slow_query_log</span> = <span class="number">1</span></span><br><span class="line"><span class="attr">slow_query_log_file</span> = /var/log/mysql/slow.log</span><br><span class="line"><span class="attr">long_query_time</span> = <span class="number">1</span>                  <span class="comment"># 超过1秒记录</span></span><br><span class="line"><span class="attr">log_queries_not_using_indexes</span> = <span class="number">1</span>    <span class="comment"># 记录未用索引的查询</span></span><br></pre></td></tr></table></figure></li><li class="lvl-3"><p>使用工具分析慢查询</p><blockquote><ul class="lvl-3"><li class="lvl-2"><code>mysqldumpslow</code>（MySQL自带）</li><li class="lvl-2"><code>pt-query-digest</code>（Percona Toolkit，推荐）</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pt<span class="operator">-</span>query<span class="operator">-</span>digest <span class="operator">/</span>var<span class="operator">/</span>log<span class="operator">/</span>mysql<span class="operator">/</span>slow.log</span><br></pre></td></tr></table></figure></blockquote></li><li class="lvl-3"><p>监控工具</p><blockquote><ul class="lvl-3"><li class="lvl-2"><strong>实时监控</strong>：<code>SHOW PROCESSLIST</code>, <code>SHOW STATUS</code>, <code>SHOW ENGINE INNODB STATUS</code></li><li class="lvl-2">可视化监控：<ul class="lvl-5"><li class="lvl-4">Prometheus + Grafana + mysqld_exporter</li><li class="lvl-4">Percona PMM（推荐）</li><li class="lvl-4">MySQL Workbench Performance Dashboard</li></ul></li></ul></blockquote></li></ol><h3 id="架构层优化（高并发-大数据）">架构层优化（高并发/大数据）</h3><ol><li class="lvl-3"><p><strong>读写分离</strong></p><p>主库写，多个从库读（通过 ProxySQL / MaxScale / 中间件路由）</p></li><li class="lvl-3"><p><strong>分库分表</strong></p><ul class="lvl-2"><li class="lvl-5">使用 ShardingSphere / MyCat / Vitess 等中间件</li><li class="lvl-5">按用户ID、时间等维度拆分</li></ul></li><li class="lvl-3"><p><strong>引入缓存层</strong></p><ul class="lvl-2"><li class="lvl-5">Redis / Memcached 缓存热点数据</li><li class="lvl-5">缓存查询结果或对象，减轻数据库压力</li></ul></li><li class="lvl-4"><p><strong>异步化与队列</strong></p></li></ol><ul class="lvl-0"><li class="lvl-5"><p>非核心写操作走消息队列（如 Kafka、RabbitMQ）</p></li><li class="lvl-5"><p>延迟写、批量写优化吞吐</p></li></ul><ol start="5"><li class="lvl-4"><p><strong>数据归档与冷热分离</strong></p></li></ol><ul class="lvl-0"><li class="lvl-5"><p>历史数据迁移到归档库或数仓（ClickHouse / Hive）</p></li><li class="lvl-5"><p>在线库只保留热数据</p></li></ul><h2 id="实用的优化方案">实用的优化方案</h2><p>实际中经常碰到的问题和优化方案。</p><h3 id="如何提高数据插入效率">如何提高数据插入效率</h3><ul class="lvl-0"><li class="lvl-2"><p>合并insert语句（批量插入）。日志量减少（binlog、undolog），日志刷盘数量和频率就减少，SQL解析也减少。</p></li><li class="lvl-2"><p>适当调高缓冲区参数值  <code>bulk_insert_buffer_size</code>。批量插入时支持更多数据。</p></li><li class="lvl-2"><p>设置 事务日志刷盘策略  <code>innodb_flush_log_at_trx_commit = 0</code>，默认为1。</p><blockquote><p>=1：每个事务提交都会刷新日志（buffer -&gt; file），和文件同步磁盘。<br>=0：每秒执行一次刷新，和文件到磁盘同步。<br>=2：每个事务会刷新日志（buffer -&gt; file），但不会立即同步磁盘。文件到磁盘同步，是每秒一次</p></blockquote></li><li class="lvl-2"><p>手动提交事务（执行完成后，统一提交事务）。</p></li></ul><h3 id="频繁更新数据的优化方案">频繁更新数据的优化方案</h3><p>频繁更新数据库可通过<strong>索引、减少锁定时间、使用批量更新、优化SQL查询、分区表和分布式数据库</strong>等手段提高性能和效率。</p><blockquote><p>其中，优化索引是一个最为基础且有效的方法，通过对数据库表进行适当的索引设计，可以显著减少查询和更新操作的时间。</p><p>索引优化不仅能加快查询速度，还能减少数据库的负载。选择合适的索引类型（如B-树索引、哈希索引等）以及正确地为表中的关键字段设置索引，可以使数据库在处理频繁更新操作时更加高效。特别是对于主键和外键的索引优化，能极大地提高数据访问和修改的速度。</p></blockquote><p><strong>优化索引</strong></p><blockquote><ul class="lvl-1"><li class="lvl-2"><p><strong>选择合适的索引类型</strong></p><ul class="lvl-3"><li class="lvl-4"><strong>B-树索引</strong>：适用于大多数查询操作，特别是在范围查询和排序操作中表现优异。</li><li class="lvl-4"><strong>哈希索引</strong>：适用于等值查询，但不适用于范围查询。</li><li class="lvl-4"><strong>全文索引</strong>：适用于文本搜索操作，如在文章中搜索关键词。</li></ul></li><li class="lvl-2"><p><strong>为关键字段设置索引</strong></p><p>对于主键和外键字段，设置索引可以极大地提高数据的访问和修改速度。</p><ul class="lvl-3"><li class="lvl-4"><p><strong>主键索引</strong>：主键通常是唯一的，可以显著加快数据查询和更新操作。</p></li><li class="lvl-4"><p><strong>外键索引</strong>：外键索引可以加快表之间的关联查询操作，提高数据一致性。</p></li></ul></li></ul></blockquote><p><strong>减少锁定时间</strong></p><blockquote><ul class="lvl-1"><li class="lvl-2"><p><strong>使用行级锁</strong>：只锁定被修改的行，减少锁定冲突，锁定时间越短，数据库并发性能就越高。</p></li><li class="lvl-2"><p><strong>使用乐观锁</strong>：乐观锁是一种减少锁定时间的策略，它假设数据冲突的概率较低，在提交数据时才进行冲突检测。</p></li></ul></blockquote><p><strong>使用批量更新</strong></p><blockquote><ul class="lvl-1"><li class="lvl-2"><p><strong>批量插入和更新</strong>：将多条插入操作合并为一条，可以减少数据库的I/O操作，可以显著提高数据库的性能。</p></li><li class="lvl-2"><p><strong>使用事务控制</strong>：使用事务控制可以确保数据的完整性和一致性，同时可以减少锁定时间，提高数据库的性能。</p></li></ul></blockquote><p><strong>优化SQL查询</strong></p><blockquote><ul class="lvl-1"><li class="lvl-2"><p><strong>避免使用复杂的嵌套查询</strong>：复杂的嵌套查询会导致数据库性能下降，尽量避免使用复杂的嵌套查询。</p></li><li class="lvl-2"><p><strong>使用查询缓存</strong>：查询缓存是一种提高数据库性能的有效方法，它将查询结果缓存到内存中，减少数据库I/O操作。</p></li></ul></blockquote><p><strong>分区表和分布式数据库</strong></p><blockquote><ul class="lvl-1"><li class="lvl-2"><p><strong>分区表</strong>：分区表是一种将大表拆分为多个小表的策略，减少查询和更新操作的时间，提高数据库的性能。</p></li><li class="lvl-2"><p><strong>分布式数据库</strong>：分布式数据库是一种将数据分布到多个节点上的策略，可以显著提高数据库的性能和可扩展性。</p></li></ul></blockquote><p><strong>使用缓存</strong></p><blockquote><ul class="lvl-1"><li class="lvl-2"><p><strong>应用层缓存</strong>：在应用层使用缓存可以减少对数据库的访问，提高系统的性能。</p></li><li class="lvl-2"><p><strong>数据库层缓存</strong>：在数据库层使用缓存可以减少数据库的I/O操作，提高数据库的性能。</p></li></ul></blockquote><p><strong>数据库集群和负载均衡</strong></p><blockquote><ul class="lvl-1"><li class="lvl-2"><p><strong>数据库集群</strong>：数据库集群是一种将多个数据库服务器组合在一起的策略，可以显著提高数据库的性能和可用性。</p></li><li class="lvl-2"><p><strong>负载均衡</strong>：负载均衡是一种将请求分发到多个服务器上的策略，可以显著提高系统的性能和可用性。</p></li></ul></blockquote><p><strong>数据库监控和调优</strong></p><blockquote><ul class="lvl-1"><li class="lvl-2"><p><strong>数据库监控</strong>：数据库监控是一种实时监控数据库性能的策略，可以及时发现和解决性能问题。</p></li><li class="lvl-2"><p><strong>数据库调优</strong>：数据库调优是一种通过调整数据库配置和参数来提高性能的策略。</p></li></ul></blockquote><p><strong>使用高效的存储引擎</strong></p><blockquote><ul class="lvl-1"><li class="lvl-2"><p><strong>选择合适的存储引擎</strong>：不同的存储引擎适用于不同的应用场景，选择合适的存储引擎可以显著提高数据库的性能。</p></li><li class="lvl-2"><p><strong>优化存储引擎配置</strong>：优化存储引擎的配置可以提高数据库的性能和稳定性。</p></li></ul></blockquote><p><strong>数据归档和清理</strong></p><blockquote><ul class="lvl-1"><li class="lvl-2"><p><strong>定期归档数据</strong>：定期归档不常用的数据，可以减少数据库的负载，提高数据库的性能。</p></li><li class="lvl-2"><p><strong>定期清理数据</strong>：定期清理无用的数据，可以减少数据库的存储空间，提高数据库的性能。</p></li></ul></blockquote><p><strong>数据库设计优化</strong></p><blockquote><ul class="lvl-1"><li class="lvl-2"><p><strong>规范化数据库设计</strong>：通过规范化数据库设计，可以减少数据冗余，提高数据库的性能和一致性。</p></li><li class="lvl-2"><p><strong>反规范化设计</strong>：在某些情况下，通过反规范化设计可以提高数据库的查询性能。</p></li></ul></blockquote><h3 id="内存碎片的优化方案">内存碎片的优化方案</h3><p>MySQL碎片指的是MySQL数据文件中一些不连续的空白空间，这些空间无法再被全部利用，久而久之越来越多越来越零碎。</p><p>MySQL 碎片的本质是“空间分配与回收不同步”或“空间利用率下降”。</p><h4 id="碎片产生的原因">碎片产生的原因</h4><p>MySQL 中的“碎片”通常是指由于数据的频繁增删改操作，导致存储空间未能被高效利用，从而在磁盘或内存中产生不连续、空闲但无法被有效重用的空间。碎片主要影响性能和存储效率。</p><blockquote><p>当执行插入操作时，MySQL会尝试使用空白空间，如果插入的数据刚好按照索引排序落在被删除数据的区间，可能会复用这个位置，但如果某个空白空间一直没有被大小合适的数据占用，仍然无法将其彻底占用，就形成了碎片；</p><p>【MySQL的几种删除情况】</p><blockquote><ul class="lvl-2"><li class="lvl-2"><p>drop、truncate    不管是InnoDB还是MyISAM都立刻释放磁盘空间</p></li><li class="lvl-2"><p>delete from table_name  删除全部表数据，MyISAM立刻释放磁盘空间，InnoDB不会立刻释放磁盘空间</p></li><li class="lvl-2"><p>delete from table_name where xxx     带条件的删除不管是InnoDB还是MyISAM都不会立刻释放</p></li><li class="lvl-2"><p>delete from table_name     虽然未立刻释放磁盘空间，但下次插入的时候仍然可以使用这部分空间</p></li></ul></blockquote></blockquote><p>以下是 MySQL 碎片产生的主要原因：</p><p>一、<strong>数据删除操作</strong>（DELETE）</p><blockquote><ul class="lvl-1"><li class="lvl-2"><p>删除记录后，原数据页中的空间并不会立即归还给操作系统，而是标记为“可重用”。磁盘的文件大小不会收缩。InnoDB的Purge线程会异步的来清理这些没用的索引键和行。</p></li><li class="lvl-2"><p>如果后续插入的数据大小不匹配或插入位置不连续，就会形成“空洞”，即碎片。</p></li><li class="lvl-2"><p>大量 DELETE 操作后未进行优化，碎片会持续累积。</p></li></ul></blockquote><p>二、<strong>数据更新导致行变长</strong>（UPDATE）</p><blockquote><ul class="lvl-1"><li class="lvl-2"><p>当 UPDATE 操作使某行数据长度增加（如 VARCHAR 字段内容变长），原位置空间不足时，MySQL 会将该行迁移到新的数据页，原位置留下空洞。</p></li><li class="lvl-2"><p>尤其在 InnoDB 中，行溢出或页分裂会加剧碎片。</p></li></ul><p>Innodb的最小物理存储分配单位是页(page)，而UPDATE也可能导致页分裂，频繁的页分裂，页会变得稀疏，并且被不规则的填充，所以最终数据会有碎片。例如原始数据长度varchar(100)，大规模更新数据长度为50，这样的话，有50的空间被空白了，新入库的数据不能完全利用剩余的50，这就会产生碎片。</p></blockquote><p>三、<strong>频繁的插入和删除交替操作</strong>（INSERT/DELETE）</p><blockquote><ul class="lvl-1"><li class="lvl-2"><p>高频的写入和删除会导致数据页中留下大量不连续的小块空闲空间。</p></li><li class="lvl-2"><p>这些空间可能因为太小或位置分散，无法容纳新插入的行，造成空间浪费。</p></li></ul></blockquote><p>四、<strong>自增主键中断或非顺序插入</strong></p><blockquote><ul class="lvl-1"><li class="lvl-2"><p>按顺序写入可以减少碎片，但如果中间有删除或使用 UUID、随机主键等无序插入，会导致页内或页间数据不连续。</p></li><li class="lvl-2"><p>非顺序插入容易引发页分裂（Page Split），进而产生碎片。</p></li></ul></blockquote><p>五、<strong>页分裂</strong>（Page Split） —— InnoDB 特有</p><blockquote><ul class="lvl-1"><li class="lvl-2"><p>当一个数据页已满，而新数据需要插入到该页的中间位置时，InnoDB 会将该页一分为二（页分裂），腾出空间。</p></li><li class="lvl-2"><p>分裂后两个页可能都未填满，形成内部碎片。</p></li><li class="lvl-2"><p>频繁分裂会加剧碎片化并影响查询性能。</p></li></ul></blockquote><p>六、<strong>表结构变更</strong>（如 ALTER TABLE）</p><blockquote><ul class="lvl-1"><li class="lvl-2"><p>某些 ALTER 操作（如添加字段、修改类型）可能导致表重建或行格式变化，产生临时碎片。</p></li><li class="lvl-2"><p>在线 DDL 操作过程中也可能因中间状态产生碎片。</p></li></ul></blockquote><p>七、<strong>未及时重建表</strong></p><blockquote><ul class="lvl-1"><li class="lvl-2"><p>MySQL 不会自动整理碎片，长期运行的表若未定期优化，碎片会持续积累。</p></li><li class="lvl-2"><p>OPTIMIZE TABLE 或 ALTER TABLE … ENGINE=InnoDB 可重建表、整理碎片，但需手动或定时执行。</p></li></ul></blockquote><p>八、<strong>存储引擎特性</strong>（如 MyISAM vs InnoDB）</p><blockquote><ul class="lvl-1"><li class="lvl-2"><p>MyISAM：删除记录后留下空洞，碎片明显，需定期执行 OPTIMIZE。</p></li><li class="lvl-2"><p>InnoDB：虽然有“插入缓冲”和“页合并”机制，但高并发写入或大量更新仍会产生碎片，尤其在独立表空间（file-per-table）模式下。</p></li></ul></blockquote><p>九、<strong>大对象字段的存储和更新</strong>（BLOB/TEXT）</p><blockquote><ul class="lvl-1"><li class="lvl-2"><p>大字段可能导致行溢出（off-page storage），更新时容易造成原页空间浪费。</p></li><li class="lvl-2"><p>频繁更新大字段会加剧碎片问题。</p></li></ul></blockquote><p>十、<strong>事务回滚或 MVCC 机制残留</strong></p><blockquote><ul class="lvl-1"><li class="lvl-2"><p>InnoDB 的多版本并发控制（MVCC）会保留旧版本数据，直到无事务引用。</p></li><li class="lvl-2"><p>回滚段或 undo log 中旧数据占用空间，若清理不及时，也可能形成逻辑碎片（不影响数据页，但占用存储）。</p></li></ul></blockquote><h4 id="碎片会带来什么问题">碎片会带来什么问题</h4><p>MySQL 中的“碎片”虽然不会直接导致数据丢失或系统崩溃，但会带来一系列<strong>性能下降、资源浪费和运维复杂性增加</strong>的问题。</p><p>以下是碎片带来的主要负面影响：</p><p>一、<strong>性能下降</strong>（最核心问题）</p><blockquote><ol><li class="lvl-3"><p><strong>查询性能降低</strong></p><ul class="lvl-3"><li class="lvl-5"><p>碎片导致数据在磁盘或内存中<strong>物理不连续</strong>，查询时需要读取更多数据页才能获取完整结果。</p></li><li class="lvl-5"><p>尤其影响范围查询（<code>BETWEEN</code>、<code>&gt;</code>、<code>&lt;</code>）和全表扫描，I/O 次数增加，响应时间变长。</p></li></ul></li><li class="lvl-3"><p><strong>索引效率降低</strong></p><ul class="lvl-3"><li class="lvl-5"><p>索引结构（如 B+ 树）若因碎片导致节点分散，会增加树的高度或节点访问次数。</p></li><li class="lvl-5"><p>查询时需要加载更多索引页到内存，缓存命中率下降，执行计划变慢。</p></li></ul></li><li class="lvl-3"><p><strong>缓冲池利用率下降</strong>（Buffer Pool）</p><ul class="lvl-3"><li class="lvl-5"><p>InnoDB 缓冲池缓存的是数据页。碎片页中有效数据少，大量缓存空间被“空洞”占用。</p></li><li class="lvl-5"><p>导致真正需要的数据页无法被缓存，频繁从磁盘读取，拖慢整体性能。</p></li></ul></li></ol></blockquote><p>二、<strong>存储空间浪费</strong></p><blockquote><ol><li class="lvl-3"><p><strong>占用额外磁盘空间</strong></p><ul class="lvl-3"><li class="lvl-5"><p><code>Data_free</code>（表中未使用但未释放的空间）持续增长，实际数据量远小于表文件大小。</p></li><li class="lvl-5"><p>举例：一个 10GB 的表，可能只有 6GB 是真实数据，其余 4GB 是碎片空洞。</p></li></ul></li><li class="lvl-3"><p><strong>备份/迁移成本增加</strong></p><ul class="lvl-3"><li class="lvl-5"><p>备份工具（如 mysqldump、xtrabackup）会备份整个表文件（含碎片），导致备份文件更大、耗时更长。</p></li><li class="lvl-5"><p>数据迁移、复制、同步也会因体积膨胀而效率降低。</p></li></ul></li></ol></blockquote><p>三、<strong>写入性能受影响</strong></p><blockquote><ol><li class="lvl-3"><p><strong>插入效率降低</strong></p><ul class="lvl-3"><li class="lvl-5"><p>当新数据无法填入现有碎片空洞时，MySQL 需分配新页，增加 I/O 和页管理开销。</p></li><li class="lvl-5"><p>频繁页分裂（Page Split）也会拖慢 INSERT/UPDATE 操作。</p></li></ul></li><li class="lvl-3"><p><strong>更新操作成本上升</strong>：如果更新导致行迁移（Migration），需要写入新页 + 维护指针 + 清理旧位置，开销更大。</p></li></ol></blockquote><p>四、<strong>维护成本增加</strong></p><blockquote><ol><li class="lvl-3"><p><strong>需要定期人工干预</strong></p><ul class="lvl-3"><li class="lvl-5"><p>必须定期执行 <code>OPTIMIZE TABLE</code> 或重建表，否则碎片持续累积。</p></li><li class="lvl-5"><p>大表优化耗时长、锁表风险高（尤其 MyISAM），影响业务可用性。</p></li></ul></li><li class="lvl-3"><p><strong>监控和诊断复杂化</strong></p><ul class="lvl-3"><li class="lvl-5"><p>需监控 <code>information_schema.TABLES.Data_free</code>、表大小增长率、查询执行时间变化等指标。</p></li><li class="lvl-5"><p>性能问题排查时，碎片可能成为“隐藏元凶”，增加诊断难度。</p></li></ul></li></ol></blockquote><p>五、<strong>扩展性和高可用受影响</strong></p><blockquote><ol><li class="lvl-3"><p><strong>主从复制延迟可能加剧</strong>：大量碎片表在主库执行 <code>OPTIMIZE </code>会产生大量 binlog，从库重放时会造成复制延迟。</p></li><li class="lvl-3"><p><strong>云数据库/容器环境成本上升</strong></p></li></ol><ul class="lvl-1"><li class="lvl-2"><p>在按存储计费的云环境（如 AWS RDS、阿里云 RDS）中，碎片导致“虚胖”表，多花冤枉钱。</p></li><li class="lvl-2"><p>容器存储卷空间被无效占用，影响弹性扩缩容。</p></li></ul></blockquote><p>六、极端情况：<strong>系统稳定性风险</strong></p><blockquote><ul class="lvl-1"><li class="lvl-2"><p>表空间文件（如 ibdata1 或 .ibd 文件）过度膨胀，可能占满磁盘，导致数据库写入失败或服务中断。</p></li><li class="lvl-2"><p>自动扩容机制若未配置，可能引发严重生产事故。</p></li></ul></blockquote><h4 id="如何清理碎片">如何清理碎片</h4><p>清理 MySQL 中的碎片是数据库日常维护的重要任务，目的是<strong>回收无效空间、提升查询性能、减少存储占用、优化缓存效率</strong>。</p><p>不同存储引擎（如 InnoDB、MyISAM）清理方式略有不同，以下是完整、实用的碎片清理方案：</p><p><strong>一、OPTIMIZE TABLE</strong>（通用方法）</p><p>推荐用于 MyISAM 和部分 InnoDB，Optimize语句可以<strong>重新组织表和索引</strong>的物理存储，减少存储空间，提高访问的IO效率</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">OPTIMIZE <span class="keyword">TABLE</span> table_name;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 示例：</span></span><br><span class="line">OPTIMIZE <span class="keyword">TABLE</span> orders;</span><br><span class="line"><span class="comment">-- +----------------+----------+----------+---------------------------------------------------+</span></span><br><span class="line"><span class="comment">-- | Table          | Op       | Msg_type | Msg_text                                              </span></span><br><span class="line"><span class="comment">-- +----------------+----------+----------+---------------------------------------------------+</span></span><br><span class="line"><span class="comment">-- | test.orders    | optimize | status   | OK                                 </span></span><br><span class="line"><span class="comment">-- +----------------+----------+----------+---------------------------------------------------+</span></span><br></pre></td></tr></table></figure><blockquote><ul class="lvl-1"><li class="lvl-2"><p>重建表结构、整理碎片、回收未使用空间。</p></li><li class="lvl-2"><p>对 MyISAM：效果显著，会重建索引和数据文件。</p></li><li class="lvl-2"><p>对 InnoDB（独立表空间模式 innodb_file_per_table=1）才有作用：等价于 <code>ALTER TABLE ... FORCE</code>，重建表和索引。</p></li></ul></blockquote><p><strong>注意事项</strong>：</p><blockquote><ul class="lvl-1"><li class="lvl-2"><p><strong>锁表操作</strong>：执行期间表会被锁定（MyISAM 全锁，InnoDB 可能短暂锁）。数据量越大的表，优化耗时越长，百万条数据大约耗时30s(约25000-30000行/秒)。在磁盘优化时，所有的增删操作将受限。</p></li><li class="lvl-2"><p><strong>空间要求</strong>：需要额外磁盘空间存放临时表（约等于原表大小）。剩余空间必须 &gt; 被optimize的表大小</p></li><li class="lvl-2"><p><strong>权限要求</strong>：使用这个语句需要对目标表具有select、insert权限</p></li><li class="lvl-2"><p><strong>主从复制</strong>：会记录到 binlog，在从库重放，可能引起复制延迟。</p></li><li class="lvl-2"><p><strong>大表慎用</strong>：建议在业务低峰期执行。</p></li></ul></blockquote><p><strong>二、重建表</strong>（InnoDB 专用方法）</p><p>更灵活、推荐用于生产环境</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 使用 ALTER TABLE 重建，本质上是recreate，期间支持DML查询和更新操作</span></span><br><span class="line"><span class="keyword">ALTER TABLE</span> table_name ENGINE<span class="operator">=</span>InnoDB;</span><br><span class="line"><span class="comment">-- MySQL 5.7+ 支持的语法，明确表示强制重建表，等价于更改引擎为当前引擎</span></span><br><span class="line"><span class="keyword">ALTER TABLE</span> table_name FORCE;</span><br><span class="line"></span><br><span class="line"><span class="comment">----------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用在线 DDL（MySQL 5.6+，推荐）</span></span><br><span class="line"><span class="comment">-- ALGORITHM=INPLACE：原地重建，减少空间占用。LOCK=NONE：尽量不锁表（取决于操作类型和版本）。</span></span><br><span class="line"><span class="keyword">ALTER TABLE</span> table_name ENGINE<span class="operator">=</span>InnoDB, ALGORITHM<span class="operator">=</span>INPLACE, LOCK<span class="operator">=</span><span class="keyword">NONE</span>;</span><br></pre></td></tr></table></figure><blockquote><ul class="lvl-1"><li class="lvl-2"><p>更可控，支持在线操作（部分场景）。</p></li><li class="lvl-2"><p>可结合其他 DDL 一起执行（如加索引、改字段）。</p></li></ul></blockquote><p><strong>操作过程</strong>：</p><blockquote><ol><li class="lvl-3"><p>获取MDL（meta data lock）写锁，innodb内部创建与原表结构相同的临时文件</p></li><li class="lvl-3"><p>拷贝数据前，MDL写锁退化成读锁，支持DML更新操作</p></li><li class="lvl-3"><p>根据主键递增顺序，将数据读出并写到临时文件，直到全部写入，并且拷贝期间的DML更新操作会记录到Row log中</p></li><li class="lvl-3"><p>上锁，再将Row log中的数据应用到临时文件</p></li><li class="lvl-3"><p>互换原表和临时表的名字</p></li><li class="lvl-3"><p>删除临时表</p></li></ol></blockquote><p><strong>三、分区表碎片清理</strong>（针对 RANGE/LIST 分区）</p><p>如果表是分区表，可以<strong>只优化特定碎片严重的分区</strong>，减少影响：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER TABLE</span> table_name OPTIMIZE <span class="keyword">PARTITION</span> partition_name;</span><br><span class="line"><span class="comment">-- 或</span></span><br><span class="line"><span class="keyword">ALTER TABLE</span> table_name REBUILD <span class="keyword">PARTITION</span> partition_name;</span><br></pre></td></tr></table></figure><blockquote><p>适用于日志表、时间分表等场景，按月/日分区，只清理历史分区。</p></blockquote><p><strong>四、批量清理多个表的碎片</strong></p><p>方法1：SQL 脚本自动生成优化语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> CONCAT(<span class="string">&#x27;OPTIMIZE TABLE &#x27;</span>, table_schema, <span class="string">&#x27;.&#x27;</span>, table_name, <span class="string">&#x27;;&#x27;</span>) <span class="keyword">AS</span> sql_stmt</span><br><span class="line"><span class="keyword">FROM</span> information_schema.tables</span><br><span class="line"><span class="keyword">WHERE</span> table_schema <span class="operator">=</span> <span class="string">&#x27;your_database&#x27;</span></span><br><span class="line">  <span class="keyword">AND</span> data_free <span class="operator">&gt;</span> <span class="number">1024</span> <span class="operator">*</span> <span class="number">1024</span> <span class="operator">*</span> <span class="number">100</span>  <span class="comment">-- 碎片大于100MB的表</span></span><br><span class="line">  <span class="keyword">AND</span> engine <span class="keyword">IN</span> (<span class="string">&#x27;InnoDB&#x27;</span>, <span class="string">&#x27;MyISAM&#x27;</span>);</span><br></pre></td></tr></table></figure><p>方法2：Shell 脚本 + MySQL 命令行（定时任务）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">DB_USER=<span class="string">&quot;root&quot;</span></span><br><span class="line">DB_PASS=<span class="string">&quot;password&quot;</span></span><br><span class="line">DB_NAME=<span class="string">&quot;your_db&quot;</span></span><br><span class="line"></span><br><span class="line">mysql -u<span class="variable">$DB_USER</span> -p<span class="variable">$DB_PASS</span> -Nse <span class="string">&quot;</span></span><br><span class="line"><span class="string">SELECT CONCAT(&#x27;OPTIMIZE TABLE &#x27;, table_schema, &#x27;.&#x27;, table_name, &#x27;;&#x27;)</span></span><br><span class="line"><span class="string">FROM information_schema.tables</span></span><br><span class="line"><span class="string">WHERE table_schema = &#x27;<span class="variable">$DB_NAME</span>&#x27;</span></span><br><span class="line"><span class="string">  AND data_free &gt; 100*1024*1024</span></span><br><span class="line"><span class="string">  AND engine IN (&#x27;InnoDB&#x27;,&#x27;MyISAM&#x27;);</span></span><br><span class="line"><span class="string">&quot;</span> | mysql -u<span class="variable">$DB_USER</span> -p<span class="variable">$DB_PASS</span></span><br></pre></td></tr></table></figure><blockquote><p>建议每周或每月低峰期执行一次。</p></blockquote><p><strong>五、监控碎片程度</strong>（执行前判断是否需要清理）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看表碎片大小（Data_free）：</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    table_name,</span><br><span class="line">    engine,</span><br><span class="line">    data_length,</span><br><span class="line">    index_length,</span><br><span class="line">    data_free,</span><br><span class="line">    ROUND(data_free <span class="operator">/</span> (data_length <span class="operator">+</span> index_length) <span class="operator">*</span> <span class="number">100</span>, <span class="number">2</span>) <span class="keyword">AS</span> frag_percent</span><br><span class="line"><span class="keyword">FROM</span> information_schema.tables</span><br><span class="line"><span class="keyword">WHERE</span> table_schema <span class="operator">=</span> <span class="string">&#x27;your_database&#x27;</span></span><br><span class="line">  <span class="keyword">AND</span> data_free <span class="operator">&gt;</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> data_free <span class="keyword">DESC</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 通过 `show table status like &#x27;表名&#x27;` 查看表的状态，如果data_free字段不为0则表示有碎片存在</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    CONCAT( <span class="keyword">TRUNCATE</span> ( <span class="built_in">SUM</span>( data_length ) <span class="operator">/</span> <span class="number">1024</span> <span class="operator">/</span> <span class="number">1024</span>, <span class="number">2</span> ), <span class="string">&#x27;MB&#x27;</span> ) <span class="keyword">AS</span> data_size,</span><br><span class="line">    CONCAT( <span class="keyword">TRUNCATE</span> ( <span class="built_in">SUM</span>( data_free ) <span class="operator">/</span> <span class="number">1024</span> <span class="operator">/</span> <span class="number">1024</span>, <span class="number">2</span> ), <span class="string">&#x27;MB&#x27;</span> ) <span class="keyword">AS</span> data_free,</span><br><span class="line">    CONCAT( <span class="keyword">TRUNCATE</span> ( <span class="built_in">SUM</span>( index_length ) <span class="operator">/</span> <span class="number">1024</span> <span class="operator">/</span> <span class="number">1024</span>, <span class="number">2</span> ), <span class="string">&#x27;MB&#x27;</span> ) <span class="keyword">AS</span> index_size </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    information_schema.TABLES </span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    TABLE_NAME <span class="operator">=</span> <span class="string">&#x27;tableName&#x27;</span>; </span><br></pre></td></tr></table></figure><blockquote><p>建议：碎片率 &gt; 10% 或碎片大小 &gt; 1GB 的表优先优化。</p></blockquote><p>六、特殊情况处理</p><ol><li class="lvl-3"><p><strong>共享表空间碎片</strong>（ibdata1）</p><blockquote><p>此操作风险高，仅建议在维护窗口或新系统部署时进行。</p><ul class="lvl-3"><li class="lvl-2"><p>如果使用系统表空间（innodb_file_per_table=OFF），所有表数据存在 ibdata1，碎片无法单独清理。</p></li><li class="lvl-2"><p>解决方案：</p><ol><li class="lvl-5">备份所有数据（mysqldump）</li><li class="lvl-5">停止 MySQL，删除 ibdata1、ib_logfile*</li><li class="lvl-5">启用 <code>innodb_file_per_table=ON</code></li><li class="lvl-5">恢复数据 → 每个表独立 .ibd 文件，可单独优化</li></ol></li></ul></blockquote></li><li class="lvl-3"><p>大表优化太慢？</p><p>使用 <strong>pt-online-schema-change</strong>（Percona Toolkit）工具在线重建表，几乎无锁：支持大表在线优化，不影响业务读写。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pt<span class="operator">-</span>online<span class="operator">-</span>schema<span class="operator">-</span>change <span class="comment">--alter &quot;ENGINE=InnoDB&quot; D=your_db,t=your_table --execute</span></span><br></pre></td></tr></table></figure></li></ol><p><strong>预防碎片的最佳实践</strong>（治本之策）</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><strong>使用自增主键</strong></td><td>保证数据顺序插入，减少页分裂</td></tr><tr><td><strong>避免频繁 UPDATE 大字段</strong></td><td>如 TEXT/BLOB，更新易导致行迁移</td></tr><tr><td><strong>定期归档历史数据</strong></td><td>减少活跃数据量，降低碎片产生速度</td></tr><tr><td><strong>合理设置页填充因子</strong></td><td>InnoDB 默认已优化，一般无需调整</td></tr><tr><td><strong>使用 SSD + 合理 buffer pool</strong></td><td>减轻碎片对 I/O 的影响</td></tr><tr><td><strong>监控 + 自动化脚本</strong></td><td>定期检查碎片，自动触发优化</td></tr></tbody></table><p><strong>碎片清理操作速查表</strong></p><table><thead><tr><th>场景</th><th>推荐命令</th><th>说明</th></tr></thead><tbody><tr><td>小表 / MyISAM 表</td><td><code>OPTIMIZE TABLE t;</code></td><td>简单直接，会锁表</td></tr><tr><td>InnoDB 表重建</td><td><code>ALTER TABLE t ENGINE=InnoDB;</code></td><td>更灵活，支持在线选项</td></tr><tr><td>在线无锁优化</td><td><code>ALTER TABLE t ENGINE=InnoDB, ALGORITHM=INPLACE, LOCK=NONE;</code></td><td>MySQL 5.6+</td></tr><tr><td>分区表优化</td><td><code>ALTER TABLE t OPTIMIZE PARTITION p0;</code></td><td>针对性清理</td></tr><tr><td>批量清理</td><td>用 SQL 生成脚本 + 定时任务</td><td>自动化运维</td></tr><tr><td>超大表在线优化</td><td><code>pt-online-schema-change</code></td><td>第三方工具，推荐生产环境</td></tr></tbody></table><blockquote><ul class="lvl-1"><li class="lvl-2"><p><strong>监控先行</strong>：不要盲目优化，先查碎片率和大小。</p></li><li class="lvl-2"><p><strong>低峰操作</strong>：选择业务低谷期执行，避免影响线上服务。</p></li><li class="lvl-2"><p><strong>备份保障</strong>：重要表优化前做备份。</p></li><li class="lvl-2"><p><strong>自动化 + 预防</strong>：建立定期维护机制 + 优化表设计，从源头减少碎片。</p></li></ul></blockquote><h3 id="其他实用技巧">其他实用技巧</h3><ul class="lvl-0"><li class="lvl-2"><p><strong>使用连接池</strong>：避免频繁创建/销毁连接（HikariCP、Druid）</p></li><li class="lvl-2"><p><strong>避免大事务</strong>：拆分成小事务，减少锁竞争和回滚段压力</p></li><li class="lvl-2"><p><strong>合理使用锁</strong>：避免 <code>SELECT ... FOR UPDATE</code> 滥用</p></li><li class="lvl-2"><p><strong>批量操作</strong>：INSERT/UPDATE 使用批量语句，减少交互次数</p></li></ul>]]></content>
    
    
    <summary type="html">MySQL 数据库性能优化是系统性工程，涉及SQL语句、表结构、索引、配置、磁盘IO、架构设计等多层面</summary>
    
    
    
    <category term="DB" scheme="https://pengline.github.io/categories/DB/"/>
    
    <category term="MySQL" scheme="https://pengline.github.io/categories/DB/MySQL/"/>
    
    
    <category term="MySQL性能优化" scheme="https://pengline.github.io/tags/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    <category term="MySQL索引" scheme="https://pengline.github.io/tags/MySQL%E7%B4%A2%E5%BC%95/"/>
    
    <category term="刷盘策略" scheme="https://pengline.github.io/tags/%E5%88%B7%E7%9B%98%E7%AD%96%E7%95%A5/"/>
    
    <category term="内存碎片" scheme="https://pengline.github.io/tags/%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87/"/>
    
    <category term="批量插入" scheme="https://pengline.github.io/tags/%E6%89%B9%E9%87%8F%E6%8F%92%E5%85%A5/"/>
    
    <category term="频繁更新" scheme="https://pengline.github.io/tags/%E9%A2%91%E7%B9%81%E6%9B%B4%E6%96%B0/"/>
    
    <category term="慢查询" scheme="https://pengline.github.io/tags/%E6%85%A2%E6%9F%A5%E8%AF%A2/"/>
    
  </entry>
  
  <entry>
    <title>分库分表之跨表分页查询解决方案</title>
    <link href="https://pengline.github.io/2025/09/05/351e0f653b484f3cb3ed3c71e3c1bb5a/"/>
    <id>https://pengline.github.io/2025/09/05/351e0f653b484f3cb3ed3c71e3c1bb5a/</id>
    <published>2025-09-05T08:00:46.191Z</published>
    <updated>2025-09-06T13:56:06.870Z</updated>
    
    <content type="html"><![CDATA[<p>分库与分表的目的在于，减小数据库的单库单表负担，提高查询性能，缩短查询时间。</p><blockquote><p>热数据：使用MySQL进行存储，分库分表；</p><p>冷数据：ES 或 TiDB或Hive存储；</p></blockquote><h2 id="分库分表的基本概念">分库分表的基本概念</h2><h3 id="分库">分库</h3><p>数据表分布到不同库中，减轻单一库的压力，提高数据性能和安全性。</p><p>分库带来的问题和挑战：</p><blockquote><p><strong>数据迁移与扩容问题</strong>：一般做法是通过程序先读出数据，然后按照指定的分表策略再将数据写入到各个分表中。<br><strong>分页与排序问题</strong>：需要在不同的分表中将数据进行排序并返回，并将不同分表返回结果集进行汇总和再次排序，最后再返回给用户。<br><strong>分布式全局唯一ID</strong>：UUID、GUID等</p></blockquote><h3 id="分表（水平-垂直）">分表（水平+垂直）</h3><p>分表可以减少数据库的单表负担，将压力分散到不同的表上，减少单表数据量，提高查询性能，缩短查询时间和缓解表锁的问题。</p><p><strong>水平分表（同列拆数据）</strong>：Hash取模分表就属于随机水平分表，而时间维度分表则属于连续水平分表（车辆轨迹）。</p><p><strong>垂直分表（不同列拆列）</strong>：将不常用的字段单独拆分到另外一张扩展表. 将大文本的字段单独拆分到另外一张扩展表, 将不经常修改的字段放在同一张表中，将经常改变的字段放在另一张表中，将列表的共用字段放一起（车辆、摄像头、果壳箱告警）。</p><blockquote><p>对于海量用户场景，可以考虑hash取模分表，数据相对比较均匀，不容易出现热点和并发访问的瓶颈。</p><p>库内分表仅仅是解决了单表数据过大的问题，但并没有把单表的数据分散到不同的物理机上，因此并不能减轻 MySQL 服务器的压力，仍然存在同一个物理机上的资源竞争和瓶颈，包括 CPU、内存、磁盘 IO、网络带宽等。</p></blockquote><p>一张表分很多表后，每一个小表都是完整的一张表，对应三个文件（MyISAM引擎：.MYD数据文件，.MYI索引文件，.frm表结构文件）。</p><h3 id="分片（跨库-水平分表）">分片（跨库-水平分表）</h3><p>分片是将一个逻辑上的数据库或表切分成多个物理上的数据库或表，每个分片都包含一部分数据。分片可以跨多个数据库服务器，甚至跨多个数据中心。分片通常基于某种策略（如哈希、范围等）将数据分散到不同的分片中。</p><p>MySQL5以后支持分区，但是不支持二级分区，并且单机MySQL的性能远远不如Oracle，所以分区并不能解决性能问题。</p><p>分片就是分库+分表，属于水平切分，将表中数据按照某种规则放到多个库中，既分表又分库。</p><p>分片关注于跨多个数据库服务器的水平扩展和数据隔离</p><blockquote><ul class="lvl-1"><li class="lvl-2"><p><strong>水平扩展</strong>：通过增加数据库服务器数量，实现水平扩展，提高系统的整体性能。</p></li><li class="lvl-2"><p><strong>数据隔离</strong>：不同的分片可以部署在不同的地理位置，实现数据的物理隔离和容灾备份。</p></li><li class="lvl-2"><p><strong>降低单点故障风险</strong>：由于数据被分散到多个分片中，单个分片的故障不会影响整个系统的运行。</p></li></ul></blockquote><p>常见的分片策略有：</p><blockquote><ul class="lvl-1"><li class="lvl-2"><p><strong>范围分片</strong>：根据数据的某个字段（如时间戳、用户ID等）的值范围将数据分散到不同的分片中。这种方法适用于连续增长的数据，但可能导致数据倾斜。</p></li><li class="lvl-2"><p><strong>哈希分片</strong>：使用哈希函数将数据分散到不同的分片中。这种方法可以确保数据的均匀分布，但可能导致跨分片查询的性能问题。</p></li><li class="lvl-2"><p><strong>目录分片</strong>：使用一个额外的目录表来记录数据在不同分片中的分布情况。这种方法可以提供更灵活的分片策略，但增加了查询的复杂度。</p></li></ul></blockquote><p>在实现分片时，可以使用中间件（如MyCAT、Sharding-JDBC等）或自定义代码来管理数据的路由和分片。中间件通常提供了丰富的分片策略和配置选项，可以方便地实现分片功能。</p><h3 id="分区（单库-水平分表）">分区（单库-水平分表）</h3><p>MySQL分区表是将一个表物理上分割成多个较小的、更易于管理的片段，这些片段称为分区。</p><p>分区主要关注于单个数据库服务器的性能提升和管理效率</p><p>MySQL支持多种分区类型，如RANGE、LIST、HASH、KEY等。</p><blockquote><ul class="lvl-1"><li class="lvl-2"><p><strong>性能提升</strong>：通过减少I/O操作、提高查询缓存效率等方式，提升查询性能。</p></li><li class="lvl-2"><p><strong>管理方便</strong>：可以单独对分区进行备份、恢复、删除等操作，提高管理效率。</p></li><li class="lvl-2"><p><strong>减少锁争用</strong>：在并发查询时，不同的分区可以并行处理，减少锁争用。</p></li></ul></blockquote><p>应用</p><blockquote><ul class="lvl-1"><li class="lvl-2"><p><strong>日志表</strong>：如MySQL的慢查询日志表，可以按时间范围进行分区，便于管理和查询。</p></li><li class="lvl-2"><p><strong>历史数据表</strong>：对于按时间存储的历史数据，可以使用RANGE分区，将不同时间段的数据存储在不同的分区中。</p></li><li class="lvl-2"><p><strong>大数据表</strong>：对于数据量非常大的表，可以使用HASH或KEY分区，将数据分散到多个分区中，提高查询性能。</p></li></ul></blockquote><h2 id="分库分表的挑战">分库分表的挑战</h2><p>引入分库分表之后，会给系统带来什么挑战呢？</p><ul class="lvl-0"><li class="lvl-2"><p><strong>分页查询</strong>：数据分布到多个表中，导致分页查询受限，需要扫描各个分表再聚合结果。还涉及到深度分页问题。</p></li><li class="lvl-2"><p><strong>join 操作</strong>：同一个数据库中的表分布在了不同的数据库中，导致无法使用 join 操作。这样就导致我们需要手动进行数据的封装，比如你在一个数据库中查询到一个数据之后，再根据这个数据去另外一个数据库中找对应的数据。</p><blockquote><p>建议尽量不使用 join 操作。因为效率低，并且会对分库分表造成影响。对于需要用到 join 操作的地方，可以采用多次查询业务层进行数据组装的方法。不过，这种方法需要考虑业务上多次查询的事务性的容忍度。</p></blockquote></li><li class="lvl-2"><p><strong>事务问题</strong>：同一个数据库中的表分布在了不同的库中，操作涉及到多个数据库，数据库自带的事务就无法满足我们的要求了。这个时候，我们就需要引入分布式事务了。</p></li><li class="lvl-2"><p><strong>分布式 ID</strong>：分库之后， 数据遍布在不同服务器上的数据库，数据库的自增主键已经没办法满足生成的主键唯一了。</p></li><li class="lvl-2"><p><strong>跨库聚合查询</strong>：分库分表会导致常规聚合查询操作，如 group by，order by 等变得异常复杂。这是因为这些操作需要在多个分片上进行数据汇总和排序。为了实现这些操作，需要编写复杂的业务代码，或者使用中间件来协调分片间的通信和数据传输。这样会增加开发和维护的成本，以及影响查询的性能和可扩展性。</p></li></ul><h2 id="分库分表的建议">分库分表的建议</h2><p>遇到下面几种场景可以考虑分库分表：</p><blockquote><ul class="lvl-1"><li class="lvl-2"><p>单表的数据达到千万级别以上，数据库读写速度比较缓慢。</p></li><li class="lvl-2"><p>数据库中的数据占用的空间越来越大，备份时间越来越长。</p></li><li class="lvl-2"><p>应用的并发量太大（应该优先考虑其他性能优化方法，而非分库分表）。</p></li></ul></blockquote><p>不过，分库分表的成本太高，如非必要尽量不要采用。而且，并不一定是单表千万级数据量就要分表。</p><h3 id="分页方案选型建议">分页方案选型建议</h3><table><thead><tr><th>业务场景</th><th>推荐方案</th><th>说明</th></tr></thead><tbody><tr><td>移动端下拉加载</td><td>游标分页 or 禁止跳页</td><td>性能最佳，用户体验好</td></tr><tr><td>后台管理系统（需跳页）</td><td>二次查询法 + 限制最大页码</td><td>平衡功能与性能</td></tr><tr><td>企业级复杂分页</td><td>ShardingSphere / MyCat</td><td>透明化，减少开发成本</td></tr><tr><td>海量数据实时排序</td><td>优先队列流式合并</td><td>适合推荐、排行榜场景</td></tr><tr><td>数据分析/报表</td><td>异步导出 or 预计算</td><td>避免在线分页，改用离线处理</td></tr></tbody></table><blockquote><ol><li class="lvl-3"><p><strong>避免深分页</strong>：前端限制最大页码（如 ≤ 100页），或引导用户用筛选条件缩小范围。</p></li><li class="lvl-3"><p><strong>索引优化</strong>：确保排序字段、分片键有联合索引。</p></li><li class="lvl-3"><p><strong>缓存分页结果</strong>：对前几页数据缓存到 Redis（尤其热门查询）。</p></li><li class="lvl-3"><p><strong>异步预加载</strong>：用户浏览第1页时，后台预加载第2页。</p></li><li class="lvl-3"><p><strong>数据归档</strong>：历史数据迁移到冷库，减少分片数据量。</p></li></ol></blockquote><h2 id="分库分表的解决方案">分库分表的解决方案</h2><p>常见分页查询方案对比</p><table><thead><tr><th>方案</th><th>适用场景</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>1. 全局有序ID + 游标分页</td><td>主键/时间戳有序</td><td>性能好、无跳页</td><td>不支持跳页、需有序字段</td></tr><tr><td>2. 二次查询法（排序归并）</td><td>任意排序字段</td><td>支持任意排序、跳页</td><td>性能较差、内存压力大</td></tr><tr><td>3. 禁止跳页 + 页码缓存</td><td>App/小程序下拉场景</td><td>用户体验好、性能高</td><td>不支持传统页码跳转</td></tr><tr><td>4. 全局汇总中间件</td><td>复杂聚合分页</td><td>功能强大</td><td>架构复杂、成本高</td></tr><tr><td>5. 并行查询 + 优先队列</td><td>大数据量排序分页</td><td>实时性好</td><td>实现复杂、资源消耗大</td></tr></tbody></table><h3 id="方案1：游标分页（推荐）">方案1：游标分页（推荐）</h3><p>适用于：主键自增、时间戳、全局唯一有序字段（如订单号、创建时间）</p><blockquote><ul class="lvl-1"><li class="lvl-2"><p>不使用 <code>OFFSET</code>，而是记录上一页最后一条记录的排序值（如 <code>id &gt; 1000</code>）。</p></li><li class="lvl-2"><p>下一页从该值之后开始查，每页固定大小。</p></li></ul></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 第一页</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> order_shard_01 </span><br><span class="line"><span class="keyword">WHERE</span> create_time <span class="operator">&gt;=</span> <span class="string">&#x27;2024-01-01&#x27;</span> </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> create_time <span class="keyword">DESC</span>, id <span class="keyword">DESC</span> </span><br><span class="line">LIMIT <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 假设最后一条记录是 create_time=&#x27;2024-06-01 10:00:00&#x27;, id=5000</span></span><br><span class="line"><span class="comment">-- 第二页</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> order_shard_01 </span><br><span class="line"><span class="keyword">WHERE</span> (create_time <span class="operator">&lt;</span> <span class="string">&#x27;2024-06-01 10:00:00&#x27;</span>) </span><br><span class="line">   <span class="keyword">OR</span> (create_time <span class="operator">=</span> <span class="string">&#x27;2024-06-01 10:00:00&#x27;</span> <span class="keyword">AND</span> id <span class="operator">&lt;</span> <span class="number">5000</span>)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> create_time <span class="keyword">DESC</span>, id <span class="keyword">DESC</span> </span><br><span class="line">LIMIT <span class="number">20</span>;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 请求参数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PageRequest</span> &#123;</span><br><span class="line">    Long lastId;      <span class="comment">// 上一页最后一条ID（游标）</span></span><br><span class="line">    <span class="type">Integer</span> <span class="variable">pageSize</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 响应</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PageResult</span> &#123;</span><br><span class="line">    List&lt;Order&gt; data;</span><br><span class="line">    Long nextCursor;  <span class="comment">// 下一页游标（最后一条ID）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 服务层</span></span><br><span class="line"><span class="keyword">public</span> PageResult <span class="title function_">listOrders</span><span class="params">(PageRequest req)</span> &#123;</span><br><span class="line">    List&lt;Order&gt; allResults = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 并行查询所有分片</span></span><br><span class="line">    <span class="keyword">for</span> (String shardTable : getShardTables()) &#123;</span><br><span class="line">        List&lt;Order&gt; shardData = jdbcTemplate.query(</span><br><span class="line">            <span class="string">&quot;SELECT * FROM &quot;</span> + shardTable + </span><br><span class="line">            <span class="string">&quot; WHERE id &lt; ? ORDER BY id DESC LIMIT ?&quot;</span>,</span><br><span class="line">            req.lastId == <span class="literal">null</span> ? Long.MAX_VALUE : req.lastId,</span><br><span class="line">            req.pageSize + <span class="number">1</span>,  <span class="comment">// 多查1条用于判断是否有下一页</span></span><br><span class="line">            orderRowMapper</span><br><span class="line">        );</span><br><span class="line">        allResults.addAll(shardData);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 全局排序</span></span><br><span class="line">    allResults.sort((a, b) -&gt; Long.compare(b.getId(), a.getId()));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 截取分页</span></span><br><span class="line">    List&lt;Order&gt; pageData = allResults.stream()</span><br><span class="line">        .limit(req.pageSize)</span><br><span class="line">        .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算下一页游标</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">nextCursor</span> <span class="operator">=</span> pageData.size() &gt;= req.pageSize ? </span><br><span class="line">                      pageData.get(pageData.size() - <span class="number">1</span>).getId() : <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PageResult</span>(pageData, nextCursor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优点</strong>：</p><blockquote><ul class="lvl-1"><li class="lvl-2"><p>性能极佳（走索引，无 OFFSET）</p></li><li class="lvl-2"><p>天然避免数据重复/遗漏</p></li><li class="lvl-2"><p>支持无限下拉（App/小程序常用）</p></li></ul></blockquote><p><strong>缺点</strong>：</p><blockquote><ul class="lvl-1"><li class="lvl-2"><p>不支持“跳到第100页”</p></li><li class="lvl-2"><p>要求排序字段全局唯一或组合唯一（避免边界重复，如 <code>create_time + id</code>），确保唯一性。</p></li><li class="lvl-2"><p>要求客户端传入上一页最后一条的完整排序字段值。</p></li></ul></blockquote><h3 id="方案2：二次查询法（排序归并分页）">方案2：二次查询法（排序归并分页）</h3><p>适用于：必须支持“跳页”、排序字段无序或非全局唯一</p><blockquote><ol><li class="lvl-3"><p>第一轮：每个分片查“可能相关”的数据（带冗余）</p><ul class="lvl-3"><li class="lvl-5">比如要第3页（每页10条），则每个分片查前 30+10=40 条（offset=0, limit=40）</li></ul></li><li class="lvl-3"><p>第二轮：内存中合并排序，取全局第21~30条</p></li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Step 1: 并行查询每个分片的前 N 条（N = offset + limit）</span></span><br><span class="line">List&lt;Future&lt;List&lt;Record&gt;&gt;&gt; futures = shards.stream()</span><br><span class="line">    .map(shard -&gt; executor.submit(() -&gt; </span><br><span class="line">        query(<span class="string">&quot;SELECT * FROM &quot;</span> + shard + <span class="string">&quot; ORDER BY score DESC LIMIT &quot;</span> + (offset + limit))</span><br><span class="line">    )).collect(toList());</span><br><span class="line"></span><br><span class="line"><span class="comment">// Step 2: 合并所有结果，全局排序</span></span><br><span class="line">List&lt;Record&gt; allRecords = mergeAndSort(futures.get());</span><br><span class="line"></span><br><span class="line"><span class="comment">// Step 3: 截取最终分页</span></span><br><span class="line"><span class="keyword">return</span> allRecords.subList(offset, offset + limit);</span><br></pre></td></tr></table></figure><p><strong>优点</strong>：</p><blockquote><ul class="lvl-1"><li class="lvl-2"><p>支持任意跳页</p></li><li class="lvl-2"><p>适用任意排序字段</p></li></ul></blockquote><p><strong>缺点</strong>：</p><blockquote><ul class="lvl-1"><li class="lvl-2"><p>性能随页码增大急剧下降（深分页问题），可设置最大可跳页数（如最多100页），避免恶意深分页。</p></li><li class="lvl-2"><p>内存压力大（需缓存 offset+limit 条记录），使用缓存中间页结果（如 Redis 缓存第1~10页数据）。</p></li><li class="lvl-2"><p>数据量大时可能 OOM</p></li></ul></blockquote><h3 id="方案3：禁止跳页-页码缓存（App常用）">方案3：禁止跳页 + 页码缓存（App常用）</h3><p>适用于：移动端、信息流、下拉加载场景</p><blockquote><ul class="lvl-1"><li class="lvl-2"><p>前端不提供“跳页”按钮，只提供“加载更多”。</p></li><li class="lvl-2"><p>后端使用游标分页（方案1）。</p></li><li class="lvl-2"><p>可选：缓存前N页数据到 Redis，加速重复访问。</p></li></ul></blockquote><p><strong>优点</strong>：</p><blockquote><ul class="lvl-1"><li class="lvl-2"><p>性能最优</p></li><li class="lvl-2"><p>用户体验流畅</p></li><li class="lvl-2"><p>实现简单</p></li></ul></blockquote><p><strong>缺点</strong>：不满足传统“跳页”需求（如后台管理系统）</p><h3 id="方案4：全局汇总中间件（企业级方案）">方案4：全局汇总中间件（企业级方案）</h3><p>适用于：复杂业务、需透明分页、不想自己实现逻辑 。如ShardingSphere、MyCat</p><blockquote><ul class="lvl-1"><li class="lvl-2"><p>中间件自动路由查询到各分片。</p></li><li class="lvl-2"><p>自动合并、排序、分页（通常采用“二次查询法”）。</p></li><li class="lvl-2"><p>对应用透明，SQL 仍写 <code>LIMIT 100, 10</code>。</p></li></ul></blockquote><p><strong>优点</strong>：</p><blockquote><ul class="lvl-1"><li class="lvl-2"><p>开发无感知，SQL 兼容性好</p></li><li class="lvl-2"><p>支持复杂聚合、排序、分页</p></li></ul></blockquote><p><strong>缺点</strong>：</p><blockquote><ul class="lvl-1"><li class="lvl-2"><p>中间件有性能开销</p></li><li class="lvl-2"><p>深分页仍慢</p></li><li class="lvl-2"><p>需维护中间件集群</p></li></ul></blockquote><p>ShardingSphere 示例配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">rules:</span></span><br><span class="line"><span class="bullet">-</span> <span class="type">!SHARDING</span></span><br><span class="line">  <span class="attr">tables:</span></span><br><span class="line">    <span class="attr">t_order:</span></span><br><span class="line">      <span class="attr">actualDataNodes:</span> <span class="string">ds_$&#123;0..1&#125;.t_order_$&#123;0..3&#125;</span></span><br><span class="line">      <span class="attr">tableStrategy:</span></span><br><span class="line">        <span class="attr">standard:</span></span><br><span class="line">          <span class="attr">shardingColumn:</span> <span class="string">user_id</span></span><br><span class="line">          <span class="attr">shardingAlgorithmName:</span> <span class="string">table_inline</span></span><br><span class="line">  <span class="attr">shardingAlgorithms:</span></span><br><span class="line">    <span class="attr">table_inline:</span></span><br><span class="line">      <span class="attr">type:</span> <span class="string">INLINE</span></span><br><span class="line">      <span class="attr">props:</span></span><br><span class="line">        <span class="attr">algorithm-expression:</span> <span class="string">t_order_$&#123;user_id</span> <span class="string">%</span> <span class="number">4</span><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 应用层 SQL：</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t_order <span class="keyword">ORDER</span> <span class="keyword">BY</span> create_time <span class="keyword">DESC</span> LIMIT <span class="number">100</span>, <span class="number">10</span>;</span><br><span class="line"><span class="comment">-- ShardingSphere 自动分发+归并</span></span><br></pre></td></tr></table></figure><h3 id="方案5：并行查询-优先队列（高性能方案）">方案5：并行查询 + 优先队列（高性能方案）</h3><p>通过大数据量实时分页，适用于：海量数据、实时排序分页（如推荐系统、排行榜）</p><blockquote><ul class="lvl-1"><li class="lvl-2"><p>每个分片返回一个“排序迭代器”。</p></li><li class="lvl-2"><p>使用堆（优先队列）动态合并各分片TopK数据。</p></li><li class="lvl-2"><p>类似“外排序”思想，内存占用可控。</p></li></ul></blockquote><p><strong>优点</strong>：</p><blockquote><ul class="lvl-1"><li class="lvl-2"><p>内存占用稳定（只缓存 heap.size = limit）</p></li><li class="lvl-2"><p>支持深分页（性能不随 offset 增大而剧降）</p></li><li class="lvl-2"><p>实时性好</p></li></ul></blockquote><p><strong>缺点</strong>：</p><blockquote><ul class="lvl-1"><li class="lvl-2"><p>实现复杂（需自研或使用高级中间件）</p></li><li class="lvl-2"><p>对数据库连接数压力大</p></li></ul></blockquote><p><strong>开源参考</strong>：</p><blockquote><ul class="lvl-1"><li class="lvl-2"><p>Apache ShardingSphere 的 <code>StreamMerge</code> 模式</p></li><li class="lvl-2"><p>Elasticsearch 的 <code>search_after</code></p></li></ul></blockquote><h2 id="分库分表查询案例（订单）">分库分表查询案例（订单）</h2><p>案例：订单表根据 userId 分表（userId % 1024）后</p><h3 id="如何根据-orderId-快速查询订单信息？">如何根据 orderId 快速查询订单信息？</h3><ul class="lvl-0"><li class="lvl-2"><p>方案一：扫描所有分表（效率最差）</p></li><li class="lvl-2"><p>方案二：建立中间路由表（数据冗余）</p><p>维护 分片 和 orderId 的映射，首先查询该表来确认分表，再查询数据（需要两次查询，且数据冗余，可能出现不一致的情况）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 伪代码</span></span><br><span class="line"><span class="type">Long</span> <span class="variable">orderId</span> <span class="operator">=</span> <span class="number">10086L</span>;</span><br><span class="line"><span class="type">Route</span> <span class="variable">route</span> <span class="operator">=</span> routeMapper.selectByOrderId(orderId); <span class="comment">// 查路由表</span></span><br><span class="line"><span class="type">String</span> <span class="variable">targetTable</span> <span class="operator">=</span> <span class="string">&quot;order_&quot;</span> + route.getTableIndex();</span><br><span class="line"><span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> orderMapper.selectByIdFromTable(orderId, targetTable); <span class="comment">// 精准查询</span></span><br></pre></td></tr></table></figure><blockquote><ul class="lvl-3"><li class="lvl-2"><p>多一次查询（可缓存优化）</p></li><li class="lvl-2"><p>路由表需与订单表事务一致（写入订单时同时写路由）</p></li></ul></blockquote></li><li class="lvl-2"><p><strong>方案三</strong>（推荐）：重新维护 orderId，跟 userId 关联</p><p>最后4位数据拼接 userId 的二进制 前四位，然后可以对 orderId % 1024 来确定分表（需要保证分表数量为 2的次方个，且重写雪花算法，向其借四位）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1bit | 41bit时间戳 | 10bit机器/分片ID | 12bit序列号</span></span><br><span class="line"><span class="keyword">public</span> ShardInfo <span class="title function_">parseFromSnowflake</span><span class="params">(<span class="type">long</span> orderId)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">shardBits</span> <span class="operator">=</span> (orderId &gt;&gt; <span class="number">12</span>) &amp; <span class="number">0x3FF</span>; <span class="comment">// 取中间10位</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">dbIndex</span> <span class="operator">=</span> (<span class="type">int</span>) (shardBits / <span class="number">16</span>);     <span class="comment">// 假设每库16表</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">tableIndex</span> <span class="operator">=</span> (<span class="type">int</span>) (shardBits % <span class="number">16</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ShardInfo</span>(dbIndex, tableIndex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul class="lvl-3"><li class="lvl-2"><p>无需路由表，直接计算</p></li><li class="lvl-2"><p>ID全局唯一、趋势递增、包含分片信息</p></li></ul></blockquote></li><li class="lvl-2"><p>方案四（推荐）：让 orderId 本身包含分片信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DD20250405_03_000000001</span><br><span class="line">  │    │    │    └── 自增序列（保证唯一）</span><br><span class="line">  │    │    └────── 分库分表标识（如 03 表示 db0.table3）</span><br><span class="line">  │    └─────────── 日期（可选，用于归档）</span><br><span class="line">  └────────────── 业务前缀（如 DD=订单）</span><br><span class="line"></span><br><span class="line">或更简洁：</span><br><span class="line">2025040503000000001</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderIdParser</span> &#123;</span><br><span class="line">    <span class="comment">// orderId = &quot;DD20250405_03_000000001&quot;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ShardInfo <span class="title function_">parse</span><span class="params">(String orderId)</span> &#123;</span><br><span class="line">        String[] parts = orderId.split(<span class="string">&quot;_&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">shardPart</span> <span class="operator">=</span> parts[<span class="number">1</span>]; <span class="comment">// &quot;03&quot;</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">dbIndex</span> <span class="operator">=</span> Integer.parseInt(shardPart) / <span class="number">4</span>;  <span class="comment">// 假设每库4表</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">tableIndex</span> <span class="operator">=</span> Integer.parseInt(shardPart) % <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ShardInfo</span>(dbIndex, tableIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li class="lvl-2"><p>方案五：使用分库分表中间件（推荐）</p><p>使用 ShardingSphere，配置分片规则后，应用直接写 SQL，中间件自动路由：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ShardingSphere 根据 order_id 值自动计算分片，只查询目标表。</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line"><span class="bullet">-</span> <span class="type">!SHARDING</span></span><br><span class="line">  <span class="attr">tables:</span></span><br><span class="line">    <span class="attr">t_order:</span></span><br><span class="line">      <span class="attr">actualDataNodes:</span> <span class="string">ds_$&#123;0..1&#125;.t_order_$&#123;0..3&#125;</span></span><br><span class="line">      <span class="attr">databaseStrategy:</span></span><br><span class="line">        <span class="attr">standard:</span></span><br><span class="line">          <span class="attr">shardingColumn:</span> <span class="string">order_id</span></span><br><span class="line">          <span class="attr">shardingAlgorithmName:</span> <span class="string">db_inline</span></span><br><span class="line">      <span class="attr">tableStrategy:</span></span><br><span class="line">        <span class="attr">standard:</span></span><br><span class="line">          <span class="attr">shardingColumn:</span> <span class="string">order_id</span></span><br><span class="line">          <span class="attr">shardingAlgorithmName:</span> <span class="string">table_inline</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">shardingAlgorithms:</span></span><br><span class="line">    <span class="attr">db_inline:</span></span><br><span class="line">      <span class="attr">type:</span> <span class="string">INLINE</span></span><br><span class="line">      <span class="attr">props:</span></span><br><span class="line">        <span class="attr">algorithm-expression:</span> <span class="string">ds_$&#123;order_id.substring(10,11).toInteger()</span> <span class="string">/</span> <span class="number">2</span><span class="string">&#125;</span> <span class="comment"># 示例：从第10位取1位算库</span></span><br><span class="line">    <span class="attr">table_inline:</span></span><br><span class="line">      <span class="attr">type:</span> <span class="string">INLINE</span></span><br><span class="line">      <span class="attr">props:</span></span><br><span class="line">        <span class="attr">algorithm-expression:</span> <span class="string">t_order_$&#123;order_id.substring(10,11).toInteger()</span> <span class="string">%</span> <span class="number">4</span><span class="string">&#125;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="如何分页查询所有订单？"><strong>如何分页查询所有订单</strong>？</h3><p>根据条件扫描所有分表中前面的所有数据，再代码过滤聚合（需要查大量无效数据，且性能低，涉及深度分页）</p><ul class="lvl-0"><li class="lvl-2"><p>全局表查询：维护一个涉及查询参数的全局表，数据列少（包含分表信息），查询后再二次检索原数据。</p></li><li class="lvl-2"><p>最值限制过滤（可行）：根据上页最大值做过滤，如：ID或日期，扫描每个分表范围内数据，当客户端拉取不到任何数据的时候，即可停止分页。缺点是不能跳页查询，只能倒序排序。</p></li><li class="lvl-2"><p>大数据集成法（推荐）：ES或其它大数据组件。缺点是引入新的组件，会涉及数据同步的挑战。</p></li><li class="lvl-2"><p>三方分库分表组件（可行）：自动完成分表分页查询，只需要做好配置（如：ShardingSphere，其原理也是拆分查询 ）</p></li><li class="lvl-2"><p>分布式数据库（推荐）：既有关系数据库的优点又可无限扩表，支持数据库间无障碍迁移，如国产TiDB。</p></li><li class="lvl-2"><p><strong>按日期的二次查询法</strong>（常用）：通过两次查询来确保分页查询的精度和性能，特别适用于数据量大且需要精确分页的场景。</p><blockquote><p>二次查询法的基本思想是：将全局分页查询拆分为多个子查询，并通过两次查询来获取所需的数据。</p><ul class="lvl-3"><li class="lvl-2"><strong>第一次查询</strong>：将全局分页查询改写为多个子查询，每个子查询在各个分库中执行。例如，假设有三个分库，查询第200页的数据，每页5条记录，原始SQL为：<code>SELECT * FROM T ORDER BY time OFFSET 1000 LIMIT 5;</code></li><li class="lvl-2"><strong>找到最小时间戳</strong>：比较所有分库返回结果集中的最小时间戳，作为二次查询的起点。例如，假设三个分库返回的最小时间戳分别为1487501123、1487501133和1487501143，则最小时间戳为1487501123。</li><li class="lvl-2"><strong>第二次查询</strong>：根据最小时间戳和各分库返回结果集的最大时间戳，构造新的查询条件。例如，第一个分库返回的最大时间戳为1487501523，则新的查询条件为：<code>SELECT * FROM T WHERE time BETWEEN 1487501123 AND 1487501523;</code></li><li class="lvl-2"><strong>合并结果集</strong>：将所有分库的查询结果合并，并根据全局偏移量计算最终的分页结果。</li></ul><p><strong>优点</strong>：</p><ul class="lvl-3"><li class="lvl-2"><p><strong>精确分页</strong>：能够精确返回所需的分页数据。</p></li><li class="lvl-2"><p><strong>高性能</strong>：每次查询的数据量较小，不会随着翻页增加而显著增加。</p></li></ul><p><strong>缺点</strong>：</p><ul class="lvl-3"><li class="lvl-2"><p><strong>两次查询</strong>：需要进行两次数据库查询，增加了查询的复杂度。</p></li><li class="lvl-2"><p><strong>适用场景有限</strong>：适用于数据量大且需要精确分页的场景，不适用于所有情况</p></li></ul></blockquote></li></ul>]]></content>
    
    
    <summary type="html">分库、分表、分片、分区的区别，以及如何实现跨表的分页查询</summary>
    
    
    
    <category term="DB" scheme="https://pengline.github.io/categories/DB/"/>
    
    <category term="分库分表" scheme="https://pengline.github.io/categories/DB/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/"/>
    
    
    <category term="分库分表" scheme="https://pengline.github.io/tags/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/"/>
    
    <category term="分布式数据库" scheme="https://pengline.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="二次查询法" scheme="https://pengline.github.io/tags/%E4%BA%8C%E6%AC%A1%E6%9F%A5%E8%AF%A2%E6%B3%95/"/>
    
    <category term="TiDB" scheme="https://pengline.github.io/tags/TiDB/"/>
    
    <category term="ShardingSphere" scheme="https://pengline.github.io/tags/ShardingSphere/"/>
    
    <category term="跨表分页查询" scheme="https://pengline.github.io/tags/%E8%B7%A8%E8%A1%A8%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2/"/>
    
  </entry>
  
  <entry>
    <title>海量数据的深度分页查询解决方案</title>
    <link href="https://pengline.github.io/2025/09/05/b35492bf2a96482e86fe1e77b2bc7812/"/>
    <id>https://pengline.github.io/2025/09/05/b35492bf2a96482e86fe1e77b2bc7812/</id>
    <published>2025-09-05T07:58:48.639Z</published>
    <updated>2025-09-06T12:37:35.202Z</updated>
    
    <content type="html"><![CDATA[<h2 id="深度分页的概念和场景">深度分页的概念和场景</h2><p><strong>深度分页</strong>指的是在数据库或搜索引擎中，当需要访问结果集中非常靠后的数据页时（例如第 1000 页，每页 10 条，即第 10000 条记录之后），系统性能会显著下降的现象。</p><p><strong>核心问题在于：</strong> 大多数数据库的实现方式并不是直接跳到第 N 页，而是需要先获取并跳过前 (N-1) * SIZE 条记录，这会导致巨大的资源消耗。</p><p>以MySQL的LIMIT偏移查询为例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 查询第 <span class="number">1000</span> 页的<span class="number">10</span>条数据</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> test <span class="keyword">ORDER</span> <span class="keyword">BY</span> created_at <span class="keyword">DESC</span> LIMIT <span class="number">10000</span>, <span class="number">10</span>;</span><br></pre></td></tr></table></figure><blockquote><ol><li class="lvl-3"><p>数据库需要先读取 <code>10000 + 10</code> 条记录的索引和数据（可能涉及回表）。</p></li><li class="lvl-3"><p>然后丢弃前 10000 条记录。</p></li><li class="lvl-3"><p>最后返回剩下的 10 条。</p></li></ol><p><code>OFFSET</code> 越大，需要读取和丢弃的数据就越多，计算和I/O成本就越高，性能自然急剧下降。</p></blockquote><h2 id="深度分页常用解决方案">深度分页常用解决方案</h2><p>以Mysql 为例说明</p><table><thead><tr><th style="text-align:left">方案</th><th style="text-align:left">原理</th><th style="text-align:left">优点</th><th style="text-align:left">缺点</th><th style="text-align:left">适用场景</th></tr></thead><tbody><tr><td style="text-align:left"><strong>游标分页</strong></td><td style="text-align:left">记录上一页末尾的位置作为起点</td><td style="text-align:left"><strong>性能最好</strong>，数据一致</td><td style="text-align:left">无法跳页</td><td style="text-align:left"><strong>无限滚动、流式数据</strong></td></tr><tr><td style="text-align:left"><strong>子查询</strong></td><td style="text-align:left">覆盖索引的优化，不需要二次查询</td><td style="text-align:left">简单高效</td><td style="text-align:left">连表查询，不稳定</td><td style="text-align:left">数据量少的简单可跳页查询</td></tr><tr><td style="text-align:left"><strong>覆盖索引</strong></td><td style="text-align:left">通过索引避免回表，减少I/O</td><td style="text-align:left">比纯<code>LIMIT</code>快</td><td style="text-align:left">优化有限，需两次查询</td><td style="text-align:left">查询数据少的简单分页</td></tr><tr><td style="text-align:left"><strong>限制深度</strong></td><td style="text-align:left">业务上不允许访问太深的页</td><td style="text-align:left">简单有效</td><td style="text-align:left">功能受限</td><td style="text-align:left">搜索引擎、后台管理系统</td></tr><tr><td style="text-align:left"><strong>ES <code>search_after</code></strong></td><td style="text-align:left">类似游标分页</td><td style="text-align:left">专业引擎原生支持</td><td style="text-align:left">引擎特定</td><td style="text-align:left">Elasticsearch/Solr</td></tr></tbody></table><blockquote><p>对于新项目或需要高性能的场景，<strong>强烈推荐使用游标分页</strong>。虽然牺牲了直接跳转页码的功能，但换来了稳定且高效的性能，非常适合现代应用（如手机APP）的交互方式。如果必须支持页码跳转，可以考虑将<strong>游标分页与限制最大分页深度</strong>结合使用。</p></blockquote><h3 id="游标分页（推荐）">游标分页（推荐）</h3><p>游标分页（Cursor-based Pagination），也叫“键集分页”，是解决深度分页最有效的方法。它不记录页码，而是记录上一页最后一条记录的位置，并以此为起点获取下一页。</p><p>比如数据根据ID倒序排列，点击下一页时，携带上一页中最小的ID，作为下一页最大值的过滤值。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span> user_order </span><br><span class="line"><span class="keyword">WHERE</span> id <span class="operator">&lt;</span> #&#123;minId&#125; <span class="keyword">AND</span> create_time<span class="operator">&gt;</span><span class="string">&#x27;2020-8-5 00:00:00&#x27;</span> </span><br><span class="line">    <span class="keyword">ORDER</span> <span class="keyword">BY</span> id LIMIT <span class="number">10</span>;</span><br></pre></td></tr></table></figure><blockquote><p>minId就是上一页中的最小主键Id。所以采用此方式的前提：</p><ul class="lvl-1"><li class="lvl-2">主键必须自增，不能是UUID。并且前端还需要传递上一页的最小Id</li><li class="lvl-2">不支持随机跳页，只能上下顺序翻页。</li></ul></blockquote><p><strong>优点：</strong></p><ul class="lvl-0"><li class="lvl-2"><p><strong>性能极佳</strong>：无论翻到第几页，查询速度都一样快，因为 <code>WHERE id &lt; 1000</code> 可以利用索引快速定位，无需扫描和跳过之前的记录。</p></li><li class="lvl-2"><p><strong>数据一致性</strong>：适合实时性高的数据流（如社交媒体动态），在分页过程中即使有新增或删除数据，也不会出现重复或丢失记录的问题（传统 LIMIT 分页可能会）。</p></li></ul><p><strong>缺点：</strong></p><ul class="lvl-0"><li class="lvl-2"><p><strong>无法直接跳转到指定页码</strong>：用户只能“上一页”或“下一页”地浏览，不能直接跳到第 100 页。</p></li><li class="lvl-2"><p><strong>需要客户端配合</strong>：客户端需要维护 <code>cursor</code> 状态。</p></li></ul><p><strong>适用场景：</strong> 无限滚动（Infinite Scroll）的列表、新闻流、时间线等。</p><h3 id="直接覆盖索引（可用）">直接覆盖索引（可用）</h3><p>确保分页查询的数据都包含在索引里，这样只需要查询索引即可，而无需回表，从而减少磁盘 I/O。</p><blockquote><p>除非要查询的数据量很少，且都符合建立索引的条件下可以使用。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id, order_id, create_time <span class="keyword">FROM</span> user_order </span><br><span class="line"><span class="keyword">WHERE</span> create_time<span class="operator">&gt;</span><span class="string">&#x27;2020-8-5 00:00:00&#x27;</span> </span><br><span class="line">    <span class="keyword">ORDER</span> <span class="keyword">BY</span> id LIMIT <span class="number">10000</span>, <span class="number">10</span>;</span><br></pre></td></tr></table></figure></blockquote><p><strong>优点：</strong></p><ul class="lvl-0"><li class="lvl-2"><p>在一定程度上减轻了深度分页的压力。</p></li></ul><p><strong>缺点：</strong></p><ul class="lvl-0"><li class="lvl-2"><p>优化有限，<code>OFFSET</code> 非常大时，索引扫描范围依然很大。</p></li><li class="lvl-2"><p>只能查询有限的数据列，且需要创建大量索引，占据磁盘。</p></li></ul><h3 id="间接覆盖索引（可用）">间接覆盖索引（可用）</h3><p>让查询只需要扫描索引，而无需回表，从而减少磁盘 I/O。</p><p>通过以下两步查询完成：</p><ol><li class="lvl-3"><p>先从覆盖索引中获取目标记录的主键</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id <span class="keyword">FROM</span> user_order </span><br><span class="line"><span class="keyword">WHERE</span> create_time<span class="operator">&gt;</span><span class="string">&#x27;2020-8-5 00:00:00&#x27;</span> </span><br><span class="line">    <span class="keyword">ORDER</span> <span class="keyword">BY</span> id LIMIT <span class="number">10000</span>, <span class="number">10</span>;</span><br></pre></td></tr></table></figure><blockquote><p>假设 <code>(create_time, id)</code> 是一个联合索引，这个查询可以完全在索引上完成，速度较快</p></blockquote></li><li class="lvl-3"><p>再根据这些主键ID，回表查询获取完整数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">    <span class="keyword">FROM</span> user_order </span><br><span class="line"><span class="keyword">WHERE</span> id <span class="keyword">IN</span> (<span class="number">10001</span>, <span class="number">10002</span>, ..., <span class="number">10020</span>); <span class="comment">-- 上一步得到的主键ID </span></span><br><span class="line">    <span class="keyword">ORDER</span> <span class="keyword">BY</span> id</span><br></pre></td></tr></table></figure></li></ol><p><strong>优点：</strong></p><ul class="lvl-0"><li class="lvl-2"><p>在一定程度上减轻了深度分页的压力。</p></li></ul><p><strong>缺点：</strong></p><ul class="lvl-0"><li class="lvl-2"><p>优化有限，<code>OFFSET</code> 非常大时，索引扫描范围依然很大。</p></li><li class="lvl-2"><p>仅适用于查询数据较少的情况，否则回表时会有大量ID集合数据需要过滤。</p></li><li class="lvl-2"><p>需要需要两次查询，占据IO 和 长事务问题。</p></li></ul><h3 id="子查询（常用）">子查询（常用）</h3><p>先根据条件分页查询出id（覆盖索引），再根据id连表查询出所需数据。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> </span><br><span class="line">    <span class="keyword">FROM</span> user_order d <span class="keyword">join</span> </span><br><span class="line">        (<span class="keyword">SELECT</span> id <span class="keyword">FROM</span> user_order <span class="keyword">WHERE</span> d.order_time<span class="operator">&gt;</span><span class="string">&#x27;2020-8-5 00:00:00&#x27;</span> </span><br><span class="line">         <span class="keyword">ORDER</span> <span class="keyword">BY</span> d.order_time LIMIT <span class="number">6</span>, <span class="number">100</span></span><br><span class="line">        ) dd </span><br><span class="line">    <span class="keyword">on</span> d.id <span class="operator">=</span> dd.id</span><br></pre></td></tr></table></figure><blockquote><p>查询ID直接是通过索引查询，速度较快</p><p>效果不如游标分页稳定。</p></blockquote><h3 id="限制分页深度">限制分页深度</h3><p>业务层面可以限制分页深度，这是一种“防患于未然”的策略，从产品设计上避免用户进入深度分页。</p><p><strong>实现方式：</strong></p><ul class="lvl-0"><li class="lvl-2"><p><strong>提供精确的搜索和筛选功能</strong>：让用户通过条件（如时间范围、标签、关键词）来缩小结果集，而不是无脑地翻页。</p></li><li class="lvl-2"><p><strong>限制最大可访问页码</strong>：例如，搜索引擎通常只允许查看前 100 页的结果。直接在前端或后端限制 <code>offset</code> 的最大值（如 <code>max_offset = 2000</code>）。</p></li></ul><p><strong>优点：</strong></p><ul class="lvl-0"><li class="lvl-2"><p>简单有效，从根本上避免了性能问题。</p></li><li class="lvl-2"><p>提升用户体验，用户通常也不愿意翻上百页。</p></li></ul><p><strong>缺点：</strong></p><ul class="lvl-0"><li class="lvl-2"><p>是一种限制，而非技术解决。</p></li></ul><h3 id="利用-Redis-扩展">利用 Redis 扩展</h3><p>利用其内存和对应的数据结构。</p><ul class="lvl-0"><li class="lvl-2"><p>使用 <strong>zset</strong> 结构，将数据的 id 作为 value，将数据的排序依据（比如时间、热度、评分等）作为 score，然后根据用户的分页请求，使用 <code>ZRANGE</code> 或者 <code>ZREVRANGE</code> 命令来获取指定范围的 value，再根据 value 获取具体数据。</p><blockquote><p>优点：减轻数据库压力，提高查询效率，保证数据一致性，动态地添加或删除数据，可以控制 zset 长度，防止一直增长。</p><p>缺点：需要维护额外的 zset 数据结构，可能占用更多的内存空间，并且需要注意数据同步和更新的问题。</p></blockquote></li><li class="lvl-2"><p>使用 <strong>hash</strong> 结构，将数据以 id 为 key 缓存，然后把数据 id 和排序存到 redis 的 zset 里；当查找数据时，先从 redis 里的 skip list 取出对应的分页数据，得到 id 列表；用 multi get 从 redis 上一次性把 id 列表里的所有数据都取出。</p><blockquote><p>优点：可以利用 hash 的高效存储和查询特性，减少内存开销，利用 zset 的排序和范围查询特性，提高分页效率。缺点：需要维护两个数据结构，可能增加复杂度，并且需要注意数据同步和更新的问题。</p></blockquote></li><li class="lvl-2"><p>使用 <strong>list</strong> 结构，将数据按照顺序存储到 list，根据用户分页请求，使用 <code>LINDEX</code> 或者 <code>LRANGE</code> 命令来获取指定范围的数据。</p><blockquote><p>优点：简单易实现，并且可以利用 list 的有序和可变特性，动态地添加或删除数据。缺点：需要扫描所有的数据，查询效率低下，并且不能支持多种排序方式。</p></blockquote></li></ul><h2 id="ES-深度分页解决方案">ES 深度分页解决方案</h2><p>ES 提供三种分页查询，其中以下两种为深度分页的解决方案：</p><table><thead><tr><th style="text-align:left">特性</th><th style="text-align:left"><code>search_after</code></th><th style="text-align:left"><code>scroll</code></th></tr></thead><tbody><tr><td style="text-align:left"><strong>设计目的</strong></td><td style="text-align:left"><strong>实时、高效的深度分页</strong></td><td style="text-align:left"><strong>大批量数据的离线检索和导出</strong></td></tr><tr><td style="text-align:left"><strong>数据一致性</strong></td><td style="text-align:left"><strong>实时当前索引状态</strong>（Point-in-Time 可增强）</td><td style="text-align:left"><strong>快照</strong>（Snapshot in Time）</td></tr><tr><td style="text-align:left"><strong>资源占用</strong></td><td style="text-align:left">低（无状态，每次查询独立）</td><td style="text-align:left">高（在上下文存活期间占用资源）</td></tr><tr><td style="text-align:left"><strong>生命周期</strong></td><td style="text-align:left">无状态，无需维护</td><td style="text-align:left">有状态，需要显式创建和销毁</td></tr><tr><td style="text-align:left"><strong>性能</strong></td><td style="text-align:left">每次查询开销类似常规搜索</td><td style="text-align:left">首次创建开销大，后续遍历非常快</td></tr><tr><td style="text-align:left"><strong>客户端</strong></td><td style="text-align:left">需要维护排序值（sort values）</td><td style="text-align:left">需要维护 <code>scroll_id</code></td></tr><tr><td style="text-align:left"><strong>返回结果</strong></td><td style="text-align:left">返回一页数据</td><td style="text-align:left">返回一批数据和一个新的 <code>scroll_id</code></td></tr></tbody></table><h3 id="from-size（浅分页）">from + size（浅分页）</h3><p><code>from + size</code> 分页方式的原理相对简单。当执行一个搜索查询并指定了 <code>from</code> 和 <code>size</code> 参数时，Elasticsearch 会进行以下步骤：</p><blockquote><ol><li class="lvl-3"><p><strong>分发查询</strong>：Elasticsearch会将查询请求分发到所有相关的分片上。</p></li><li class="lvl-3"><p><strong>查询分片</strong>：每个分片都会执行查询，并返回前 <code>from + size</code> 条符合条件的文档（但实际上只会用到最后的 <code>size</code> 条）。</p></li><li class="lvl-3"><p><strong>合并和排序</strong>：协调节点（通常是执行搜索的Elasticsearch节点）会收集所有分片返回的结果，将它们合并成一个全局的结果集，并根据查询中指定的排序规则进行排序。</p></li><li class="lvl-3"><p><strong>截断和返回</strong>：协调节点会从排序后的结果集中截取从 <code>from</code> 位置开始的 <code>size</code> 条记录，并将它们返回给客户端。</p></li></ol></blockquote><p>由于 <code>from + size</code> 需要合并和排序所有分片返回的结果，因此当 <code>from</code> 值很大时，这个过程可能变得非常慢，因为需要处理大量数据。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">GET /products/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;match&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;apple&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;from&quot;</span><span class="punctuation">:</span> <span class="number">9</span><span class="punctuation">,</span>  <span class="comment">// 注意，索引从0开始，所以第10条记录的索引是9</span></span><br><span class="line">    <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">10</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;sort&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span> <span class="attr">&quot;price&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;order&quot;</span><span class="punctuation">:</span> <span class="string">&quot;asc&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p><strong>存在不足</strong>：</p><blockquote><ul class="lvl-1"><li class="lvl-2"><p><strong>性能问题</strong>：当<code>from</code>值很大时，Elasticsearch需要遍历大量数据才能找到起始位置，然后返回<code>size</code>条记录。这会导致查询性能下降，尤其是在数据量很大的情况下。</p></li><li class="lvl-2"><p><strong>资源消耗</strong>：深度分页会消耗大量CPU和内存资源，对集群性能造成压力。</p></li></ul></blockquote><p>**使用场景：**适用于数据量不大、实时性要求高、不需要深度分页的场景。</p><h3 id="scroll（游标-非实时）">scroll（游标-非实时）</h3><p>一种基于游标的分页方式，它允许我们遍历大量数据而不需要在每次请求时重新计算整个搜索。</p><blockquote><p>对某次查询生成一个游标 scroll_id ， 后续的查询只需要根据这个游标去取数据，直到结果集中返回的 hits 字段为空，就表示遍历结束。scroll_id 的生成可以理解为建立了一个临时的历史快照，在此之后的增删改查等操作不会影响到这个快照的结果。</p></blockquote><p><strong>实现原理</strong></p><p><code>scroll</code> 会为第一次搜索创建一个<strong>快照（snapshot）</strong> 和一个<strong>搜索上下文（search context）</strong>。后续请求使用返回的 <code>scroll_id</code> 来从这个固定的快照中获取下一批结果。它本质上是一个<strong>有状态的游标</strong>。</p><blockquote><p>当你执行一个带有 <code>scroll</code> 参数的搜索查询时：</p><ol><li class="lvl-3"><strong>初始化搜索上下文</strong>：Elasticsearch会为这次搜索创建一个快照（snapshot），并存储相关的搜索上下文（search context）。这个上下文包括查询本身、排序方式、聚合等所有与搜索相关的信息。</li><li class="lvl-3"><strong>返回初始结果</strong>：Elasticsearch会像普通搜索一样返回第一批结果，并附带一个 <code>scroll_id</code>。这个 <code>scroll_id</code> 是唯一标识这次搜索上下文的。</li><li class="lvl-3"><strong>使用 scroll_id 获取更多结果</strong>：客户端可以使用这个 <code>scroll_id</code> 来请求更多的结果。Elasticsearch会基于之前存储的搜索上下文，从快照中检索更多的结果，并返回给客户端。这个过程可以重复多次，直到所有的结果都被检索完或搜索上下文过期。</li></ol></blockquote><p>由于 <code>scroll</code> 只需要在开始时计算一次搜索上下文，并在之后基于这个上下文来获取结果，因此它在处理大量数据时通常比 <code>from + size</code> 更快。但是，它也会消耗更多的服务器资源来维护搜索上下文和快照。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始搜索</span></span><br><span class="line">POST /_search/scroll</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">100</span><span class="punctuation">,</span>           <span class="comment">// 每次返回的文档数量</span></span><br><span class="line">    <span class="attr">&quot;scroll&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1m&quot;</span><span class="punctuation">,</span>        <span class="comment">// 保持scroll上下文的活动时间，这里是1分钟</span></span><br><span class="line">    <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;match_all&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span>    <span class="comment">// 可替换为任何需要的查询条件</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 二次搜索</span></span><br><span class="line">POST /_search/scroll</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;scroll&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1m&quot;</span><span class="punctuation">,</span>                <span class="comment">// 保持与第一次请求相同的scroll上下文时间</span></span><br><span class="line">    <span class="attr">&quot;scroll_id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;你的scroll_id&quot;</span> <span class="comment">// 第一次请求返回的scroll_id</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p><strong>优点：</strong></p><blockquote><ol><li class="lvl-3"><p><strong>极高的遍历效率</strong>：一旦上下文创建，后续的滚动请求非常快，因为是从快照中获取，无需再次排序和计算排名（如果不需要评分，可设置 <code>&quot;sort&quot;: [&quot;_doc&quot;]</code> 达到最大速度）。</p></li><li class="lvl-3"><p><strong>数据一致性</strong>：看到的是查询发起时刻的<strong>数据快照</strong>，在整个滚动过程中，结果集不会改变，不会受新数据写入影响。</p></li></ol></blockquote><p><strong>缺点：</strong></p><p>默认情况下，scroll请求会保持一段时间（如1分钟）的上下文，如果在这段时间内没有新的请求，上下文将被自动清除。</p><blockquote><ol><li class="lvl-3"><p><strong>非实时（Stale Data）</strong>：由于<code>scroll</code>是基于数据快照的，看到的是历史数据，无法获取滚动开始后新写入的文档。</p></li><li class="lvl-3"><p><strong>资源消耗大</strong>：<code>scroll</code>会消耗大量的服务器资源来维护游标和数据快照，搜索上下文会占用大量的堆内存和文件句柄，直到超时被自动清除。同时处理大量滚动查询会消耗集群大量资源。</p></li><li class="lvl-3"><p><strong>非随机性</strong>：不支持随机访问页面，只能顺序获取数据。</p></li><li class="lvl-3"><p><strong>有状态</strong>：需要服务器和客户端共同维护 <code>scroll_id</code> 和上下文生命周期，如果忘记清理，会导致资源泄漏。</p></li></ol></blockquote><p><strong>适用场景：</strong>.</p><p>适用于需要遍历大量数据、实时性要求不高的场景，如日志导出、数据迁移等。</p><blockquote><ul class="lvl-1"><li class="lvl-2"><p><strong>离线数据处理和大批量数据导出</strong>（例如将整个索引或大量查询结果导出到文件或数据库）。</p></li><li class="lvl-2"><p><strong>索引重建（reindex）</strong> 等后台任务。</p></li><li class="lvl-2"><p><strong>需要对大量数据进行全量分析</strong>（不关心最新数据，只关心某一时刻的状态）。</p></li></ul></blockquote><h3 id="search-after（推荐-排序值唯一）">search_after（推荐-排序值唯一）</h3><p>一种基于排序值的分页方式，它允许我们根据上一页的最后一条数据的排序值来获取下一页的数据。需要配合<code>sort</code>字段使用。</p><p><strong>实现原理</strong></p><p><code>search_after</code> 分页方式的原理是基于上一次查询的结果来确定下一次查询的起始位置。当你执行一个带有 <code>search_after</code> 参数的搜索查询时，Elasticsearch 会：</p><blockquote><ol><li class="lvl-3"><p><strong>排序和返回结果</strong>：首先，Elasticsearch会像普通搜索一样执行查询，并根据指定的排序字段对结果进行排序。然后，它会返回第一批结果。</p></li><li class="lvl-3"><p><strong>确定下一次查询的起始位置</strong>：客户端可以选择结果集中的任意一条记录作为下一次查询的起始位置。这通常是通过记录该条记录的排序字段值来实现的。</p></li><li class="lvl-3"><p><strong>使用 search_after 获取更多结果</strong>：在下一次查询时，客户端会指定 <code>search_after</code> 参数，并将上一次查询的起始位置（即排序字段值）作为该参数的值。Elasticsearch会基于这个值来确定下一次查询的起始位置，并返回该位置之后的结果。</p></li></ol></blockquote><p>由于 <code>search_after</code> 不需要像 <code>from + size</code> 那样合并和排序所有分片返回的结果，也不需要像 <code>scroll</code> 那样维护搜索上下文和快照，因此它在深度分页时通常比这两种方式更高效。但它要求排序字段的值必须是唯一的，以确保能够准确地确定下一次查询的起始位置。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始查询</span></span><br><span class="line">GET /products/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">10</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;match_all&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span>  <span class="comment">// 或者你可以添加具体的查询条件</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;sort&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span> <span class="attr">&quot;price&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;order&quot;</span><span class="punctuation">:</span> <span class="string">&quot;desc&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span>        <span class="comment">// 排序</span></span><br><span class="line">        <span class="punctuation">&#123;</span> <span class="attr">&quot;created_at&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;order&quot;</span><span class="punctuation">:</span> <span class="string">&quot;asc&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span>    <span class="comment">// 排序</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 二次查询</span></span><br><span class="line">GET /products/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">10</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;match_all&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span>  <span class="comment">// 保持与初始查询相同的查询条件</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;sort&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="comment">// 保持与初始查询相同的排序字段和顺序</span></span><br><span class="line">        <span class="punctuation">&#123;</span> <span class="attr">&quot;price&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;order&quot;</span><span class="punctuation">:</span> <span class="string">&quot;desc&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span> <span class="attr">&quot;created_at&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;order&quot;</span><span class="punctuation">:</span> <span class="string">&quot;asc&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span>  </span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;search_after&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="number">129.99</span><span class="punctuation">,</span>                  <span class="comment">// 上一页最后一个产品的price值</span></span><br><span class="line">        <span class="string">&quot;2023-10-23T12:00:00Z&quot;</span>  <span class="comment">// 上一页最后一个产品的created_at值</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p><strong>优点：</strong></p><blockquote><ol><li class="lvl-3"><p><strong>实时性 (Real-time)</strong>：默认查询的是最新的索引状态，比<code>scroll</code>更具实时性。</p></li><li class="lvl-3"><p><strong>无状态 (Stateless)</strong>：服务端不保存任何上下文。每次查询都是独立的，资源占用低，易于扩展。</p></li><li class="lvl-3"><p><strong>适用于实时分页</strong>：是替代 <code>from + size</code>（深度分页）的理想方案，用户可前后翻页（需客户端缓存多组 <code>search_after</code> 值）。</p></li></ol></blockquote><p><strong>缺点：</strong></p><blockquote><ol><li class="lvl-3"><p><strong>无法跳页</strong>：和所有游标分页一样，只能一页一页顺序往下走，不能直接跳到任意页码。</p></li><li class="lvl-3"><p><strong>需要稳定的排序</strong>：排序字段必须能够唯一确定文档顺序（通常需要至少一个唯一字段如 <code>_id</code> 作为第二排序条件），需要依赖一个或多个排序字段确定下一页的位置。否则可能导致分页结果重复或丢失。</p><blockquote><ul class="lvl-4"><li class="lvl-2">如果排序字段的值不是唯一的，可能导致查询结果不准确。</li><li class="lvl-2">如果排序字段的值发生更改（如文档被更新或删除），可能会导致结果不一致。</li></ul></blockquote></li><li class="lvl-3"><p><strong>实时性</strong>：虽然<code>search_after</code>比<code>scroll</code>更实时，但它可能仍然无法获取到查询发起后的最新数据。这取决于刷新机制，</p><blockquote><ul class="lvl-4"><li class="lvl-2">Elasticsearch 默认每 <strong>1秒</strong> 自动刷新一次索引（可配置 <code>refresh_interval</code>）。</li><li class="lvl-2">只有被 <strong>refresh</strong> 后的文档，才能被搜索到。</li><li class="lvl-2"><code>search_after</code> 查询的是 <strong>当前已 refresh 的数据快照</strong>，不是实时写入的文档。</li></ul></blockquote><p>如果你在查询发起后，有新文档写入（<code>index</code> 或 <code>update</code>），但在下一次 <code>refresh</code> 之前，这些数据 不会出现在 <code>search_after</code> 查询结果中。一旦索引刷新，后续的 <code>search_after</code> 查询就有可能查到这些新数据，</p></li><li class="lvl-3"><p><strong>客户端逻辑稍复杂</strong>：客户端需要存储和传递每页的排序值。</p></li></ol></blockquote><p><strong>适用场景：</strong></p><blockquote><p>适用于需要深度分页、实时性要求相对较高、且排序字段唯一，支持顺序向后翻页访问的场景。</p><ul class="lvl-1"><li class="lvl-2">用户界面的无限滚动（Infinite Scroll）</li><li class="lvl-2">需要实时反映数据变化的深度分页需求</li><li class="lvl-2">任何需要替代 <code>from + size</code>（特别是当 <code>from &gt; 10,000</code> 时）的高性能分页</li></ul></blockquote><h3 id="关于随机翻页">关于随机翻页</h3><p>如果你有随机跳页的需求（例如，用户直接在界面上输入页码并跳转），正确的解决方案是 扩展**<code>search_after</code>**。</p><p><strong><code>scroll</code> API 完全不支持随机访问或跳页。</strong> 这是由其核心设计理念和工作机制决定的。</p><h4 id="为什么-Scroll-不支持随机跳页？">为什么 Scroll 不支持随机跳页？</h4><ol><li class="lvl-3"><p><strong>顺序遍历器</strong>，而非随机存取器<br><code>scroll</code> 被设计成一个<strong>单向的、顺序的流式读取器</strong>。你可以把它想象成一个只能从前往后读的磁带，或者一个只能调用 <code>next()</code> 方法的迭代器 (Iterator)。</p><blockquote><p>它唯一的操作是 <strong>“获取下一批（next batch）”</strong>。系统内部维护着一个指针，指向下一批要返回的数据的起始位置。你无法让这个指针突然跳到任意位置。</p></blockquote></li><li class="lvl-3"><p><strong>基于快照的上下文</strong><br>当你初始化一个 <code>scroll</code> 请求时，Elasticsearch 会为当时的查询条件创建一个<strong>数据快照（snapshot）</strong> 和<strong>搜索上下文（search context）</strong>，这个快照是固定的。后续所有的 <code>scroll</code> 请求都是用同一个 <code>scroll_id</code>，在这个固定的快照上顺序地获取下一批数据。它没有为“跳到第 N 页”这种操作建立任何索引或映射。</p></li><li class="lvl-3"><p><strong><code>scroll_id</code> 的含义</strong><br><code>scroll_id</code> 不是一个指向页码的标记，而是一个<strong>包含了整个查询状态、排序顺序和当前读取位置</strong>的上下文句柄。服务器根据这个句柄知道“你已经拿到前 1000 条了，下一次应该从第 1001 条开始”。</p></li></ol><p><strong>举例说明</strong></p><blockquote><p>假设你有一个 10000 条结果的 <code>scroll</code> 查询，每次返回 100 条。</p><ul class="lvl-1"><li class="lvl-2"><strong>第一次请求 (<code>scroll=1m</code>)</strong>: 你得到结果 1-100 和一个 <code>scroll_id: ABC</code>。</li><li class="lvl-2"><strong>第二次请求 (带上 <code>scroll_id: ABC</code>)</strong>: 你得到结果 101-200。</li><li class="lvl-2">…</li><li class="lvl-2"><strong>你想直接拿到第 50 页（结果 4901-5000）</strong>: <strong>这是不可能的</strong>。你没有任何一个 <code>scroll_id</code> 能让你直接从 4901 开始。你唯一的办法是从头开始，顺序地进行大约 49 次 <code>scroll</code> 请求，丢弃掉前 4900 条结果，才能拿到你想要的那一页。这不仅完全失去了 <code>scroll</code> 的性能优势，其性能甚至会比深度分页更差，因为你还额外维护了一个沉重的上下文。</li></ul></blockquote><h4 id="基于-search-after-的随机翻页设计">基于 <strong><code>search_after</code></strong> 的随机翻页设计</h4><p><code>search_after</code> 的核心也不完全支持随机翻页，但通过巧妙的设计，可以实现“有限度的”随机分页。 它无法像传统数据库 <code>LIMIT offset, size</code> 那样直接跳到任意页码，但比 <code>scroll</code> 灵活得多。</p><blockquote><p>和 <code>scroll</code> 一样，<code>search_after</code> 的核心也是一个<strong>顺序遍历器</strong>。它的参数是上一页最后一条记录的<strong>排序值</strong>。Elasticsearch 利用这些值在排序索引中快速定位，并获取“接下来”的一批数据。</p><p>它没有也不维护任何关于“页码”的概念。要跳到第 N 页，系统必须知道第 (N-1) 页最后一条记录的排序值是什么。而获取这个值，恰恰就是深度分页要解决的难题本身。</p></blockquote><h5 id="策略一：客户端缓存（最实用、最常用）">策略一：客户端缓存（最实用、最常用）</h5><p>这是实现“前后翻页”和“跳回已浏览页”的最主流方案。</p><blockquote><ol><li class="lvl-3"><p>客户端（浏览器、APP）或服务端会话（Session）在用户浏览过程中，<strong>缓存每一页的“页边界”</strong>（即每一页最后一条记录的排序值）。</p></li><li class="lvl-3"><p>当用户点击“下一页”时，使用当前页的排序值。</p></li><li class="lvl-3"><p>当用户点击“上一页”或想跳回之前看过的某一页（例如第3页）时，从缓存中取出第2页的排序值，作为 <code>search_after</code> 参数去查询，得到的就是第3页的结果。</p></li></ol></blockquote><p><strong>优点：</strong></p><ul class="lvl-0"><li class="lvl-2"><p>性能极佳，每次查询都是高效的。</p></li><li class="lvl-2"><p>可以实现完美的前后导航和跳回已浏览页面。</p></li></ul><p><strong>缺点：</strong></p><ul class="lvl-0"><li class="lvl-2"><p><strong>无法跳转到未浏览的页面</strong>。你不能直接跳到第100页，除非你之前已经一页一页地浏览并缓存了第99页的排序值。</p></li><li class="lvl-2"><p>需要客户端逻辑来管理这个缓存。</p></li></ul><h5 id="策略二：服务端预计算（复杂，有代价）">策略二：服务端预计算（复杂，有代价）</h5><p>如果需要支持跳转到未浏览的页面，需要一个更强大的服务端架构。</p><blockquote><ol><li class="lvl-3"><p><strong>构建“页索引”服务</strong>：有一个后台任务或服务，预先为常见的排序和查询条件计算好每一页的边界排序值，并将其存储起来（例如在Redis中）。</p></li><li class="lvl-3"><p><strong>查询流程</strong>：当用户请求跳转到第N页时，API先向这个“页索引”服务请求获取第(N-1)页的排序值，然后再用这个值去执行 <code>search_after</code> 查询。</p></li></ol></blockquote><p><strong>优点：</strong> 理论上可以实现真正的随机跳页。</p><p><strong>缺点：</strong></p><ul class="lvl-0"><li class="lvl-2"><p><strong>极其复杂</strong>：引入了新的服务和系统复杂性。</p></li><li class="lvl-2"><p><strong>维护成本高</strong>：数据有任何增删改，都可能使预计算的页边界失效，需要重新计算，维护数据一致性挑战巨大。</p></li><li class="lvl-2"><p><strong>不灵活</strong>：只能针对少数几个固定的排序方式和查询条件做预计算。</p></li></ul><h5 id="策略三：近似跳页（牺牲精确度）">策略三：近似跳页（牺牲精确度）</h5><p>如果你的一个排序字段是均匀分布的（如自增ID、均匀分布的时间戳），你可以进行估算。例如，你想跳转到第50页（每页20条），你可以估算一个 <code>search_after</code> 值。然后让用户在这个大致的结果集里进行微调。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;search_after&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span> <span class="string">&quot;2023-01-01T00:00:00Z&quot;</span> <span class="punctuation">]</span><span class="punctuation">,</span> <span class="comment">// 估算一个大概的时间点</span></span><br><span class="line">  <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">20</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>**缺点：**结果不精确，用户体验差，适用场景有限。</p><h3 id="行业标准做法（强烈推荐）">行业标准做法（强烈推荐）</h3><p>像Google、Amazon、Netflix这样的大型互联网应用，<strong>它们直接从产品设计上规避了“深度随机跳页”的需求</strong>。</p><blockquote><ol><li class="lvl-3"><p><strong>提供强大的搜索和筛选器</strong>：让用户通过加条件（如时间范围、分类、标签）来缩小结果集，使其变得很少，无需深度分页。</p></li><li class="lvl-3"><p><strong>只提供“上一页/下一页”</strong>：这是无限滚动的标准模式，完美契合 <code>search_after</code> 的优势。</p></li><li class="lvl-3"><p><strong>限制最大可访问范围</strong>：即使提供了页码，通常也只显示前10页或前20页的页码选项，并提示“请优化搜索以查看更多结果”。</p></li></ol></blockquote>]]></content>
    
    
    <summary type="html">在海量数据表中，如何解决深度分页问题，提高查询效率</summary>
    
    
    
    <category term="DB" scheme="https://pengline.github.io/categories/DB/"/>
    
    <category term="深度分页" scheme="https://pengline.github.io/categories/DB/%E6%B7%B1%E5%BA%A6%E5%88%86%E9%A1%B5/"/>
    
    
    <category term="深度分页" scheme="https://pengline.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%88%86%E9%A1%B5/"/>
    
    <category term="scroll" scheme="https://pengline.github.io/tags/scroll/"/>
    
    <category term="游标分页" scheme="https://pengline.github.io/tags/%E6%B8%B8%E6%A0%87%E5%88%86%E9%A1%B5/"/>
    
    <category term="search_after" scheme="https://pengline.github.io/tags/search-after/"/>
    
  </entry>
  
  <entry>
    <title>基于 LangChain + RAG + Ollama 构建智能医疗问答系统</title>
    <link href="https://pengline.github.io/2025/09/04/92bb519d826e4443936d4cce27ceb524/"/>
    <id>https://pengline.github.io/2025/09/04/92bb519d826e4443936d4cce27ceb524/</id>
    <published>2025-09-04T03:16:03.664Z</published>
    <updated>2025-09-06T12:34:30.407Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于-LangChain"><a href="https://www.langchain.com.cn/docs">关于 LangChain</a></h2><p>LangChain 是一个用于构建基于大语言模型应用程序的开源框架，旨在帮助开发者更高效地开发、部署和管理 LLM 驱动的应用。</p><p>其核心价值在于模块化设计、标准化接口和丰富的工具链，简化从原型设计到生产部署的AI应用开发全流程。它不依赖特定模型，而是提供统一接口对接OpenAI、Hugging Face等主流LLM，并支持自定义模型集成，使开发者能聚焦业务逻辑而非底层技术细节。</p><blockquote><p>它提供了一系列模块化组件和工具，简化了与 LLM 交互、数据处理、工作流编排等任务。</p><ul class="lvl-1"><li class="lvl-2"><strong>LangChain</strong>：提供七大组件（Agent, Models, Chains, Tools, Memory, Callbacks, RAG）。</li><li class="lvl-2"><strong>LangGraph</strong>：在其之上编排复杂流程，解决两类问题：<ol><li class="lvl-5"><strong>线性链的局限</strong>：基础 Chain 难以处理循环/分支。</li><li class="lvl-5"><strong>Agent 的扩展</strong>：增强 Agent 的鲁棒性（如自动重试、状态回溯）。</li></ol></li></ul></blockquote><p>LangChain 主要解决以下问题：</p><blockquote><ul class="lvl-1"><li class="lvl-2"><p><strong>LLM 集成</strong>：支持多种大模型（如 OpenAI GPT、Anthropic、Llama2 等），统一接口调用。</p></li><li class="lvl-2"><p><strong>上下文管理</strong>：处理长文本、多轮对话的上下文限制（如分块、摘要、记忆机制）。</p></li><li class="lvl-2"><p><strong>数据增强</strong>：结合外部数据源（文档、数据库、API）进行检索增强生成（RAG）。</p></li><li class="lvl-2"><p><strong>工作流编排</strong>：通过链（Chain）将多个步骤组合成复杂流程（如问答、摘要、代码生成）。</p></li><li class="lvl-2"><p><strong>代理（Agent）</strong>：让 LLM 动态调用工具（如搜索、计算、自定义函数）完成复杂任务。</p></li></ul></blockquote><p>使用案例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 翻译智能体</span></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"><span class="keyword">from</span> langchain_core.prompts <span class="keyword">import</span> ChatPromptTemplate</span><br><span class="line"><span class="keyword">from</span> langchain_core.output_parsers <span class="keyword">import</span> StrOutputParser</span><br><span class="line"><span class="keyword">from</span> langchain_openai <span class="keyword">import</span> ChatOpenAI</span><br><span class="line"><span class="keyword">from</span> langserve <span class="keyword">import</span> add_routes</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. Create prompt template</span></span><br><span class="line">system_template = <span class="string">&quot;Translate the following into &#123;language&#125;:&quot;</span></span><br><span class="line">prompt_template = ChatPromptTemplate.from_messages([</span><br><span class="line">    (<span class="string">&#x27;system&#x27;</span>, system_template),</span><br><span class="line">    (<span class="string">&#x27;user&#x27;</span>, <span class="string">&#x27;&#123;text&#125;&#x27;</span>)</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. Create model</span></span><br><span class="line">model = ChatOpenAI()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. Create parser（输出转换，只过滤需要的内容）</span></span><br><span class="line">parser = StrOutputParser()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. Create chain</span></span><br><span class="line">chain = prompt_template | model | parser</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. App definition</span></span><br><span class="line">app = FastAPI(</span><br><span class="line">  title=<span class="string">&quot;LangChain Server&quot;</span>,</span><br><span class="line">  version=<span class="string">&quot;1.0&quot;</span>,</span><br><span class="line">  description=<span class="string">&quot;A simple API server using LangChain&#x27;s Runnable interfaces&quot;</span>,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. Adding chain route</span></span><br><span class="line">add_routes(</span><br><span class="line">    app,</span><br><span class="line">    chain,</span><br><span class="line">    path=<span class="string">&quot;/chain&quot;</span>,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="keyword">import</span> uvicorn</span><br><span class="line">    uvicorn.run(app, host=<span class="string">&quot;localhost&quot;</span>, port=<span class="number">8000</span>)</span><br></pre></td></tr></table></figure><h2 id="关于-Ollama"><a href="https://ollama.com/">关于 Ollama</a></h2><p>Ollama 是一个强大的运行框架，旨在使运行LLM尽可能简单。Ollama 简化了在本地机器或服务器上下载、运行和管理大型语言模型的整个过程。使用 Ollama 很简单，可以在不同的平台上完成安装。</p><p>Ollama的API具有许多基本功能，使其成为开发人员的重要选择之一，其主要功能如下：</p><blockquote><ul class="lvl-1"><li class="lvl-2"><p>流支持：实时token生成，完全兼容OpenAI API，非常适合创建响应式应用程序。</p></li><li class="lvl-2"><p>多模型管理： 能够同时运行不同的模型，但有一个警告。 当 VRAM 有限时，Ollama 将停止一个模型来运行另一个模型，这需要仔细的资源规划。</p></li><li class="lvl-2"><p>参数控制： 通过 API 调用进行高度可定制的设置，它提供了很大的灵活性，但对于初学者和生产环境的服务器来说并不友好。</p></li><li class="lvl-2"><p>CPU 兼容性： 当 VRAM 不足时，智能资源管理可以自动将模型卸载到 CPU执行，使得在 GPU 内存有限的系统上也可以运行大模型服务。</p></li><li class="lvl-2"><p>语言无关性： 可以自由使用Python、 JavaScript、 Go等编程语言，以及其他任何具有 HTTP 功能的编程语言。</p></li></ul></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装模型</span></span><br><span class="line">ollama pull nomic-embed-text</span><br><span class="line">ollama pull qwen2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动ollama</span></span><br><span class="line">ollama server</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入对话模式</span></span><br><span class="line">ollama run qwen2</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 调用 ollama 的接口</span></span><br><span class="line">curl --location --request POST <span class="string">&#x27;http://localhost:11434/api/generate&#x27;</span> \</span><br><span class="line">--header <span class="string">&#x27;Content-Type: application/json&#x27;</span> \</span><br><span class="line">--data-raw <span class="string">&#x27;&#123;</span></span><br><span class="line"><span class="string">    &quot;model&quot;: &quot;qwen2&quot;,</span></span><br><span class="line"><span class="string">    &quot;prompt&quot;: &quot;Why is the sky blue?&quot;,</span></span><br><span class="line"><span class="string">    &quot;stream&quot;: false</span></span><br><span class="line"><span class="string">&#125;&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="关于-Chroma"><a href="https://github.com/chroma-core/chroma">关于 Chroma</a></h2><p>Chroma 是一种高效的开源向量数据库，专为存储和检索高维向量数据设计，广泛应用于文本嵌入管理和相似性搜索。它通过将文本转化为向量嵌入，支持语义搜索、推荐系统等功能，尤其适合大模型应用场景。</p><blockquote><p>Chroma 的核心基于 HNSW 算法，支持快速的近似最近邻搜索。其主要特点包括：</p><ul class="lvl-1"><li class="lvl-2"><strong>多存储后端</strong>：支持 DuckDB 和 ClickHouse 等存储选项。</li><li class="lvl-2"><strong>多语言支持</strong>：提供 Python 和 JavaScript SDK。</li><li class="lvl-2"><strong>简单易用</strong>：设计简洁，提升开发效率。</li><li class="lvl-2"><strong>高性能</strong>：支持快速相似性搜索和结果分析。</li></ul></blockquote><p>使用案例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> chromadb</span><br><span class="line"><span class="comment"># 初始化客户端：</span></span><br><span class="line">client = chromadb.Client()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建集合：</span></span><br><span class="line">collection = client.create_collection(<span class="string">&quot;all-my-documents&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加数据：</span></span><br><span class="line">collection.add(</span><br><span class="line">    documents=[<span class="string">&quot;Document about AI&quot;</span>, <span class="string">&quot;Document about food&quot;</span>],</span><br><span class="line">    metadatas=[&#123;<span class="string">&quot;category&quot;</span>: <span class="string">&quot;technology&quot;</span>&#125;, &#123;<span class="string">&quot;category&quot;</span>: <span class="string">&quot;lifestyle&quot;</span>&#125;],</span><br><span class="line">    ids=[<span class="string">&quot;id1&quot;</span>, <span class="string">&quot;id2&quot;</span>]</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询数据，支持通过元数据和文档内容进行过滤查询，按元数据过滤：</span></span><br><span class="line">results = collection.query(</span><br><span class="line">    query_texts=[<span class="string">&quot;AI&quot;</span>],</span><br><span class="line">    n_results=<span class="number">2</span>,</span><br><span class="line">    where=&#123;<span class="string">&quot;category&quot;</span>: &#123;<span class="string">&quot;$eq&quot;</span>: <span class="string">&quot;technology&quot;</span>&#125;&#125;</span><br><span class="line">)</span><br><span class="line"><span class="built_in">print</span>(results)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 组合条件查询：按元数据过滤 + 按文档内容过滤</span></span><br><span class="line">results = collection.query(</span><br><span class="line">    query_texts=[<span class="string">&quot;AI&quot;</span>],</span><br><span class="line">    n_results=<span class="number">2</span>,</span><br><span class="line">    where=&#123;<span class="string">&quot;$and&quot;</span>: [&#123;<span class="string">&quot;category&quot;</span>: &#123;<span class="string">&quot;$eq&quot;</span>: <span class="string">&quot;technology&quot;</span>&#125;&#125;, &#123;<span class="string">&quot;year&quot;</span>: &#123;<span class="string">&quot;$gt&quot;</span>: <span class="number">2021</span>&#125;&#125;]&#125;</span><br><span class="line">)</span><br><span class="line"><span class="built_in">print</span>(results)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新数据：</span></span><br><span class="line">collection.update(</span><br><span class="line">    ids=[<span class="string">&quot;id1&quot;</span>],</span><br><span class="line">    documents=[<span class="string">&quot;Updated document about AI&quot;</span>],</span><br><span class="line">    metadatas=[&#123;<span class="string">&quot;category&quot;</span>: <span class="string">&quot;updated technology&quot;</span>&#125;]</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除数据：</span></span><br><span class="line">collection.delete(ids=[<span class="string">&quot;id1&quot;</span>])</span><br></pre></td></tr></table></figure><h2 id="医疗问答-Demo">医疗问答 Demo</h2><p>构建 医疗问答系统的样例。需要安装 Ollama 以及 相关依赖，添加指定数据集。可参考 <a href="https://github.com/haengood/ai-medical-agent">GitHub 源码</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> glob</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> langchain_core._api <span class="keyword">import</span> LangChainDeprecationWarning</span><br><span class="line">warnings.filterwarnings(<span class="string">&quot;ignore&quot;</span>, category=LangChainDeprecationWarning)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> langchain.agents <span class="keyword">import</span> initialize_agent, Tool</span><br><span class="line"><span class="keyword">from</span> langchain.chains <span class="keyword">import</span> RetrievalQA</span><br><span class="line"><span class="comment"># 按照最新的langchain导入规范，从langchain_community导入组件</span></span><br><span class="line"><span class="keyword">from</span> langchain_ollama <span class="keyword">import</span> ChatOllama</span><br><span class="line"><span class="keyword">from</span> langchain_chroma <span class="keyword">import</span> Chroma</span><br><span class="line"><span class="keyword">from</span> langchain_community.embeddings <span class="keyword">import</span> HuggingFaceEmbeddings</span><br><span class="line"><span class="keyword">from</span> langchain_community.document_loaders <span class="keyword">import</span> TextLoader</span><br><span class="line"><span class="keyword">from</span> langchain.text_splitter <span class="keyword">import</span> CharacterTextSplitter</span><br><span class="line"><span class="keyword">from</span> langchain_community.tools <span class="keyword">import</span> DuckDuckGoSearchRun</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加项目根目录到Python路径，以便导入tools模块</span></span><br><span class="line">sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), <span class="string">&#x27;../../&#x27;</span>)))</span><br><span class="line"><span class="comment"># 导入医疗专用工具</span></span><br><span class="line"><span class="keyword">from</span> tools.medical_tools <span class="keyword">import</span> MedicalTools</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MedicalAgent</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 初始化语言模型 - 使用Ollama并优化参数以提高响应速度</span></span><br><span class="line">        <span class="variable language_">self</span>.llm = ChatOllama(</span><br><span class="line">            model=<span class="string">&quot;gemma3:4b&quot;</span>,  <span class="comment"># Ollama中的模型名称，使用更通用的llama3</span></span><br><span class="line">            temperature=<span class="number">0</span>,</span><br><span class="line">            base_url=<span class="string">&quot;http://localhost:11434&quot;</span>,  <span class="comment"># Ollama默认API地址</span></span><br><span class="line">            <span class="comment"># 增加超时时间以解决连接问题</span></span><br><span class="line">            timeout=<span class="number">300</span>,</span><br><span class="line">            <span class="comment"># 移除JSON格式要求，某些模型可能不支持</span></span><br><span class="line">            <span class="comment"># format=&quot;json&quot;</span></span><br><span class="line">        )</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 加载RAG数据</span></span><br><span class="line">        <span class="variable language_">self</span>.vectorstore = <span class="variable language_">self</span>.load_medical_knowledge()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 创建检索链 - 减少检索文档数量以提高速度</span></span><br><span class="line">        <span class="variable language_">self</span>.retrieval_chain = RetrievalQA.from_chain_type(</span><br><span class="line">            llm=<span class="variable language_">self</span>.llm,</span><br><span class="line">            chain_type=<span class="string">&quot;stuff&quot;</span>,</span><br><span class="line">            retriever=<span class="variable language_">self</span>.vectorstore.as_retriever(</span><br><span class="line">                search_kwargs=&#123;<span class="string">&quot;k&quot;</span>: <span class="number">2</span>&#125;  <span class="comment"># 从3减少到2，减少需要处理的文档数量</span></span><br><span class="line">            ),</span><br><span class="line">            return_source_documents=<span class="literal">True</span></span><br><span class="line">        )</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 创建网络搜索工具</span></span><br><span class="line">        <span class="variable language_">self</span>.search = DuckDuckGoSearchRun()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 定义工具列表</span></span><br><span class="line">        <span class="variable language_">self</span>.tools = [</span><br><span class="line">            Tool(</span><br><span class="line">                name=<span class="string">&quot;Medical Knowledge Base&quot;</span>,</span><br><span class="line">                func=<span class="variable language_">self</span>.query_medical_knowledge,</span><br><span class="line">                description=<span class="string">&quot;适合用来回答医学知识相关的问题，包括疾病、药物、急救和健康生活方式等内容&quot;</span></span><br><span class="line">            ),</span><br><span class="line">            Tool(</span><br><span class="line">                name=<span class="string">&quot;Web Search&quot;</span>,</span><br><span class="line">                func=<span class="variable language_">self</span>.search.run,</span><br><span class="line">                description=<span class="string">&quot;适合用来搜索最新的医疗信息、研究进展和新闻等互联网信息&quot;</span></span><br><span class="line">            ),</span><br><span class="line">            Tool(</span><br><span class="line">                name=<span class="string">&quot;Symptom Extractor&quot;</span>,</span><br><span class="line">                func=<span class="variable language_">self</span>.extract_symptoms,</span><br><span class="line">                description=<span class="string">&quot;适合用来从文本中提取症状信息&quot;</span></span><br><span class="line">            ),</span><br><span class="line">            Tool(</span><br><span class="line">                name=<span class="string">&quot;Severity Assessment&quot;</span>,</span><br><span class="line">                func=<span class="variable language_">self</span>.assess_severity,</span><br><span class="line">                description=<span class="string">&quot;适合用来评估症状的严重程度&quot;</span></span><br><span class="line">            )</span><br><span class="line">        ]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 初始化智能体 - 关闭verbose输出以提高响应速度</span></span><br><span class="line">        <span class="variable language_">self</span>.agent = initialize_agent(</span><br><span class="line">            <span class="variable language_">self</span>.tools,</span><br><span class="line">            <span class="variable language_">self</span>.llm,</span><br><span class="line">            agent=<span class="string">&quot;zero-shot-react-description&quot;</span>,</span><br><span class="line">            verbose=<span class="literal">False</span>,  <span class="comment"># 从True改为False，减少输出信息</span></span><br><span class="line">            handle_parsing_errors=<span class="literal">True</span>,</span><br><span class="line">            max_iterations=<span class="number">3</span>,  <span class="comment"># 限制最大迭代次数</span></span><br><span class="line">            early_stopping_method=<span class="string">&quot;force&quot;</span></span><br><span class="line">        )</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 初始化医疗工具</span></span><br><span class="line">        <span class="variable language_">self</span>.medical_tools = MedicalTools()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">load_medical_knowledge</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;加载医疗知识库数据&quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 获取data目录下的所有txt文件</span></span><br><span class="line">        data_dir = os.path.join(os.path.abspath(os.path.dirname(__file__)), <span class="string">&quot;../../data&quot;</span>)</span><br><span class="line">        files = glob.glob(os.path.join(data_dir, <span class="string">&quot;*.txt&quot;</span>))</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> files:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;警告: 未找到医疗知识库文件。将创建一个空的向量存储。&quot;</span>)</span><br><span class="line">            <span class="keyword">from</span> langchain_community.embeddings <span class="keyword">import</span> FakeEmbeddings</span><br><span class="line">            <span class="keyword">from</span> langchain_core.documents <span class="keyword">import</span> Document</span><br><span class="line">            <span class="comment"># 创建空文档列表并使用from_documents方法初始化Chroma</span></span><br><span class="line">            empty_docs = [Document(page_content=<span class="string">&quot;这是一个空的医疗知识库文档&quot;</span>, metadata=&#123;<span class="string">&quot;source&quot;</span>: <span class="string">&quot;empty&quot;</span>&#125;)]</span><br><span class="line">            <span class="keyword">return</span> Chroma.from_documents(empty_docs, FakeEmbeddings(size=<span class="number">768</span>))</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 加载文档</span></span><br><span class="line">        documents = []</span><br><span class="line">        <span class="keyword">for</span> file <span class="keyword">in</span> files:</span><br><span class="line">            loader = TextLoader(file, encoding=<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">            documents.extend(loader.load())</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 分割文档</span></span><br><span class="line">        text_splitter = CharacterTextSplitter(chunk_size=<span class="number">1000</span>, chunk_overlap=<span class="number">200</span>)</span><br><span class="line">        texts = text_splitter.split_documents(documents)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 创建向量存储 - 使用FakeEmbeddings避免下载外部模型</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;使用FakeEmbeddings创建向量存储...&quot;</span>)</span><br><span class="line">        <span class="keyword">from</span> langchain_community.embeddings <span class="keyword">import</span> FakeEmbeddings</span><br><span class="line">        vectorstore = Chroma.from_documents(texts, FakeEmbeddings(size=<span class="number">768</span>))</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> vectorstore</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">query_medical_knowledge</span>(<span class="params">self, query</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;查询医疗知识库 - 优化查询逻辑以提高响应速度&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># 快速查询</span></span><br><span class="line">            result = <span class="variable language_">self</span>.retrieval_chain.invoke(query)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 格式化回答，包含来源信息</span></span><br><span class="line">            answer = result[<span class="string">&quot;result&quot;</span>]</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 简化处理逻辑，减少不必要的操作</span></span><br><span class="line">            sources = <span class="built_in">set</span>()</span><br><span class="line">            <span class="keyword">for</span> doc <span class="keyword">in</span> result[<span class="string">&quot;source_documents&quot;</span>]:</span><br><span class="line">                <span class="keyword">if</span> <span class="string">&quot;source&quot;</span> <span class="keyword">in</span> doc.metadata:</span><br><span class="line">                    sources.add(os.path.basename(doc.metadata[<span class="string">&quot;source&quot;</span>]))</span><br><span class="line">            </span><br><span class="line">            formatted_sources = <span class="string">&quot;\n来源: &quot;</span> + <span class="string">&quot;, &quot;</span>.join(sources) <span class="keyword">if</span> sources <span class="keyword">else</span> <span class="string">&quot;&quot;</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 直接返回回答，减少额外处理</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">f&quot;<span class="subst">&#123;answer&#125;</span><span class="subst">&#123;formatted_sources&#125;</span>&quot;</span></span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;知识库查询错误: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">f&quot;知识库查询失败: <span class="subst">&#123;<span class="built_in">str</span>(e)&#125;</span>&quot;</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">extract_symptoms</span>(<span class="params">self, text</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;提取症状信息&quot;&quot;&quot;</span></span><br><span class="line">        symptoms = <span class="variable language_">self</span>.medical_tools.extract_symptoms(text)</span><br><span class="line">        <span class="keyword">if</span> symptoms:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">f&quot;提取到的症状: <span class="subst">&#123;<span class="string">&#x27;, &#x27;</span>.join(symptoms)&#125;</span>&quot;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;未提取到明显症状&quot;</span></span><br><span class="line">            </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">assess_severity</span>(<span class="params">self, symptoms_text</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;评估症状严重程度&quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 先从文本中提取症状</span></span><br><span class="line">        symptoms = <span class="variable language_">self</span>.medical_tools.extract_symptoms(symptoms_text)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> symptoms:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;未提取到可评估的症状&quot;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 评估严重程度</span></span><br><span class="line">        severity = <span class="variable language_">self</span>.medical_tools.assess_severity(symptoms)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;症状: <span class="subst">&#123;<span class="string">&#x27;, &#x27;</span>.join(symptoms)&#125;</span>\n<span class="subst">&#123;severity&#125;</span>&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self, question</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;运行智能体回答问题&quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 验证医疗查询是否合适</span></span><br><span class="line">        is_valid, error_msg = <span class="variable language_">self</span>.medical_tools.validate_medical_query(question)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> is_valid:</span><br><span class="line">            <span class="keyword">return</span> error_msg</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 使用invoke方法替代已过时的run方法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.agent.invoke(question)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># 创建医疗智能体实例</span></span><br><span class="line">    medical_agent = MedicalAgent()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 示例问题</span></span><br><span class="line">    questions = [</span><br><span class="line">        <span class="string">&quot;什么是高血压？如何预防？&quot;</span>,</span><br><span class="line">        <span class="string">&quot;老年高血压患者有哪些注意事项？&quot;</span>,</span><br><span class="line">        <span class="string">&quot;脑血栓的高危因素有哪些？如何预防？&quot;</span>,</span><br><span class="line">        <span class="string">&quot;糖尿病的预防措施有哪些？&quot;</span>,</span><br><span class="line">        <span class="string">&quot;老年人如何保持健康的生活方式？&quot;</span>,</span><br><span class="line">        <span class="string">&quot;高血压、糖尿病和脑血栓之间有什么关系？&quot;</span>,</span><br><span class="line">        <span class="string">&quot;高危人群应该多久进行一次体检？&quot;</span></span><br><span class="line">    ]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 运行示例</span></span><br><span class="line">    <span class="keyword">for</span> q <span class="keyword">in</span> questions:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;\n问题: <span class="subst">&#123;q&#125;</span>&quot;</span>)</span><br><span class="line">        result = medical_agent.run(q)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;回答: <span class="subst">&#123;result&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">该系统能够利用预设的医疗知识库和网络搜索功能，为用户提供专业、准确的医疗健康咨询服务</summary>
    
    
    
    <category term="AI" scheme="https://pengline.github.io/categories/AI/"/>
    
    <category term="Agent" scheme="https://pengline.github.io/categories/AI/Agent/"/>
    
    
    <category term="AI" scheme="https://pengline.github.io/tags/AI/"/>
    
    <category term="LangChain" scheme="https://pengline.github.io/tags/LangChain/"/>
    
    <category term="LangGraph" scheme="https://pengline.github.io/tags/LangGraph/"/>
    
    <category term="Ollama" scheme="https://pengline.github.io/tags/Ollama/"/>
    
    <category term="医疗问答Agent" scheme="https://pengline.github.io/tags/%E5%8C%BB%E7%96%97%E9%97%AE%E7%AD%94Agent/"/>
    
  </entry>
  
  <entry>
    <title>Java 多线程之等待全部执行完成</title>
    <link href="https://pengline.github.io/2025/08/28/6d4b4511bd2443af994ec8e5982eb34a/"/>
    <id>https://pengline.github.io/2025/08/28/6d4b4511bd2443af994ec8e5982eb34a/</id>
    <published>2025-08-28T09:12:34.096Z</published>
    <updated>2025-09-08T23:49:05.411Z</updated>
    
    <content type="html"><![CDATA[<p>需求：多线程任务（查询、文件、API）同时执行，等所有线程执行完成后才能继续向下，执行其他任务</p><h2 id="submit-多线程">submit()  多线程</h2><p>底层通过实现 Future 接口实现返回值，获取 callable 接口。</p><p>只有等线程执行完成获取到结果后才能继续执行后面的流程，会阻塞直到结果返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原理</span></span><br><span class="line"><span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="literal">null</span>);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RunnableAdapter 实现 Callable 接口的 call()</span></span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; RunnableFuture&lt;T&gt; <span class="title function_">newTaskFor</span><span class="params">(Runnable runnable, T value)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.callable = <span class="keyword">new</span> <span class="title class_">RunnableAdapter</span>&lt;T&gt;(runnable, value);</span><br><span class="line">    <span class="built_in">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Callable 的 get() 方法 ，通过运行状态 和 LockSupport 实现线程阻塞</span></span><br></pre></td></tr></table></figure><p>使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;b&gt; 只有所有线程运行结束后才可以结束</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Haeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Email</span> haeng2030@gmail.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2025/1/14 18:20</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadOnlyAllBySubmit</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(RandomUtil.randomInt(n * <span class="number">2000</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;------thread = &#123;&#125;, num=&#123;&#125;, msg = &#123;&#125;&quot;</span>, Thread.currentThread().getName(), n, e.getLocalizedMessage());</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">ThreadPoolExecutor</span> <span class="variable">threadPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">5</span>, <span class="number">10</span>,</span><br><span class="line">                <span class="number">5L</span>, TimeUnit.SECONDS, <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="number">10</span>));</span><br><span class="line"></span><br><span class="line">        <span class="type">ThreadOnlyAllBySubmit</span> <span class="variable">threadOnlyOne</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadOnlyAllBySubmit</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//        submit 等待线程执行完成，返回值</span></span><br><span class="line">        Future&lt;Integer&gt; res1 = threadPool.submit(() -&gt; threadOnlyOne.test(<span class="number">1</span>));</span><br><span class="line">        Future&lt;Integer&gt; res2 = threadPool.submit(() -&gt; threadOnlyOne.test(<span class="number">4</span>));</span><br><span class="line">        Future&lt;Integer&gt; res3 = threadPool.submit(() -&gt; threadOnlyOne.test(<span class="number">7</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// get 方法等待线程执行完成后获取结果，超时后没有则抛出异常</span></span><br><span class="line">            log.warn(<span class="string">&quot;res1:: isDone=&#123;&#125;,   res=&#123;&#125;&quot;</span>, res1.isDone(), res1.get(<span class="number">5</span>, TimeUnit.SECONDS));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;+++++ meg1 = &#123;&#125;&quot;</span>, e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.warn(<span class="string">&quot;res2:: isDone=&#123;&#125;,   res=&#123;&#125;&quot;</span>, res2.isDone(), res2.get(<span class="number">5</span>, TimeUnit.SECONDS));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;+++++ meg2 = &#123;&#125;&quot;</span>, e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.warn(<span class="string">&quot;res3:: isDone=&#123;&#125;,   res=&#123;&#125;&quot;</span>, res3.isDone(), res3.get(<span class="number">5</span>, TimeUnit.SECONDS));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;+++++ meg3 = &#123;&#125;&quot;</span>, e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Semaphore（信号量）">Semaphore（信号量）</h2><p>计数信号量用来控制同时访问某个特定资源的操作数量，或者同时执行某个指定操作的数量。计数信号量还可以用来实现某种资源池，或者对容器施加边界。</p><blockquote><p>Semaphore 中管理着一组虚拟的许可，通过  acquire 获取一个许可，如果没有许可则一直阻塞。其本质就是操作系统的P-V操作，当资源足够的时候线程获得资源并执行，资源不足时线程等待或者退出，当资源被释放时线程又可以获取竞争资源继续执行；</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;b&gt; 只有所有线程运行结束后才可以结束</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Haeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Email</span> haeng2030@gmail.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2025/1/14 18:20</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadOnlyAllBySemaphore</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> n, <span class="keyword">final</span> AtomicInteger val)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(RandomUtil.randomInt(<span class="number">5000</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;------thread = &#123;&#125;, msg = &#123;&#125;&quot;</span>, Thread.currentThread().getName(), e.getLocalizedMessage());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        semaphore.release();</span><br><span class="line">        val.addAndGet(n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">ThreadPoolExecutor</span> <span class="variable">threadPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">5</span>, <span class="number">10</span>,</span><br><span class="line">                <span class="number">5L</span>, TimeUnit.SECONDS, <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="number">10</span>));</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">threadNum</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">        <span class="type">ThreadOnlyAllBySemaphore</span> <span class="variable">threadOnlyOne</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadOnlyAllBySemaphore</span>();</span><br><span class="line">        <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">val</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        threadPool.execute(() -&gt; threadOnlyOne.test(<span class="number">1</span>, val));</span><br><span class="line">        threadPool.execute(() -&gt; threadOnlyOne.test(<span class="number">4</span>, val));</span><br><span class="line">        threadPool.execute(() -&gt; threadOnlyOne.test(<span class="number">7</span>, val));</span><br><span class="line">        threadPool.execute(() -&gt; threadOnlyOne.test(<span class="number">2</span>, val));</span><br><span class="line">        threadPool.execute(() -&gt; threadOnlyOne.test(<span class="number">6</span>, val));</span><br><span class="line"></span><br><span class="line">        semaphore.acquire(threadNum);</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">&quot;semaphore结果=&#123;&#125;&quot;</span>, val.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CountDownLatch（计数器）">CountDownLatch（计数器）</h2><p>一种同步工具类，可以延迟线程的进度直到其到达终止状态。可以用来确保某些活动直到其他活动都完成后才继续执行。</p><p>应用场景：</p><blockquote><ul class="lvl-1"><li class="lvl-2"><p>确保某个计算在其需要的所有资源都被初始化之后才继续执行。</p></li><li class="lvl-2"><p>确保某个服务在其依赖的所有其他服务都已经启动之后才启动。</p></li><li class="lvl-2"><p>等待直到某个操作的所有参与者都就绪再继续执行。</p></li></ul></blockquote><p>实现原理：</p><blockquote><p>闭锁状态包括一个计数器，该计数器被初始化为一个正数，表示需要等待的事件数量。 countDown 方法用来递减计数器，表示有一个事件已经发生了， await 方法用来等待计数器达到零。如果计数器的值非零，那么 await 方法会一直阻塞直到计数器为零，或者等待中的线程中断、等待超时。当某个线程调用await()方法时，由于tryAcquireShared会判断state是否等于0，如果不等于，就会进入等待队列，直到countDown调用sync.releaseShared(1)使得sync的状态到0，await的线程才会继续执行；</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;b&gt; 只有所有线程运行结束后才可以结束</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Haeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Email</span> haeng2030@gmail.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2025/1/14 18:20</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadOnlyAllByCountDownLatch</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch countDownLatch;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ThreadOnlyAllByCountDownLatch</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.num = num;</span><br><span class="line">        countDownLatch = <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> n, <span class="keyword">final</span> AtomicInteger val)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(RandomUtil.randomInt(<span class="number">5000</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;------thread = &#123;&#125;,  msg = &#123;&#125;&quot;</span>, Thread.currentThread().getName(), e.getLocalizedMessage());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.countDown();</span><br><span class="line"></span><br><span class="line">        val.addAndGet(n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">ThreadPoolExecutor</span> <span class="variable">threadPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">5</span>, <span class="number">10</span>,</span><br><span class="line">                <span class="number">5L</span>, TimeUnit.SECONDS, <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="number">10</span>));</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">threadNum</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">        <span class="type">ThreadOnlyAllByCountDownLatch</span> <span class="variable">threadOnlyOne</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadOnlyAllByCountDownLatch</span>(threadNum);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">val</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        threadPool.execute(() -&gt; threadOnlyOne.test(<span class="number">1</span>, val));</span><br><span class="line">        threadPool.execute(() -&gt; threadOnlyOne.test(<span class="number">4</span>, val));</span><br><span class="line">        threadPool.execute(() -&gt; threadOnlyOne.test(<span class="number">7</span>, val));</span><br><span class="line">        threadPool.execute(() -&gt; threadOnlyOne.test(<span class="number">2</span>, val));</span><br><span class="line">        threadPool.execute(() -&gt; threadOnlyOne.test(<span class="number">6</span>, val));</span><br><span class="line"></span><br><span class="line">        threadOnlyOne.countDownLatch.await();</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">&quot;countDownLatch结果=&#123;&#125;&quot;</span>, val.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">多线程如何实现“等待全部执行完成”，才能继续执行下一步。</summary>
    
    
    
    <category term="Java" scheme="https://pengline.github.io/categories/Java/"/>
    
    <category term="多线程" scheme="https://pengline.github.io/categories/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
    <category term="Java多线程" scheme="https://pengline.github.io/tags/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    <category term="ThreadPoolExecutor" scheme="https://pengline.github.io/tags/ThreadPoolExecutor/"/>
    
    <category term="Runnable" scheme="https://pengline.github.io/tags/Runnable/"/>
    
    <category term="Callable" scheme="https://pengline.github.io/tags/Callable/"/>
    
    <category term="Semaphore" scheme="https://pengline.github.io/tags/Semaphore/"/>
    
  </entry>
  
  <entry>
    <title>Java 多线程之等待至少一个执行完成</title>
    <link href="https://pengline.github.io/2025/08/28/ab60513384f74cac8ff0ab36a98cc1a6/"/>
    <id>https://pengline.github.io/2025/08/28/ab60513384f74cac8ff0ab36a98cc1a6/</id>
    <published>2025-08-28T09:11:42.868Z</published>
    <updated>2025-09-08T23:49:44.644Z</updated>
    
    <content type="html"><![CDATA[<p>需求：多个线程同时执行一个任务，只要一个成功就退出，其他线程任务可以取消或无视。</p><blockquote><p><strong>注意</strong>：如果要暂停线程池中其他未执行完成的线程，需要先记录下来，然后调用其打断方法。</p></blockquote><h2 id="CountDownLatch（计数器）">CountDownLatch（计数器）</h2><p>一种同步工具类，可以延迟线程的进度直到其到达终止状态。可以用来确保某些活动直到其他活动都完成后才继续执行。</p><p>应用场景：</p><blockquote><ul class="lvl-1"><li class="lvl-2"><p>确保某个计算在其需要的所有资源都被初始化之后才继续执行。</p></li><li class="lvl-2"><p>确保某个服务在其依赖的所有其他服务都已经启动之后才启动。</p></li><li class="lvl-2"><p>等待直到某个操作的所有参与者都就绪再继续执行。</p></li></ul></blockquote><p>实现原理：</p><blockquote><p>闭锁状态包括一个计数器，该计数器被初始化为一个正数，表示需要等待的事件数量。 countDown 方法用来递减计数器，表示有一个事件已经发生了， await 方法用来等待计数器达到零。如果计数器的值非零，那么 await 方法会一直阻塞直到计数器为零，或者等待中的线程中断、等待超时。当某个线程调用await()方法时，由于tryAcquireShared会判断state是否等于0，如果不等于，就会进入等待队列，直到countDown调用sync.releaseShared(1)使得sync的状态到0，await的线程才会继续执行；</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;b&gt; 只要有一个线程运行结束后，就可以结束。忽视其他未完成线程</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; CountDownLatch</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Haeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Email</span> haeng2030@gmail.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2025/1/14 18:20</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadOnlyOneByCountDownLatch</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> n, <span class="keyword">final</span> AtomicInteger val)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(RandomUtil.randomInt(<span class="number">5000</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;------thread = &#123;&#125;,  msg = &#123;&#125;&quot;</span>, Thread.currentThread().getName(), e.getLocalizedMessage());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.countDown();</span><br><span class="line"></span><br><span class="line">        val.compareAndSet(<span class="number">0</span>, n);</span><br><span class="line">        log.info(<span class="string">&quot;------thread = &#123;&#125;, num=&#123;&#125; &quot;</span>, Thread.currentThread().getName(), n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">ThreadPoolExecutor</span> <span class="variable">threadPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">5</span>, <span class="number">10</span>,</span><br><span class="line">                <span class="number">5L</span>, TimeUnit.SECONDS, <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="number">10</span>));</span><br><span class="line"></span><br><span class="line">        <span class="type">ThreadOnlyOneByCountDownLatch</span> <span class="variable">threadOnlyOne</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadOnlyOneByCountDownLatch</span>();</span><br><span class="line">        <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">val</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        threadPool.execute(() -&gt; threadOnlyOne.test(<span class="number">1</span>, val));</span><br><span class="line">        threadPool.execute(() -&gt; threadOnlyOne.test(<span class="number">4</span>, val));</span><br><span class="line">        threadPool.execute(() -&gt; threadOnlyOne.test(<span class="number">7</span>, val));</span><br><span class="line">        threadPool.execute(() -&gt; threadOnlyOne.test(<span class="number">2</span>, val));</span><br><span class="line">        threadPool.execute(() -&gt; threadOnlyOne.test(<span class="number">6</span>, val));</span><br><span class="line"></span><br><span class="line">        threadOnlyOne.countDownLatch.await();</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">&quot;countDownLatch结果=&#123;&#125;&quot;</span>, val.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CyclicBarrier（循环栅栏）">CyclicBarrier（循环栅栏）</h2><p>栅栏能阻塞一组线程直到某个事件发生，直到所有线程都到达栅栏点，栅栏才会打开。所以栅栏一般用于多个线程需要相互等待的情况</p><p><strong>闭锁用于等待事件，而栅栏用于等待其他线程。</strong></p><p>可以使一定数量的参与方（线程）<strong>反复地</strong>在栅栏位置汇集，<code>await</code>方法将阻塞直到所有线程都到达栅栏位置。</p><p><strong>原理实现:</strong></p><blockquote><p>CyclicBarrier 维护了一个计数器，和一个 generation 每次调用await都会有将计数器减一，并且产生一个新的 generation ，只要计数器不为零，所有前置线程都会触发  await(); 内部会调用 LockSupport.park(this); 方法将线程加入等待队列， 所有线程就绪，会调用 trip.signalAll(); 唤醒所有线程，同时执行一个用户自定义的 Runnable 策略</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;b&gt; 一个线程完成就继续，忽视其他未完成线程</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; CyclicBarrier  两个屏障</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Haeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Email</span> haeng2030@gmail.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2025/1/14 18:20</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadOnlyOneByCyclicBarrier</span> &#123;</span><br><span class="line"><span class="comment">//    建立两个屏障</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">CyclicBarrier</span> <span class="variable">cyclicBarrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> n, <span class="keyword">final</span> AtomicInteger val)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(RandomUtil.randomInt(<span class="number">5000</span>));</span><br><span class="line">            cyclicBarrier.await(); <span class="comment">//放开栅栏1</span></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;------thread = &#123;&#125;, num=&#123;&#125;, msg = &#123;&#125;&quot;</span>, Thread.currentThread().getName(), n, e.getLocalizedMessage());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        val.compareAndSet(<span class="number">0</span>, n);</span><br><span class="line">        log.info(<span class="string">&quot;------thread = &#123;&#125;, num=&#123;&#125; &quot;</span>, Thread.currentThread().getName(), n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">ThreadPoolExecutor</span> <span class="variable">threadPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">5</span>, <span class="number">10</span>,</span><br><span class="line">                <span class="number">5L</span>, TimeUnit.SECONDS, <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="number">10</span>));</span><br><span class="line"></span><br><span class="line">        <span class="type">ThreadOnlyOneByCyclicBarrier</span> <span class="variable">threadOnlyOne</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadOnlyOneByCyclicBarrier</span>();</span><br><span class="line">        <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">val</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        threadPool.execute(() -&gt; threadOnlyOne.test(<span class="number">1</span>, val));</span><br><span class="line">        threadPool.execute(() -&gt; threadOnlyOne.test(<span class="number">4</span>, val));</span><br><span class="line">        threadPool.execute(() -&gt; threadOnlyOne.test(<span class="number">7</span>, val));</span><br><span class="line"></span><br><span class="line">        threadOnlyOne.cyclicBarrier.await(); <span class="comment">//放开栅栏1</span></span><br><span class="line">        log.info(<span class="string">&quot;结果=&#123;&#125;&quot;</span>, val.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Semaphore（信号量）">Semaphore（信号量）</h2><p>计数信号量用来控制同时访问某个特定资源的操作数量，或者同时执行某个指定操作的数量。计数信号量还可以用来实现某种资源池，或者对容器施加边界。</p><blockquote><p>Semaphore 中管理着一组虚拟的许可，通过  acquire 获取一个许可，如果没有许可则一直阻塞。其本质就是操作系统的P-V操作，当资源足够的时候线程获得资源并执行，资源不足时线程等待或者退出，当资源被释放时线程又可以获取竞争资源继续执行；</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;b&gt; 一个线程完成就继续，忽视其他未完成线程</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; Semaphore 信号量</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Haeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Email</span> haeng2030@gmail.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2025/1/14 18:20</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadOnlyOneBySemaphore</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> n, <span class="keyword">final</span> AtomicInteger val)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(RandomUtil.randomInt(<span class="number">5000</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;------thread = &#123;&#125;, msg = &#123;&#125;&quot;</span>, Thread.currentThread().getName(), e.getLocalizedMessage());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        semaphore.release(); <span class="comment">// 释放信号量</span></span><br><span class="line">        val.compareAndSet(<span class="number">0</span>, n);</span><br><span class="line">        log.info(<span class="string">&quot;------thread = &#123;&#125;, num=&#123;&#125; &quot;</span>, Thread.currentThread().getName(), n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">ThreadPoolExecutor</span> <span class="variable">threadPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">5</span>, <span class="number">10</span>,</span><br><span class="line">                <span class="number">5L</span>, TimeUnit.SECONDS, <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="number">10</span>));</span><br><span class="line"></span><br><span class="line">        <span class="type">ThreadOnlyOneBySemaphore</span> <span class="variable">threadOnlyOne</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadOnlyOneBySemaphore</span>();</span><br><span class="line">        <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">val</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        threadPool.execute(() -&gt; threadOnlyOne.test(<span class="number">1</span>, val));</span><br><span class="line">        threadPool.execute(() -&gt; threadOnlyOne.test(<span class="number">4</span>, val));</span><br><span class="line">        threadPool.execute(() -&gt; threadOnlyOne.test(<span class="number">7</span>, val));</span><br><span class="line"></span><br><span class="line">        semaphore.acquire();</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">&quot;semaphore结果=&#123;&#125;&quot;</span>, val.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Queue（阻塞队列）">Queue（阻塞队列）</h2><p>通过队列的阻塞等待实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;b&gt; 其中一个线程运行结束后就可以结束，忽视其他未完成线程</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Haeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Email</span> haeng2030@gmail.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2025/1/14 18:20</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadOnlyOneByQueue</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> BlockingQueue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(RandomUtil.randomInt(<span class="number">5000</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;------thread = &#123;&#125;, msg = &#123;&#125;&quot;</span>, Thread.currentThread().getName(), e.getLocalizedMessage());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        queue.add(n);</span><br><span class="line">        log.info(<span class="string">&quot;------thread = &#123;&#125;, num=&#123;&#125; &quot;</span>, Thread.currentThread().getName(), n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">ThreadPoolExecutor</span> <span class="variable">threadPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">5</span>, <span class="number">10</span>,</span><br><span class="line">                <span class="number">5L</span>, TimeUnit.SECONDS, <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="number">10</span>));</span><br><span class="line"></span><br><span class="line">        <span class="type">ThreadOnlyOneByQueue</span> <span class="variable">threadOnlyOne</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadOnlyOneByQueue</span>();</span><br><span class="line"></span><br><span class="line">        threadPool.execute(() -&gt; threadOnlyOne.test(<span class="number">1</span>));</span><br><span class="line">        threadPool.execute(() -&gt; threadOnlyOne.test(<span class="number">4</span>));</span><br><span class="line">        threadPool.execute(() -&gt; threadOnlyOne.test(<span class="number">7</span>));</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">&quot;结果=&#123;&#125;&quot;</span>, queue.take());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="如何打断其他线程">如何打断其他线程</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;b&gt; 其中一个线程运行结束后就可以结束</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;  终止其他未结束的线程，需要先将所有线程记录下来，然后调用其打断方法。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Haeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Email</span> haeng2030@gmail.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2025/1/14 18:20</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadOnlyOneByQueueAndInterruptOther</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> BlockingQueue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> n, Set&lt;Thread&gt; runThread)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">currentThread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        runThread.add(currentThread);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(n * RandomUtil.randomInt(<span class="number">1000</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;------thread = &#123;&#125;, msg = &#123;&#125;&quot;</span>, currentThread.getName(), e.getLocalizedMessage());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        queue.add(n);</span><br><span class="line">        runThread.remove(currentThread);</span><br><span class="line">        log.info(<span class="string">&quot;------thread = &#123;&#125;, num=&#123;&#125; &quot;</span>, currentThread.getName(), n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">ThreadPoolExecutor</span> <span class="variable">threadPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">5</span>, <span class="number">10</span>,</span><br><span class="line">                <span class="number">5L</span>, TimeUnit.SECONDS, <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="number">10</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录此次运行的线程</span></span><br><span class="line">        <span class="keyword">final</span> Set&lt;Thread&gt; runThread = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        threadPool.execute(() -&gt; ThreadOnlyOneByQueueAndInterruptOther.test(<span class="number">411</span>, runThread));</span><br><span class="line">        threadPool.execute(() -&gt; ThreadOnlyOneByQueueAndInterruptOther.test(<span class="number">114</span>, runThread));</span><br><span class="line">        threadPool.execute(() -&gt; ThreadOnlyOneByQueueAndInterruptOther.test(<span class="number">70</span>, runThread));</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">&quot;结果=&#123;&#125;&quot;</span>, queue.take());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!runThread.isEmpty())<span class="comment">// 打断还在运行中的其他线程</span></span><br><span class="line">            runThread.parallelStream().forEach(Thread::interrupt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">多线程如何实现“等待至少一个执行完成”，就可执行下一步。</summary>
    
    
    
    <category term="Java" scheme="https://pengline.github.io/categories/Java/"/>
    
    <category term="多线程" scheme="https://pengline.github.io/categories/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
    <category term="Java多线程" scheme="https://pengline.github.io/tags/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    <category term="ThreadPoolExecutor" scheme="https://pengline.github.io/tags/ThreadPoolExecutor/"/>
    
    <category term="Runnable" scheme="https://pengline.github.io/tags/Runnable/"/>
    
    <category term="Semaphore" scheme="https://pengline.github.io/tags/Semaphore/"/>
    
    <category term="CountDownLatch" scheme="https://pengline.github.io/tags/CountDownLatch/"/>
    
  </entry>
  
  <entry>
    <title>负载均衡算法的多种实现方案</title>
    <link href="https://pengline.github.io/2025/08/28/eaa2e8c201164ab5bdb705ebd84ee89d/"/>
    <id>https://pengline.github.io/2025/08/28/eaa2e8c201164ab5bdb705ebd84ee89d/</id>
    <published>2025-08-28T09:03:45.330Z</published>
    <updated>2025-09-09T08:52:41.723Z</updated>
    
    <content type="html"><![CDATA[<p>常见的负载均衡算法列举与实现。</p><h2 id="随机">随机</h2><p>随机从集群中选择一个服务器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;b&gt; 负载均衡 - 随机算法   &lt;/b&gt;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; 随机获得服务器</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Haeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Email</span> haeng2030@gmail.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/8/5 17:13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RandomSlb</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;Server&gt; servers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">// 所有服务器列表</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Server&gt; currentServer = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();   <span class="comment">// 当前服务器</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得下一个服务器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Server <span class="title function_">getNextServer</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchAlgorithmException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">nextIndex</span> <span class="operator">=</span> SecureRandom.getInstanceStrong().nextInt(servers.size());</span><br><span class="line">        <span class="type">Server</span> <span class="variable">server</span> <span class="operator">=</span> servers.get(nextIndex);</span><br><span class="line">        currentServer.set(server);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> server;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchAlgorithmException &#123;</span><br><span class="line">        servers.add(<span class="keyword">new</span> <span class="title class_">Server</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="string">&quot;111&quot;</span>, <span class="number">1</span>));</span><br><span class="line">        servers.add(<span class="keyword">new</span> <span class="title class_">Server</span>(<span class="string">&quot;127.0.0.2&quot;</span>, <span class="string">&quot;222&quot;</span>, <span class="number">2</span>));</span><br><span class="line">        servers.add(<span class="keyword">new</span> <span class="title class_">Server</span>(<span class="string">&quot;127.0.0.3&quot;</span>, <span class="string">&quot;333&quot;</span>, <span class="number">3</span>));</span><br><span class="line">        servers.add(<span class="keyword">new</span> <span class="title class_">Server</span>(<span class="string">&quot;127.0.0.4&quot;</span>, <span class="string">&quot;444&quot;</span>, <span class="number">4</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(getNextServer());</span><br><span class="line">        System.out.println(getNextServer());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="随机加权">随机加权</h2><p>根据权重值，随机获取集群服务器。权值越大获取的概率越大</p><h3 id="TreeMap排序">TreeMap排序</h3><p>通过树结构实现：找到大于该权重值中的最小权重的服务。如： random = 4, 则找出的第一个为</p><p>结果近似于方法一，key为最大权重值，取最接近的一个</p><p><img src="/imgs/image-20240710113822720.png" alt="image-20240710113822720"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;b&gt;   负载均衡 - 加权随机算法   &lt;/b&gt;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; 按权重设置随机概率，示例：</span></span><br><span class="line"><span class="comment"> * 如有4个元素A、B、C、D，权重分别为1、2、3、4，随机结果中A:B:C:D的比例要为1:2:3:4。</span></span><br><span class="line"><span class="comment"> * 总体思路：累加每个元素的权重A(1)-B(3)-C(6)-D(10)，则4个元素的的权重管辖区间分别为[0,1)、[1,3)、[3,6)、[6,10)。</span></span><br><span class="line"><span class="comment"> * 然后随机出一个[0,10)之间的随机数。落在哪个区间，则该区间之后的元素即为按权重命中的元素。</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 实现方法：</span></span><br><span class="line"><span class="comment"> * 利用TreeMap，则构造出的一个树为:  利用treemap.tailMap().firstKey()即可找到目标元素。</span></span><br><span class="line"><span class="comment"> * 　　   　　B(3)</span></span><br><span class="line"><span class="comment"> * 　　   　 /      \</span></span><br><span class="line"><span class="comment"> *         /         \</span></span><br><span class="line"><span class="comment"> *      A(1)     D(10)</span></span><br><span class="line"><span class="comment"> *      /</span></span><br><span class="line"><span class="comment"> *     /</span></span><br><span class="line"><span class="comment"> *   C(6)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Haeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Email</span> haeng2030@gmail.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/8/5 17:35</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WeightRandom</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TreeMap&lt;Double, Server&gt; weightMap = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WeightRandom</span><span class="params">(<span class="keyword">final</span> List&lt;Server&gt; list)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Server server : list) &#123;</span><br><span class="line">            <span class="type">double</span> <span class="variable">lastWeight</span> <span class="operator">=</span> <span class="built_in">this</span>.weightMap.size() == <span class="number">0</span> ? <span class="number">0</span> : <span class="built_in">this</span>.weightMap.lastKey(); <span class="comment">// 获取最后一个服务累加的权重值</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.weightMap.put(server.getWeight() + lastWeight, server);    <span class="comment">//累加当前权重</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 随机获取下一个服务</span></span><br><span class="line">    <span class="keyword">public</span> Server <span class="title function_">randomServer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">randomWeight</span> <span class="operator">=</span> <span class="built_in">this</span>.weightMap.lastKey() * Math.random();     <span class="comment">// 获取随机数</span></span><br><span class="line">        <span class="comment">// 查找 key 大于  randomWeight 的所有</span></span><br><span class="line">        SortedMap&lt;Double, Server&gt; tailMap = <span class="built_in">this</span>.weightMap.tailMap(randomWeight, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.weightMap.get(tailMap.firstKey());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Server&gt; servers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        servers.add(<span class="keyword">new</span> <span class="title class_">Server</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="string">&quot;111&quot;</span>, <span class="number">1</span>));</span><br><span class="line">        servers.add(<span class="keyword">new</span> <span class="title class_">Server</span>(<span class="string">&quot;127.0.0.2&quot;</span>, <span class="string">&quot;222&quot;</span>, <span class="number">22</span>));</span><br><span class="line">        servers.add(<span class="keyword">new</span> <span class="title class_">Server</span>(<span class="string">&quot;127.0.0.3&quot;</span>, <span class="string">&quot;333&quot;</span>, <span class="number">3</span>));</span><br><span class="line">        servers.add(<span class="keyword">new</span> <span class="title class_">Server</span>(<span class="string">&quot;127.0.0.4&quot;</span>, <span class="string">&quot;444&quot;</span>, <span class="number">4</span>));</span><br><span class="line"></span><br><span class="line">        <span class="type">WeightRandom</span> <span class="variable">weightRandom</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WeightRandom</span>(servers);</span><br><span class="line">        <span class="type">int</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="number">0</span>, s2 = <span class="number">0</span>, s3 = <span class="number">0</span>, s4 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">float</span> <span class="variable">maxCount</span> <span class="operator">=</span> <span class="number">10000</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; maxCount; i++) &#123;</span><br><span class="line">            <span class="type">Server</span> <span class="variable">server</span> <span class="operator">=</span> weightRandom.randomServer();</span><br><span class="line">            <span class="keyword">switch</span> (server.getPort()) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;111&quot;</span>:</span><br><span class="line">                    s1++;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;222&quot;</span>:</span><br><span class="line">                    s2++;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;333&quot;</span>:</span><br><span class="line">                    s3++;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;444&quot;</span>:</span><br><span class="line">                    s4++;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.printf(<span class="string">&quot;s1 = %d 出现概率 %.2f \n&quot;</span>, s1, (s1 / maxCount) * <span class="number">100</span>);</span><br><span class="line">        System.out.printf(<span class="string">&quot;s2 = %d 出现概率 %.2f \n&quot;</span>, s2, (s2 / maxCount) * <span class="number">100</span>);</span><br><span class="line">        System.out.printf(<span class="string">&quot;s3 = %d 出现概率 %.2f \n&quot;</span>, s3, (s3 / maxCount) * <span class="number">100</span>);</span><br><span class="line">        System.out.printf(<span class="string">&quot;s4 = %d 出现概率 %.2f \n&quot;</span>, s4, (s4 / maxCount) * <span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="区间法">区间法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;b&gt;   负载均衡 - 加权随机算法   &lt;/b&gt;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; 按权重设置随机概率，示例：</span></span><br><span class="line"><span class="comment"> * 如有4个元素A、B、C、D，权重分别为1、2、3、4，随机结果中A:B:C:D的比例要为1:2:3:4。</span></span><br><span class="line"><span class="comment"> * 总体思路：累加每个元素的权重A(1)-B(3)-C(6)-D(10)，则4个元素的的权重管辖区间分别为[0,1)、[1,3)、[3,6)、[6,10)。</span></span><br><span class="line"><span class="comment"> *      然后随机出一个[0,10)之间的随机数。落在哪个区间，则该区间之后的元素即为按权重命中的元素。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 实现方法：</span></span><br><span class="line"><span class="comment"> *      根据权值，获得区间范围列表，并加入到对应的服务中，Map&lt;Server, Set&lt;Integer&gt;&gt;  key为服务， value为区间列表值</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Haeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Email</span> haeng2030@gmail.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/8/5 17:35</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WeightSlb</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;Server&gt; servers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">// 所有服务器列表</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">int</span> totalWeights;    <span class="comment">// 权重总和</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Server, Set&lt;Integer&gt;&gt; maps = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(); <span class="comment">// 每个服务器的权重区间值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Server&gt; currentServer = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();   <span class="comment">// 当前服务器</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置权重区间值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">weightExtent</span><span class="params">()</span> &#123;</span><br><span class="line">        totalWeights = servers.stream().mapToInt(Server::getWeight).sum();   <span class="comment">//计算权重总和</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">startSum</span> <span class="operator">=</span> <span class="number">0</span>;  <span class="comment">// 截至上一个对象的累计权值总和</span></span><br><span class="line">        <span class="keyword">for</span> (Server s : servers) &#123;</span><br><span class="line"></span><br><span class="line">            Set&lt;Integer&gt; list = maps.computeIfAbsent(s, n -&gt; <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;());</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startSum; i &lt; startSum + s.getWeight(); i++) &#123;</span><br><span class="line">                list.add(i);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            startSum += s.getWeight(); <span class="comment">// 累加本服务的权值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得下一个服务器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Server <span class="title function_">getNextServer</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchAlgorithmException &#123;</span><br><span class="line"><span class="comment">//        int nextInt = new Random().nextInt(totalWeights);</span></span><br><span class="line"><span class="comment">//        currentServer.remove();</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">nextInt</span> <span class="operator">=</span> SecureRandom.getInstanceStrong().nextInt(totalWeights);</span><br><span class="line">        <span class="keyword">for</span> (Server server : maps.keySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (maps.get(server).contains(nextInt)) &#123;</span><br><span class="line">                currentServer.set(server);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> currentServer.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchAlgorithmException &#123;</span><br><span class="line">        servers.add(<span class="keyword">new</span> <span class="title class_">Server</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="string">&quot;111&quot;</span>, <span class="number">1</span>));</span><br><span class="line">        servers.add(<span class="keyword">new</span> <span class="title class_">Server</span>(<span class="string">&quot;127.0.0.2&quot;</span>, <span class="string">&quot;222&quot;</span>, <span class="number">12</span>));</span><br><span class="line">        servers.add(<span class="keyword">new</span> <span class="title class_">Server</span>(<span class="string">&quot;127.0.0.3&quot;</span>, <span class="string">&quot;333&quot;</span>, <span class="number">3</span>));</span><br><span class="line">        servers.add(<span class="keyword">new</span> <span class="title class_">Server</span>(<span class="string">&quot;127.0.0.4&quot;</span>, <span class="string">&quot;444&quot;</span>, <span class="number">4</span>));</span><br><span class="line"></span><br><span class="line">        weightExtent();</span><br><span class="line">        <span class="type">int</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="number">0</span>, s2 = <span class="number">0</span>, s3 = <span class="number">0</span>, s4 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">float</span> <span class="variable">maxCount</span> <span class="operator">=</span> <span class="number">10000</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; maxCount; i++) &#123;</span><br><span class="line">            <span class="type">Server</span> <span class="variable">server</span> <span class="operator">=</span> getNextServer();</span><br><span class="line">            <span class="keyword">switch</span> (server.getPort()) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;111&quot;</span>:</span><br><span class="line">                    s1++;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;222&quot;</span>:</span><br><span class="line">                    s2++;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;333&quot;</span>:</span><br><span class="line">                    s3++;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;444&quot;</span>:</span><br><span class="line">                    s4++;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.printf(<span class="string">&quot;s1 = %d 出现概率 %.2f \n&quot;</span>, s1, (s1 / maxCount) * <span class="number">100</span>);</span><br><span class="line">        System.out.printf(<span class="string">&quot;s2 = %d 出现概率 %.2f \n&quot;</span>, s2, (s2 / maxCount) * <span class="number">100</span>);</span><br><span class="line">        System.out.printf(<span class="string">&quot;s3 = %d 出现概率 %.2f \n&quot;</span>, s3, (s3 / maxCount) * <span class="number">100</span>);</span><br><span class="line">        System.out.printf(<span class="string">&quot;s4 = %d 出现概率 %.2f \n&quot;</span>, s4, (s4 / maxCount) * <span class="number">100</span>);</span><br><span class="line"><span class="comment">//        System.out.println(getNextServer());</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="B-树结构">B+树结构</h3><p>利用B+树的原理。叶子结点存放元素，非叶子结点用于索引。非叶子结点有两个属性，分别保存左右子树的累加权重。如下图：</p><img src="/imgs/721070-20170609190949200-1515655849.png" alt="img" style="zoom:67%;" /><p>更改一个元素，只须修改该元素到根结点那半部分的权值即可</p><h2 id="轮询">轮询</h2><p>把来自用户的请求轮流分配给集群中的服务器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;b&gt;   负载均衡 - 轮询算法   &lt;/b&gt;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; 请求轮流分配给内部的服务器</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Haeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Email</span> haeng2030@gmail.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/8/5 17:02</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PollingSlb</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;Server&gt; servers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">// 所有服务器列表</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Server&gt; currentServer = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();   <span class="comment">// 当前服务器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">currentServerIndex</span> <span class="operator">=</span> <span class="number">0</span>;    <span class="comment">// 当前服务器下标</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得下一个服务器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Server <span class="title function_">getNextServer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Server</span> <span class="variable">server</span> <span class="operator">=</span> currentServer.get();</span><br><span class="line">        <span class="keyword">if</span> (server != <span class="literal">null</span>)</span><br><span class="line">            currentServerIndex = (currentServerIndex + <span class="number">1</span>) % servers.size();</span><br><span class="line"></span><br><span class="line">        server = servers.get(currentServerIndex);</span><br><span class="line">        currentServer.set(server);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> server;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        servers.add(<span class="keyword">new</span> <span class="title class_">Server</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="string">&quot;111&quot;</span>, <span class="number">1</span>));</span><br><span class="line">        servers.add(<span class="keyword">new</span> <span class="title class_">Server</span>(<span class="string">&quot;127.0.0.2&quot;</span>, <span class="string">&quot;222&quot;</span>, <span class="number">1</span>));</span><br><span class="line">        servers.add(<span class="keyword">new</span> <span class="title class_">Server</span>(<span class="string">&quot;127.0.0.3&quot;</span>, <span class="string">&quot;333&quot;</span>, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(PollingSlb.getNextServer());</span><br><span class="line">        System.out.println(PollingSlb.getNextServer());</span><br><span class="line">        System.out.println(PollingSlb.getNextServer());</span><br><span class="line">        System.out.println(PollingSlb.getNextServer());</span><br><span class="line">        System.out.println(PollingSlb.getNextServer());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">常见负载均衡算法的实现和原理（随机、随机加权、轮询）</summary>
    
    
    
    <category term="算法" scheme="https://pengline.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="负载均衡" scheme="https://pengline.github.io/categories/%E7%AE%97%E6%B3%95/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    
    
    <category term="算法" scheme="https://pengline.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="负载均衡" scheme="https://pengline.github.io/tags/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    
    <category term="随机加权" scheme="https://pengline.github.io/tags/%E9%9A%8F%E6%9C%BA%E5%8A%A0%E6%9D%83/"/>
    
  </entry>
  
  <entry>
    <title>docker-compose 安装脚本大集绵</title>
    <link href="https://pengline.github.io/2025/08/27/b585f359ac2749e1ac92f2801c848595/"/>
    <id>https://pengline.github.io/2025/08/27/b585f359ac2749e1ac92f2801c848595/</id>
    <published>2025-08-27T13:57:21.379Z</published>
    <updated>2025-09-04T11:16:15.961Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>包含单机版或集群部署，相关参数可自行调整</p></blockquote><h2 id="nacos">nacos</h2><p>单机版</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">nacos:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nacos/nacos-server:v2.5.1</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">nacos</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8848:8848&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;9848:9848&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;9849:9849&quot;</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MODE=standalone</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">NACOS_AUTH_ENABLE=true</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">PREFER_HOST_MODE=hostname</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MODE=standalone</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">NACOS_AUTH_IDENTITY_KEY=nacos</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">NACOS_AUTH_IDENTITY_VALUE=nacos</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">NACOS_AUTH_TOKEN=VGhpc0lzTXlDdXN0b21TZWNyZXRLZXkwMTIzNDU2Nzg=</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">TZ=Asia/Shanghai</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">JVM_XMX=1g</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">JVM_XMS=1g</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./logs:/data/nacos/logs</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./data:/data/nacos/data</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br></pre></td></tr></table></figure><h2 id="rocketmq">rocketmq</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3.3&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">namesrv:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">apache/rocketmq:5.3.2</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">rmqnamesrv</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">9876</span><span class="string">:9876</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">rocketmq</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">sh</span> <span class="string">mqnamesrv</span></span><br><span class="line">  <span class="attr">broker:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">apache/rocketmq:5.3.2</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">rmqbroker</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">10909</span><span class="string">:10909</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">10911</span><span class="string">:10911</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">10912</span><span class="string">:10912</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">NAMESRV_ADDR=rmqnamesrv:9876</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">namesrv</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">rocketmq</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">sh</span> <span class="string">mqbroker</span></span><br><span class="line">  <span class="attr">proxy:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">apache/rocketmq:5.3.2</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">rmqproxy</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">rocketmq</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">broker</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">namesrv</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">8081</span><span class="string">:8081</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">8082</span><span class="string">:8082</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">on-failure</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">NAMESRV_ADDR=rmqnamesrv:9876</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">sh</span> <span class="string">mqproxy</span></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">rocketmq:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">bridge</span></span><br></pre></td></tr></table></figure><h2 id="kafka">kafka</h2><p>单机版（KRaft模式）</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.8&quot;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">kafka:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">confluentinc/cp-kafka:latest</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">kafka</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;9092:9092&quot;</span>      <span class="comment"># 容器间通信端口</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;19092:19092&quot;</span>    <span class="comment"># 宿主机访问端口</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;9093:9093&quot;</span>      <span class="comment"># Controller端口</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">volume</span></span><br><span class="line">        <span class="attr">source:</span> <span class="string">kafka_standalone_data</span></span><br><span class="line">        <span class="attr">target:</span> <span class="string">/data/kafka</span></span><br><span class="line">        <span class="attr">read_only:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="comment"># KRaft模式必需配置</span></span><br><span class="line">      <span class="attr">CLUSTER_ID:</span> <span class="string">mk-0kz5wGoTQ6eN6vDPN2eX2A</span></span><br><span class="line">      <span class="attr">KAFKA_PROCESS_ROLES:</span> <span class="string">broker,controller</span></span><br><span class="line">      <span class="attr">KAFKA_NODE_ID:</span> <span class="number">1</span></span><br><span class="line">      <span class="attr">KAFKA_CONTROLLER_QUORUM_VOTERS:</span> <span class="number">1</span><span class="string">@localhost:9093</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment"># 关键：配置多个监听器支持不同访问场景</span></span><br><span class="line">      <span class="comment"># 在Docker容器中，使用INTERNAL监听器：kafka:19092</span></span><br><span class="line">      <span class="comment"># 在宿主机中，使用EXTERNAL监听器端口：localhost:9092</span></span><br><span class="line">      <span class="attr">KAFKA_LISTENERS:</span> <span class="string">INTERNAL://0.0.0.0:19092,EXTERNAL://0.0.0.0:9092,CONTROLLER://0.0.0.0:9093</span></span><br><span class="line">      <span class="attr">KAFKA_ADVERTISED_LISTENERS:</span> <span class="string">INTERNAL://kafka:19092,EXTERNAL://localhost:9092</span></span><br><span class="line">      <span class="attr">KAFKA_LISTENER_SECURITY_PROTOCOL_MAP:</span> <span class="string">INTERNAL:PLAINTEXT,EXTERNAL:PLAINTEXT,CONTROLLER:PLAINTEXT</span></span><br><span class="line">      <span class="attr">KAFKA_INTER_BROKER_LISTENER_NAME:</span> <span class="string">INTERNAL</span></span><br><span class="line">      <span class="attr">KAFKA_CONTROLLER_LISTENER_NAMES:</span> <span class="string">CONTROLLER</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment"># 存储配置</span></span><br><span class="line">      <span class="attr">KAFKA_LOG_DIRS:</span> <span class="string">/tmp/kraft-combined-logs</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment"># 其他配置</span></span><br><span class="line">      <span class="attr">KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR:</span> <span class="number">1</span></span><br><span class="line">      <span class="attr">KAFKA_TRANSACTION_STATE_LOG_REPLICATION_FACTOR:</span> <span class="number">1</span></span><br><span class="line">      <span class="attr">KAFKA_TRANSACTION_STATE_LOG_MIN_ISR:</span> <span class="number">1</span></span><br><span class="line">      <span class="attr">KAFKA_AUTO_CREATE_TOPICS_ENABLE:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">KAFKA_NUM_PARTITIONS:</span> <span class="number">3</span></span><br><span class="line">      <span class="attr">KAFKA_DEFAULT_REPLICATION_FACTOR:</span> <span class="number">1</span></span><br><span class="line">      <span class="comment"># 用来进行选举的Controller服务器，如果有多个Controller则都需要写上，这里本机</span></span><br><span class="line">      <span class="attr">KAFKA_CFG_CONTROLLER_QUORUM_VOTERS:</span> <span class="number">1</span><span class="string">@127.0.0.1:9094</span></span><br><span class="line">      <span class="attr">ALLOW_PLAINTEXT_LISTENER:</span> <span class="literal">yes</span></span><br><span class="line">      <span class="comment"># 开启JMX监控</span></span><br><span class="line">      <span class="attr">JMX_PORT:</span> <span class="number">9998</span></span><br><span class="line">      <span class="attr">KAFKA_JMX_OPTS:</span> <span class="string">-Dcom.sun.management.jmxremote</span> <span class="string">-Dcom.sun.management.jmxremote.authenticate=false</span> <span class="string">-Dcom.sun.management.jmxremote.ssl=false</span> <span class="string">-Djava.rmi.server.hostname=kafka</span> <span class="string">-Dcom.sun.management.jmxremote.rmi.port=9998</span></span><br><span class="line">      </span><br><span class="line">    <span class="attr">healthcheck:</span></span><br><span class="line">      <span class="attr">test:</span> [<span class="string">&quot;CMD-SHELL&quot;</span>, <span class="string">&quot;kafka-broker-api-versions --bootstrap-server localhost:9092&quot;</span>]</span><br><span class="line">      <span class="attr">interval:</span> <span class="string">30s</span></span><br><span class="line">      <span class="attr">timeout:</span> <span class="string">10s</span></span><br><span class="line">      <span class="attr">retries:</span> <span class="number">3</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">kafka-network</span>     </span><br><span class="line">      </span><br><span class="line">  <span class="attr">kafka-ui:</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">kafka-ui</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">provectuslabs/kafka-ui:latest</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="comment"># 访问UI： http://localhost:9090/kafkaui/auth</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;9090:8080&quot;</span></span><br><span class="line">    <span class="attr">depends_on:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="string">kafka</span></span><br><span class="line">     <span class="comment"># kafka:</span></span><br><span class="line">     <span class="comment">#   condition: service_healthy</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">KAFKA_CLUSTERS_0_NAME:</span> <span class="string">kafka-stand-alone</span></span><br><span class="line">      <span class="attr">KAFKA_CLUSTERS_0_BOOTSTRAPSERVERS:</span> <span class="string">kafka:19092</span></span><br><span class="line">      <span class="attr">KAFKA_CLUSTERS_0_READONLY:</span> <span class="literal">false</span></span><br><span class="line">      <span class="attr">KAFKA_CLUSTERS_0_METRICS_PORT:</span> <span class="number">9998</span></span><br><span class="line">      <span class="attr">SERVER_SERVLET_CONTEXT_PATH:</span> <span class="string">/kafkaui</span></span><br><span class="line">      <span class="attr">AUTH_TYPE:</span> <span class="string">disabled</span>  <span class="comment"># 或者设置为 : &quot;LOGIN_FORM&quot;</span></span><br><span class="line">      <span class="attr">SPRING_SECURITY_USER_NAME:</span> <span class="string">admin</span></span><br><span class="line">      <span class="attr">SPRING_SECURITY_USER_PASSWORD:</span> <span class="number">123456</span></span><br><span class="line">      <span class="attr">DYNAMIC_CONFIG_ENABLED:</span> <span class="string">&#x27;true&#x27;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">kafka-network</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">unless-stopped</span></span><br><span class="line">      </span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="attr">kafka_standalone_data:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">local</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">kafka-network:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">bridge</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="mqtt">mqtt</h2><p>单机版</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">mosquitto:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">eclipse-mosquitto:2.0</span>    <span class="comment"># 只能选择 mqttx 中的 3.1.1 版本，才能连接上</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">mqtt</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">mosquitto</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="literal">no</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;1883:1883&quot;</span>  <span class="comment"># </span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;9001:9001&quot;</span>  <span class="comment"># WebSocket for web clients</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8083:8083&quot;</span>  <span class="comment"># MQTT over WebSocket (alternative)</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./conf/mosquitto.conf:/mosquitto/config/mosquitto.conf</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./data/mosquitto:/mosquitto/data</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./logs/mosquitto:/mosquitto/log</span></span><br><span class="line">    <span class="comment">#  - ./data/mosquitto/password.txt:/mosquitto/config/password.txt  # 预先创建好的密码文件</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mqtt-network</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">TZ=Asia/Shanghai</span>  <span class="comment"># 设置时区</span></span><br><span class="line">    <span class="attr">deploy:</span></span><br><span class="line">      <span class="attr">resources:</span></span><br><span class="line">        <span class="attr">limits:</span></span><br><span class="line">          <span class="attr">memory:</span> <span class="string">512M</span></span><br><span class="line">          <span class="attr">cpus:</span> <span class="string">&#x27;1&#x27;</span></span><br><span class="line">        <span class="attr">reservations:</span></span><br><span class="line">          <span class="attr">memory:</span> <span class="string">256M</span></span><br><span class="line">    <span class="attr">healthcheck:</span></span><br><span class="line">      <span class="attr">test:</span> [<span class="string">&quot;CMD&quot;</span>, <span class="string">&quot;mosquitto&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;/mosquitto/config/mosquitto.conf&quot;</span>]</span><br><span class="line">      <span class="attr">interval:</span> <span class="string">30s</span></span><br><span class="line">      <span class="attr">timeout:</span> <span class="string">10s</span></span><br><span class="line">      <span class="attr">retries:</span> <span class="number">3</span></span><br><span class="line">      </span><br><span class="line">  <span class="comment"># MQTT 管理界面</span></span><br><span class="line"><span class="comment">#  mqtt-admin:</span></span><br><span class="line"><span class="comment">#    image: hivemq/hivemq-mqtt-web-client:latest</span></span><br><span class="line"><span class="comment">#    container_name: mqtt-admin</span></span><br><span class="line"><span class="comment">#    ports:</span></span><br><span class="line"><span class="comment">#      - &quot;8080:8080&quot;</span></span><br><span class="line"><span class="comment">#    environment:</span></span><br><span class="line"><span class="comment">#      - HIVEMQ_BROKER_HOST=mosquitto</span></span><br><span class="line"><span class="comment">#      - HIVEMQ_BROKER_PORT=1883</span></span><br><span class="line"><span class="comment">#    depends_on:</span></span><br><span class="line"><span class="comment">#      - mosquitto</span></span><br><span class="line"><span class="comment">#    restart: no</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Node-RED（可选，用于MQTT数据处理）</span></span><br><span class="line">  <span class="attr">node-red:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nodered/node-red:latest</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">node-red</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;1880:1880&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./data/mosquitto/node-red-data:/data</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="literal">no</span>   <span class="comment"># unless-stopped</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">mqtt-network:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">bridge</span></span><br><span class="line"><span class="comment"># 可选：自定义网络参数，更好地隔离</span></span><br><span class="line">    <span class="comment"># ipam:</span></span><br><span class="line">    <span class="comment">#   config:</span></span><br><span class="line">    <span class="comment">#     - subnet: 172.28.0.0/16</span></span><br></pre></td></tr></table></figure><p><code>mosquitto.conf</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"># Basic configuration</span><br><span class="line"># TCP 监听器</span><br><span class="line">listener <span class="number">1883</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line">protocol mqtt</span><br><span class="line"># 允许匿名连接</span><br><span class="line">allow_anonymous <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"># Security</span><br><span class="line"># password_file /mosquitto/config/password.txt</span><br><span class="line"></span><br><span class="line"># Persistence</span><br><span class="line">persistence <span class="literal">true</span></span><br><span class="line">persistence_location /mosquitto/data/</span><br><span class="line">autosave_interval <span class="number">1800</span></span><br><span class="line"></span><br><span class="line"># 兼容性设置</span><br><span class="line">connection_messages <span class="literal">true</span></span><br><span class="line"># 协议版本兼容性</span><br><span class="line">allow_zero_length_clientid <span class="literal">true</span></span><br><span class="line">auto_id_prefix <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">log_timestamp <span class="literal">true</span></span><br><span class="line"># Logging</span><br><span class="line">log_dest file /mosquitto/log/mosquitto.log</span><br><span class="line">log_type error</span><br><span class="line">log_dest stdout</span><br><span class="line">log_type all</span><br><span class="line"></span><br><span class="line"># Limits</span><br><span class="line">max_connections <span class="number">1000</span></span><br><span class="line">max_keepalive <span class="number">300</span></span><br><span class="line">max_packet_size <span class="number">1024</span></span><br><span class="line"></span><br><span class="line"># WebSocket support</span><br><span class="line">listener <span class="number">9001</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line">protocol websockets</span><br></pre></td></tr></table></figure><h2 id="skywalking">skywalking</h2><p>skywalking 包含的所有组件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3.3&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">elasticsearch:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">elasticsearch:7.14.2</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">elasticsearch</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">9200</span><span class="string">:9200</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;TAKE_FILE_OWNERSHIP=true&quot;</span> <span class="comment">#volumes 挂载权限 如果不想要挂载es文件改配置可以删除</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;discovery.type=single-node&quot;</span> <span class="comment">#单机模式启动</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;TZ=Asia/Shanghai&quot;</span> <span class="comment"># 设置时区</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;</span> <span class="comment"># 设置jvm内存大小</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./elasticsearch/logs:/usr/share/elasticsearch/logs</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./elasticsearch/data:/usr/share/elasticsearch/data</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./elasticsearch/conf/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml</span></span><br><span class="line">    <span class="attr">ulimits:</span></span><br><span class="line">      <span class="attr">memlock:</span></span><br><span class="line">        <span class="attr">soft:</span> <span class="number">-1</span></span><br><span class="line">        <span class="attr">hard:</span> <span class="number">-1</span></span><br><span class="line">  <span class="attr">skywalking-oap-server:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">apache/skywalking-oap-server:8.9.1</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">skywalking-oap-server</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">elasticsearch</span></span><br><span class="line">    <span class="attr">links:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">elasticsearch</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">11800</span><span class="string">:11800</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">12800</span><span class="string">:12800</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">SW_STORAGE:</span> <span class="string">elasticsearch</span>  <span class="comment"># 指定ES版本</span></span><br><span class="line">      <span class="attr">SW_STORAGE_ES_CLUSTER_NODES:</span> <span class="string">elasticsearch:9200</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">Asia/Shanghai</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">./oap/conf/alarm-settings.yml:/skywalking/config/alarm-settings.yml</span></span><br><span class="line">  <span class="attr">skywalking-ui:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">apache/skywalking-ui:8.9.1</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">skywalking-ui</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">skywalking-oap-server</span></span><br><span class="line">    <span class="attr">links:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">skywalking-oap-server</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">8080</span><span class="string">:8080</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">SW_OAP_ADDRESS:</span> <span class="string">http://skywalking-oap-server:12800</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">Asia/Shanghai</span></span><br></pre></td></tr></table></figure><h2 id="prometheus">prometheus</h2><p>prometheus 包含的所有组件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">net-prometheus:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">bridge</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="comment"># 核心组件   </span></span><br><span class="line">  <span class="attr">prometheus:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">prom/prometheus</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">prometheus</span></span><br><span class="line">    <span class="attr">user:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">TZ=Asia/Shanghai</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="literal">no</span>     <span class="comment"># always</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;9090:9090&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./prometheus/conf:/etc/prometheus</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./prometheus/data/prometheus_db:/prometheus</span> </span><br><span class="line">    <span class="attr">command:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;--config.file=/etc/prometheus/prometheus.yml&#x27;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;--storage.tsdb.path=/prometheus&#x27;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;--web.console.libraries=/usr/share/prometheus/console_libraries&#x27;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;--web.console.templates=/usr/share/prometheus/consoles&#x27;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">net-prometheus</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 前端展示</span></span><br><span class="line">  <span class="attr">grafana:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">grafana/grafana</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">grafana</span></span><br><span class="line">    <span class="attr">user:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">TZ=Asia/Shanghai</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="literal">no</span>     <span class="comment"># always</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;3000:3000&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">     <span class="comment"># - ./prometheus/conf/grafana:/etc/grafana</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./prometheus/data/grafana_data:/var/lib/grafana</span></span><br><span class="line">    <span class="attr">depends_on:</span>  </span><br><span class="line">      <span class="bullet">-</span> <span class="string">prometheus</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">net-prometheus</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">pushgateway:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">prom/pushgateway</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">pushgateway</span></span><br><span class="line">    <span class="attr">user:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">TZ=Asia/Shanghai</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="literal">no</span>     <span class="comment"># always</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;9091:9091&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./prometheus/data/pushgateway_data:/var/lib/pushgateway</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">net-prometheus</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 告警组件      </span></span><br><span class="line">  <span class="attr">alertmanager:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">prom/alertmanager</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">alertmanager</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">alertmanager</span></span><br><span class="line">    <span class="attr">user:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">TZ=Asia/Shanghai</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="literal">no</span>     <span class="comment"># always</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;9093:9093&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./prometheus/data/alertmanager_data:/var/lib/alertmanager</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">net-prometheus</span></span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line"><span class="comment"># 节点监控</span></span><br><span class="line">  <span class="attr">node_exporter:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">prom/node-exporter</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">node_exporter</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;./prometheus:/host:ro,rslave&#x27;</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">9100</span><span class="string">:9100</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">Asia/Shanghai</span></span><br><span class="line">    <span class="attr">command:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;--path.rootfs=/host&#x27;</span></span><br><span class="line">    <span class="attr">labels:</span></span><br><span class="line">      <span class="attr">org.label-schema.group:</span> <span class="string">&quot;monitoring&quot;</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="literal">no</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">net-prometheus</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 容器监控</span></span><br><span class="line">  <span class="attr">cadvisor:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">google/cadvisor:latest</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">cadvisor</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">cadvisor</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="literal">no</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./prometheus/:/rootfs:ro</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./prometheus/var/run:/var/run:rw</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./prometheus/sys:/sys:ro</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./prometheus/var/lib/docker/:/var/lib/docker:ro</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;8080:8080&#x27;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">net-prometheus</span></span><br></pre></td></tr></table></figure><p><code>prometheus.yml</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># my global config</span></span><br><span class="line"><span class="attr">global:</span></span><br><span class="line">  <span class="attr">scrape_interval:</span>     <span class="string">15s</span> <span class="comment"># Set the scrape interval to every 15 seconds. Default is every 1 minute.</span></span><br><span class="line">  <span class="attr">evaluation_interval:</span> <span class="string">15s</span> <span class="comment"># Evaluate rules every 15 seconds. The default is every 1 minute.</span></span><br><span class="line">  <span class="comment"># scrape_timeout is set to the global default (10s).</span></span><br><span class="line">  <span class="attr">external_labels:</span></span><br><span class="line">    <span class="attr">monitor:</span> <span class="string">&#x27;dashboard&#x27;</span></span><br><span class="line"></span><br><span class="line">      </span><br><span class="line"><span class="comment"># Alertmanager configuration</span></span><br><span class="line"><span class="attr">alerting:</span></span><br><span class="line">  <span class="attr">alert_relabel_configs:</span> <span class="comment"># 动态修改 alert 属性的规则配置。</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">source_labels:</span> [<span class="string">dc</span>] </span><br><span class="line">      <span class="attr">regex:</span> <span class="string">(.+)\d+</span></span><br><span class="line">      <span class="attr">target_label:</span> <span class="string">dc1</span></span><br><span class="line">  <span class="attr">alertmanagers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">static_configs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">targets:</span> [<span class="string">&#x27;192.168.1.115:9093&#x27;</span>]</span><br><span class="line">      </span><br><span class="line"></span><br><span class="line"><span class="comment"># Load rules once and periodically evaluate them according to the global &#x27;evaluation_interval&#x27;.</span></span><br><span class="line"><span class="attr">rule_files:</span></span><br><span class="line">  <span class="comment"># - &quot;first_rules.yml&quot;</span></span><br><span class="line">  <span class="comment"># - &quot;second_rules.yml&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># A scrape configuration containing exactly one endpoint to scrape:</span></span><br><span class="line"><span class="comment"># Here it&#x27;s Prometheus itself.</span></span><br><span class="line"><span class="attr">scrape_configs:</span></span><br><span class="line">  <span class="comment"># The job name is added as a label `job=&lt;job_name&gt;` to any timeseries scraped from this config.</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">&#x27;prometheus&#x27;</span></span><br><span class="line">    <span class="attr">scrape_interval:</span> <span class="string">5s</span></span><br><span class="line">    <span class="attr">static_configs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">targets:</span> [<span class="string">&#x27;prometheus:9090&#x27;</span>]</span><br><span class="line">      </span><br><span class="line">  <span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">&#x27;node-exporter&#x27;</span></span><br><span class="line">    <span class="attr">static_configs:</span></span><br><span class="line">    <span class="comment"># 需要修改 node-exporter service, 不能用localhost 指的是容器内部</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">targets:</span> [<span class="string">&#x27;192.168.1.115:9100&#x27;</span>,<span class="string">&#x27;192.168.1.115:9091&#x27;</span>]</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">包含各种组件的docker compose 安装脚本，如：nacos、skywalking、kafka、mqtt</summary>
    
    
    
    <category term="CICD" scheme="https://pengline.github.io/categories/CICD/"/>
    
    <category term="docker" scheme="https://pengline.github.io/categories/CICD/docker/"/>
    
    
    <category term="docker" scheme="https://pengline.github.io/tags/docker/"/>
    
    <category term="docker-compose" scheme="https://pengline.github.io/tags/docker-compose/"/>
    
    <category term="kafka docker-compose" scheme="https://pengline.github.io/tags/kafka-docker-compose/"/>
    
    <category term="rocketmq docker-compose" scheme="https://pengline.github.io/tags/rocketmq-docker-compose/"/>
    
    <category term="skywalking docker-compose" scheme="https://pengline.github.io/tags/skywalking-docker-compose/"/>
    
    <category term="nacos docker-compose" scheme="https://pengline.github.io/tags/nacos-docker-compose/"/>
    
    <category term="prometheus docker-compose" scheme="https://pengline.github.io/tags/prometheus-docker-compose/"/>
    
  </entry>
  
  <entry>
    <title>DDD 领域模型在订单系统中的应用案例</title>
    <link href="https://pengline.github.io/2025/08/27/6efb20fcd51b42c4a7a358edeb242cf6/"/>
    <id>https://pengline.github.io/2025/08/27/6efb20fcd51b42c4a7a358edeb242cf6/</id>
    <published>2025-08-27T04:02:14.924Z</published>
    <updated>2025-09-06T12:41:07.144Z</updated>
    
    <content type="html"><![CDATA[<h1>DDD 领域模型</h1><p>领域驱动设计（Domain-driven design）是一种通过将实现连接到持续进化的模型来满足复杂需求的软件开发方法。</p><p><strong>DDD 核心思想是通过领域驱动设计方法定义领域模型，从而确定业务和应用边界，保证业务模型与代码模型的一致性</strong>。</p><blockquote><p>领域驱动设计是一种由<strong>域模型</strong>来驱动着系统设计的思想。</p><ul class="lvl-1"><li class="lvl-2">一种解决复杂系统的建模与分析方法</li><li class="lvl-2">将业务概念和规则转为对象和对象的属性行为</li><li class="lvl-2">通过封装、继承和多态降低业务复杂性</li><li class="lvl-2"><strong>不是数据库表结构的映射</strong>，而是对业务逻辑、规则、流程的建模。</li><li class="lvl-2">包含实体、值对象、聚合、领域服务、领域事件等元素。</li></ul><p>举个例子：在一个电商系统中，“订单”不是一个简单的 <code>Order</code> 表，而是一个包含下单、支付、取消、发货等行为和状态流转逻辑的复杂对象。</p></blockquote><h2 id="五层架构">五层架构</h2><p>原则：每层只能与位于其下方的层发生耦合。</p><p>分层架构可以简单分为两种，即严格分层架构和松散分层架构。在<strong>严格分层架构</strong>中，某层只能与位于其直接下方的层发生耦合，而在<strong>松散分层架构</strong>中，则允许某层与它的任意下方层发生耦合。</p><img src="/imgs/at4uaznghdxgm_a3d40698d6354ed5af6fc331081774d3.webp" alt="img" style="zoom:33%;" /><blockquote><ul class="lvl-1"><li class="lvl-2"><p>降低了系统的性能。因为增加了中间层，可以通过缓存机制来改善。</p></li><li class="lvl-2"><p>可能会导致级联的修改。这种修改尤其体现在自上而下的方向，可以通过依赖倒置来改善。</p></li></ul></blockquote><ul class="lvl-0"><li class="lvl-2"><p><strong>领域层</strong>domain（核心业务层）</p><ul class="lvl-2"><li class="lvl-4"><strong>领域对象</strong>：实体对象、值对象、聚合、聚合根 （充血模型：业务方法在实体对象里，负责维护实体自身的生命周期和状态）</li><li class="lvl-4"><strong>领域服务</strong>：接口服务，业务的具体实现（围绕实体）：商品服务、电子围栏、订单服务、运单服务、</li><li class="lvl-4"><strong>领域仓储</strong>：持久化的细节隐藏，减少领域层对基础设施层的依赖（需要使用到基础设施层，包括DB、Feign调用等）</li></ul></li><li class="lvl-2"><p><strong>防腐层</strong>（外部API）</p><ul class="lvl-2"><li class="lvl-4">三方API：隔离业务，防止污染业务代码，可通过代理或适配器实现转换</li></ul></li><li class="lvl-2"><p><strong>应用层（业务逻辑层）</strong></p><ul class="lvl-2"><li class="lvl-4">应用服务：调用和组合领域层的服务，不包含任何业务逻辑（简单除外），只是组合模型业务（类似模块化）</li><li class="lvl-4">数据转换：接口参数DTO的简单校验，以及DTO和实体值对象的数据转换</li><li class="lvl-4">事件订阅：管理多个消息主体</li><li class="lvl-4">消息订阅：多个微服务间协作解耦的异步实现方式</li></ul></li><li class="lvl-2"><p><strong>基础设施层</strong></p><ul class="lvl-2"><li class="lvl-4">数据库、缓存、消息队列、配置</li><li class="lvl-4">对外隐藏技术实现细节，提供粗粒度的数据输出服务</li><li class="lvl-4">数据库操作：领域层传递的是数据对象，在这里可以按数据表的实现方式进行拆分实现</li></ul></li><li class="lvl-2"><p><strong>用户接口层（表现层）</strong></p><ul class="lvl-2"><li class="lvl-4">面向服务间API调用，WEB接口</li><li class="lvl-4">身份认证和权限验证</li><li class="lvl-4">限流和熔断服务</li><li class="lvl-4">VO和DTO数据转换</li></ul></li></ul><blockquote><p>简单查询不涉及业务，是可以直接从应用层穿透到PO查询，不需要经过domain层</p><p>DTO是不能存在于domain层的，DDD设计不认为DTO是业务对象，entity才是</p></blockquote><h1>订单建模示例</h1><p><a href="https://github.com/haeng2015/ddd-order-demo"><strong>完整Github项目</strong></a></p><ol><li class="lvl-3"><p><strong>DDD 分层模型</strong>：</p></li></ol><blockquote><p><strong>用户接口层（Interface / API 层）</strong>：提供 REST 接口，接收外部请求。</p><p><strong>应用层（Application 层）</strong>：编排领域服务，处理用例逻辑，如“创建订单”。</p><p><strong>领域层（Domain 层）</strong>：包含核心业务逻辑，如 Order 聚合根、领域事件、状态机、仓储接口等。</p><p><strong>基础设施层（Infrastructure 层）</strong>：实现仓储接口、防腐层、外部服务调用、事件发布等。</p></blockquote><ol start="2"><li class="lvl-3"><p><strong>防腐层（Anti-Corruption Layer, ACL）</strong>：</p></li></ol><blockquote><p>用于与外部系统（如库存服务）交互，避免领域模型被外部污染。</p><p>在基础设施层实现，通过 ACL 将外部模型转换为内部领域模型。</p></blockquote><ol start="3"><li class="lvl-3"><p><strong>事件与状态机</strong>：</p></li></ol><blockquote><p>使用领域事件（如 OrderCreatedEvent, OrderPaidEvent）表达领域内发生的重要事情。</p><p>使用状态机（如 OrderStateMachine）管理订单状态的合法流转（如：待支付 -&gt; 已支付 -&gt; 已发货 / 已取消）。</p></blockquote><p><strong>代码结构展示</strong></p><blockquote><p>├── src/<br>│   └── main/<br>│       ├── java/<br>│       │   └── com/example/order/<br>│       │       ├── OrderApplication.java<br>│       │       │<br>│       │       ├── application/                 # 应用层<br>│       │       │   ├── service/<br>│       │       │   │   └── OrderService.java<br>│       │       │   └── dto/<br>│       │       │       └── OrderDTO.java<br>│       │       │<br>│       │       ├── domain/                      # 领域层（核心）<br>│       │       │   ├── model/                   # 聚合根、实体、值对象<br>│       │       │   │   ├── Order.java<br>│       │       │   │   ├── OrderItem.java<br>│       │       │   │   └── OrderStatus.java<br>│       │       │   │<br>│       │       │   ├── event/                   # 领域事件<br>│       │       │   │   ├── OrderCreatedEvent.java<br>│       │       │   │   ├── OrderPaidEvent.java<br>│       │       │   │   ├── OrderShippedEvent.java<br>│       │       │   │   └── OrderCancelledEvent.java<br>│       │       │   │<br>│       │       │   ├── repository/              # 领域仓库接口<br>│       │       │   │   └── OrderRepository.java<br>│       │       │   │<br>│       │       │   ├── service/                 # 领域服务<br>│       │       │   │   └── OrderDomainService.java<br>│       │       │   │<br>│       │       │   └── statemachine/            # 状态机配置<br>│       │       │       ├── OrderState.java<br>│       │       │       ├── OrderEvent.java<br>│       │       │       └── OrderStateMachineConfig.java<br>│       │       │<br>│       │       ├── infrastructure/              # 基础设施层<br>│       │       │   ├── persistence/             # 持久化实现<br>│       │       │   │   ├── jpa/<br>│       │       │   │   │   ├── OrderEntity.java<br>│       │       │   │   │   └── OrderRepository.java<br>│       │       │   │   └── mapper/<br>│       │       │   │       └── OrderMapper.java<br>│       │       │   │<br>│       │       │   ├── messaging/               # 消息发布（事件）<br>│       │       │   │   └── KafkaEventPublisher.java<br>│       │       │   │<br>│       │       │   └── integration/             # 外部系统集成（含防腐层）<br>│       │       │       ├── inventory/<br>│       │       │       │   ├── InventoryClient.java<br>│       │       │       │   ├── InventoryResponse.java<br>│       │       │       │   └── acl/             # 防腐层<br>│       │       │       │       ├── InventoryServiceAcl.java<br>│       │       │       │       └── InventoryRequestDTO.java<br>│       │       │       └── payment/<br>│       │       │           ├── PaymentClient.java<br>│       │       │           └── acl/<br>│       │       │               └── PaymentServiceAcl.java<br>│       │       │<br>│       │       └── interfaces/                  # 接口层（Controller）<br>│       │           └── web/<br>│       │               └── OrderController.java<br>│       │<br>│       └── resources/<br>│           ├── application.yml<br>│           ├── statemachine/                    # 状态机配置</p></blockquote><h2 id="订单管理建模">订单管理建模</h2><p>核心对象：</p><blockquote><ul class="lvl-1"><li class="lvl-2"><p>聚合根对象：<code>Order</code>（订单）</p></li><li class="lvl-2"><p>值对象：订单项（<code>OrderItem</code>）、地址（<code>Address</code>）、金额（<code>Money</code>）等</p></li><li class="lvl-2"><p>一致性边界：一次下单操作必须保证所有订单项和状态一致</p></li></ul></blockquote><h3 id="实体与值对象定义">实体与值对象定义</h3><ul class="lvl-0"><li class="lvl-2"><p><strong>值对象</strong>：<code>Money</code>（金额）</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Money</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> BigDecimal amount;</span><br><span class="line">    <span class="keyword">private</span> String currency;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Money</span><span class="params">(BigDecimal amount, String currency)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (amount.compareTo(BigDecimal.ZERO) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BusinessRuleViolation</span>(<span class="string">&quot;金额不能为负&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.amount = amount;</span><br><span class="line">        <span class="built_in">this</span>.currency = currency;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Money <span class="title function_">add</span><span class="params">(Money other)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>.currency.equals(other.currency)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BusinessRuleViolation</span>(<span class="string">&quot;货币不一致&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Money</span>(<span class="built_in">this</span>.amount.add(other.amount), <span class="built_in">this</span>.currency);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// equals, hashCode 基于 amount 和 currency</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p><strong>实体</strong>：<code>OrderItem</code>（订单项）</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderItem</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String productId;</span><br><span class="line">    <span class="keyword">private</span> String productName;</span><br><span class="line">    <span class="keyword">private</span> Money unitPrice;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> quantity;</span><br><span class="line">    <span class="keyword">private</span> Money totalPrice;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OrderItem</span><span class="params">(String productId, String productName, Money unitPrice, <span class="type">int</span> quantity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.productId = productId;</span><br><span class="line">        <span class="built_in">this</span>.productName = productName;</span><br><span class="line">        <span class="built_in">this</span>.unitPrice = unitPrice;</span><br><span class="line">        <span class="built_in">this</span>.quantity = quantity;</span><br><span class="line">        <span class="built_in">this</span>.totalPrice = unitPrice.multiply(quantity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可提供 increaseQuantity(), changePrice() 等方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p><strong>聚合根</strong>：<code>Order</code>（订单）</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Order</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String orderId;</span><br><span class="line">    <span class="keyword">private</span> String customerId;</span><br><span class="line">    <span class="keyword">private</span> List&lt;OrderItem&gt; items = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> Address shippingAddress;</span><br><span class="line">    <span class="keyword">private</span> Money totalAmount;</span><br><span class="line">    <span class="keyword">private</span> OrderStatus status;</span><br><span class="line">    <span class="keyword">private</span> DateTime createdAt;</span><br><span class="line">    <span class="keyword">private</span> List&lt;DomainEvent&gt; events = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有构造，强制使用工厂创建</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Order</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下单：创建订单</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Order <span class="title function_">createFromCart</span><span class="params">(</span></span><br><span class="line"><span class="params">            String orderId,</span></span><br><span class="line"><span class="params">            String customerId,</span></span><br><span class="line"><span class="params">            List&lt;CartItem&gt; cartItems,</span></span><br><span class="line"><span class="params">            Address address)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Order</span>();</span><br><span class="line">        order.orderId = orderId;</span><br><span class="line">        order.customerId = customerId;</span><br><span class="line">        order.shippingAddress = address;</span><br><span class="line">        order.createdAt = LocalDateTime.now();</span><br><span class="line">        order.status = OrderStatus.PENDING;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (CartItem item : cartItems) &#123;</span><br><span class="line">            <span class="type">ProductPrice</span> <span class="variable">price</span> <span class="operator">=</span> ProductService.getCurrentPrice(item.getProductId());</span><br><span class="line">            order.addItem(<span class="keyword">new</span> <span class="title class_">OrderItem</span>(</span><br><span class="line">                item.getProductId(),</span><br><span class="line">                item.getProductName(),</span><br><span class="line">                price.getAmount(),</span><br><span class="line">                item.getQuantity()</span><br><span class="line">            ));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        order.calculateTotal();</span><br><span class="line">        <span class="keyword">return</span> order;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加订单项（业务规则：仅在 PENDING 状态下允许）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addItem</span><span class="params">(OrderItem item)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (status != OrderStatus.PENDING) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BusinessRuleViolation</span>(<span class="string">&quot;订单已锁定，无法添加商品&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        items.add(item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算总金额</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">calculateTotal</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.totalAmount = items.stream()</span><br><span class="line">            .map(OrderItem::getTotalPrice)</span><br><span class="line">            .reduce(Money.ZERO, Money::add);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 支付成功：确认订单</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">confirmPayment</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (status != OrderStatus.PENDING) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BusinessRuleViolation</span>(<span class="string">&quot;订单状态异常，无法确认支付&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.status = OrderStatus.PAID;</span><br><span class="line">        <span class="comment">// 发布领域事件</span></span><br><span class="line">        DomainEventPublisher.publish(<span class="keyword">new</span> <span class="title class_">OrderPaidEvent</span>(orderId, totalAmount));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取消订单</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cancel</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (status == OrderStatus.SHIPPED) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BusinessRuleViolation</span>(<span class="string">&quot;已发货订单不能取消&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (status == OrderStatus.CANCELLED) &#123;</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">// 幂等处理</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.status = OrderStatus.CANCELLED;</span><br><span class="line">        DomainEventPublisher.publish(<span class="keyword">new</span> <span class="title class_">OrderCancelledEvent</span>(orderId, customerId));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发货</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ship</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (status != OrderStatus.PAID) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BusinessRuleViolation</span>(<span class="string">&quot;订单未支付，不能发货&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.status = OrderStatus.SHIPPED;</span><br><span class="line">        DomainEventPublisher.publish(<span class="keyword">new</span> <span class="title class_">OrderShippedEvent</span>(orderId));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addEvent</span><span class="params">(DomainEvent event)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.events.add(event);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// getter 方法省略...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p><strong>枚举及其他</strong>：<code>OrderStatus</code></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">OrderStatus</span> &#123;</span><br><span class="line">    PENDING,    <span class="comment">// 待支付</span></span><br><span class="line">    PAID,       <span class="comment">// 已支付</span></span><br><span class="line">    SHIPPED,    <span class="comment">// 已发货</span></span><br><span class="line">    CANCELLED   <span class="comment">// 已取消</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="领域事件（Domain-Events）">领域事件（Domain Events）</h3><p>领域事件可通过事件总线异步通知库存、物流、用户积分等系统。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 订单已支付</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderPaidEvent</span> <span class="keyword">implements</span> <span class="title class_">DomainEvent</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String orderId;</span><br><span class="line">    <span class="keyword">private</span> Money amount;</span><br><span class="line">    <span class="keyword">private</span> LocalDateTime occurredAt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OrderPaidEvent</span><span class="params">(String orderId, Money amount)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.orderId = orderId;</span><br><span class="line">        <span class="built_in">this</span>.amount = amount;</span><br><span class="line">        <span class="built_in">this</span>.occurredAt = LocalDateTime.now();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 订单已取消</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderCancelledEvent</span> <span class="keyword">implements</span> <span class="title class_">DomainEvent</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String orderId;</span><br><span class="line">    <span class="keyword">private</span> String customerId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OrderCancelledEvent</span><span class="params">(String orderId, String customerId)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.orderId = orderId;</span><br><span class="line">        <span class="built_in">this</span>.customerId = customerId;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 订单已发货</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderShippedEvent</span> <span class="keyword">implements</span> <span class="title class_">DomainEvent</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String orderId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OrderShippedEvent</span><span class="params">(String orderId)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.orderId = orderId;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="领域服务：OrderFulfillmentService">领域服务：<code>OrderFulfillmentService</code></h3><p>处理跨聚合或跨上下文的复杂逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderFulfillmentService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> InventoryService inventoryService;</span><br><span class="line">    <span class="keyword">private</span> PaymentQueryService paymentQueryService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleOrderPaymentConfirmed</span><span class="params">(String orderId)</span> &#123;</span><br><span class="line">        <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> orderRepository.findById(orderId);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 检查支付是否真实完成</span></span><br><span class="line">        <span class="keyword">if</span> (!paymentQueryService.isPaymentValid(orderId)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BusinessRuleViolation</span>(<span class="string">&quot;支付未验证通过&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 锁定库存（调用库存上下文）</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">locked</span> <span class="operator">=</span> inventoryService.reserveInventory(order.getItems());</span><br><span class="line">        <span class="keyword">if</span> (!locked) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BusinessRuleViolation</span>(<span class="string">&quot;库存不足&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 确认订单</span></span><br><span class="line">        order.confirmPayment();</span><br><span class="line">        orderRepository.save(order); <span class="comment">// 触发事件发布</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="仓储接口（Repository）">仓储接口（Repository）</h3><p>定义在领域层，实现放在基础设施层：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 领域层接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">OrderRepository</span> &#123;</span><br><span class="line">    Order <span class="title function_">findById</span><span class="params">(String orderId)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(Order order)</span>;</span><br><span class="line">    List&lt;Order&gt; <span class="title function_">findByCustomer</span><span class="params">(String customerId)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="工厂封装（Factory）">工厂封装（Factory）</h3><p>封装复杂创建逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Order <span class="title function_">createFromCart</span><span class="params">(</span></span><br><span class="line"><span class="params">            String orderId,</span></span><br><span class="line"><span class="params">            Customer customer,</span></span><br><span class="line"><span class="params">            ShoppingCart cart,</span></span><br><span class="line"><span class="params">            Address address)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 校验用户是否可下单</span></span><br><span class="line">        <span class="keyword">if</span> (!customer.isActive()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BusinessRuleViolation</span>(<span class="string">&quot;用户被禁用&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 校验购物车非空</span></span><br><span class="line">        <span class="keyword">if</span> (cart.getItems().isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BusinessRuleViolation</span>(<span class="string">&quot;购物车为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Order.createFromCart(orderId, customer.getId(), cart.getItems(), address);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="事件驱动的订单状态机设计">事件驱动的订单状态机设计</h2><blockquote><ul class="lvl-1"><li class="lvl-2"><p>订单的状态流转不再由“硬编码 if-else”控制，而是通过 <strong>监听领域事件</strong> 触发状态变更。</p></li><li class="lvl-2"><p>使用 <strong>状态机（State Machine）</strong> 模型来管理 <code>OrderStatus</code> 的合法转换。</p></li><li class="lvl-2"><p>所有状态变更由 <strong>领域事件驱动</strong>，保证逻辑集中、可追溯、可扩展。</p></li></ul></blockquote><table><thead><tr><th>当前状态 → 新状态</th><th>触发事件</th><th>是否允许</th></tr></thead><tbody><tr><td>PENDING → PAID</td><td>OrderPaidEvent</td><td>✅ 是</td></tr><tr><td>PENDING → CANCELLED</td><td>OrderCancelledEvent</td><td>✅ 是</td></tr><tr><td>PAID → SHIPPED</td><td>OrderShippedEvent</td><td>✅ 是</td></tr><tr><td>PAID → CANCELLED</td><td>OrderRefundedEvent</td><td>✅ 是（退款后取消）</td></tr><tr><td>SHIPPED → CANCELLED</td><td>❌</td><td>❌ 否</td></tr><tr><td>任意 → PENDING</td><td>❌</td><td>❌ 不允许回退</td></tr></tbody></table><h3 id="状态机实现">状态机实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderStateMachine</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义合法的状态转移</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;OrderStatus, List&lt;OrderStatus&gt;&gt; transitions = Map.of(</span><br><span class="line">        OrderStatus.PENDING, Arrays.asList(OrderStatus.PAID, OrderStatus.CANCELLED),</span><br><span class="line">        OrderStatus.PAID, Arrays.asList(OrderStatus.SHIPPED, OrderStatus.CANCELLED)</span><br><span class="line">        <span class="comment">// SHIPPED 没有出边 → 不可变更</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canTransition</span><span class="params">(OrderStatus from, OrderStatus to)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (from == <span class="literal">null</span> || to == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        List&lt;OrderStatus&gt; allowed = transitions.getOrDefault(from, Collections.emptyList());</span><br><span class="line">        <span class="keyword">return</span> allowed.contains(to);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行状态变更（由事件处理器调用）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">applyEvent</span><span class="params">(Order order, DomainEvent event)</span> &#123;</span><br><span class="line">        <span class="type">OrderStatus</span> <span class="variable">newStatus</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (event <span class="keyword">instanceof</span> OrderPaidEvent) &#123;</span><br><span class="line">            newStatus = OrderStatus.PAID;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event <span class="keyword">instanceof</span> OrderShippedEvent) &#123;</span><br><span class="line">            newStatus = OrderStatus.SHIPPED;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event <span class="keyword">instanceof</span> OrderCancelledEvent || event <span class="keyword">instanceof</span> OrderRefundedEvent) &#123;</span><br><span class="line">            newStatus = OrderStatus.CANCELLED;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (newStatus != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (canTransition(order.getStatus(), newStatus)) &#123;</span><br><span class="line">                order.setStatusInternal(newStatus); <span class="comment">// 注意：内部私有方法，不暴露给外部，避免外部随意修改状态</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BusinessRuleViolation</span>(</span><br><span class="line">                    <span class="string">&quot;非法状态转移: &quot;</span> + order.getStatus() + <span class="string">&quot; → &quot;</span> + newStatus);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="事件处理器（Event-Handlers）">事件处理器（Event Handlers）</h3><p>使用 Spring 的事件机制或自定义事件总线监听领域事件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderEventHandlers</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> OrderRepository orderRepository;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> OrderStateMachine stateMachine;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@EventListener</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(OrderPaidEvent event)</span> &#123;</span><br><span class="line">        <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> orderRepository.findById(event.getOrderId());</span><br><span class="line">        stateMachine.applyEvent(order, event);</span><br><span class="line">        orderRepository.save(order);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@EventListener</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(OrderShippedEvent event)</span> &#123;</span><br><span class="line">        <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> orderRepository.findById(event.getOrderId());</span><br><span class="line">        stateMachine.applyEvent(order, event);</span><br><span class="line">        orderRepository.save(order);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@EventListener</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(OrderCancelledEvent event)</span> &#123;</span><br><span class="line">        <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> orderRepository.findById(event.getOrderId());</span><br><span class="line">        stateMachine.applyEvent(order, event);</span><br><span class="line">        orderRepository.save(order);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="支持事件溯源">支持事件溯源</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 伪代码：从事件重建订单</span></span><br><span class="line"><span class="keyword">public</span> Order <span class="title function_">reconstituteFromHistory</span><span class="params">(String orderId, List&lt;DomainEvent&gt; events)</span> &#123;</span><br><span class="line">    <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Order</span>();</span><br><span class="line">    <span class="keyword">for</span> (DomainEvent event : events) &#123;</span><br><span class="line">        event.applyTo(order); <span class="comment">// 每个事件自己知道如何影响订单</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> order;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="防腐层：支付、库存等">防腐层：支付、库存等</h2><p><strong>在限界上下文之间建立翻译与隔离层</strong>，防止外部概念“侵蚀”本领域的纯洁性。 外部系统（如支付系统、库存系统）</p><blockquote><p>外部系统（支付宝）<br>↓ HTTP 回调<br>[ 支付回调 Controller ]<br>↓<br>[ AlipayAclAdapter ] → 验签 + 校验<br>↓<br>[ PaymentEventMapper ] → 映射为 OrderPaidEvent<br>↓<br>[ Domain Event Bus ]<br>├──→ [OrderEventHandlers] → 触发 Order 状态机<br>└──→ [OrderStateMachine]   → 更新订单状态<br>↓<br>[OrderRepository] →  数据持久化</p></blockquote><ol><li class="lvl-3"><h5 id="外部支付回调-DTO（来自支付宝）">外部支付回调 DTO（来自支付宝）</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AlipayCallback</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String tradeNo;</span><br><span class="line">    <span class="keyword">private</span> String outTradeNo; <span class="comment">// 我方订单号</span></span><br><span class="line">    <span class="keyword">private</span> String tradeStatus;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li class="lvl-3"><h5 id="防腐层适配器（ACL-Adapter）">防腐层适配器（ACL Adapter）</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AlipayAclAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PaymentEventMapper eventMapper;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DomainEventPublisher eventPublisher;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleCallback</span><span class="params">(AlipayCallback callback)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 校验签名（安全）</span></span><br><span class="line">        <span class="keyword">if</span> (!verifySignature(callback)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SecurityException</span>(<span class="string">&quot;非法回调&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 映射为本地下游事件</span></span><br><span class="line">        <span class="type">DomainEvent</span> <span class="variable">domainEvent</span> <span class="operator">=</span> eventMapper.toDomainEvent(callback);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 发布事件，驱动本域逻辑</span></span><br><span class="line">        <span class="keyword">if</span> (domainEvent != <span class="literal">null</span>) &#123;</span><br><span class="line">            eventPublisher.publish(domainEvent);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">verifySignature</span><span class="params">(AlipayCallback callback)</span> &#123;</span><br><span class="line">        <span class="comment">// 调用支付宝 SDK 验签</span></span><br><span class="line">        <span class="keyword">return</span> AlipaySignature.rsaCheckV2(...) == <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li class="lvl-3"><h5 id="事件映射器（Mapping-Logic）">事件映射器（Mapping Logic）</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PaymentEventMapper</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> DomainEvent <span class="title function_">toDomainEvent</span><span class="params">(AlipayCallback callback)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">orderId</span> <span class="operator">=</span> callback.getOutTradeNo();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (callback.getTradeStatus()) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;TRADE_SUCCESS&quot;</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;TRADE_FINISHED&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">OrderPaidEvent</span>(orderId, Money.of(<span class="number">999</span>, <span class="string">&quot;CNY&quot;</span>)); <span class="comment">// 可结合查询订单金额</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;TRADE_CLOSED&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">OrderRefundedEvent</span>(orderId);</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="应用层：-Service">应用层： Service</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> OrderRepository orderRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> PaymentService paymentService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DomainEventPublisher eventPublisher;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> OrderId <span class="title function_">createOrder</span><span class="params">(CreateOrderCommand command)</span> &#123;</span><br><span class="line">        <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Order</span>(command.getOrderId(), command.getAmount());</span><br><span class="line">        order.create();</span><br><span class="line">        orderRepository.save(order);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发布事件</span></span><br><span class="line">        order.getEvents().forEach(eventPublisher::publish);</span><br><span class="line">        <span class="keyword">return</span> order.getId();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">payOrder</span><span class="params">(PayOrderCommand command)</span> &#123;</span><br><span class="line">        <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> orderRepository.findById(command.getOrderId())</span><br><span class="line">            .orElseThrow(() -&gt; <span class="keyword">new</span> <span class="title class_">BusinessException</span>(<span class="string">&quot;Order not found&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先调用支付</span></span><br><span class="line">        <span class="type">PaymentResult</span> <span class="variable">result</span> <span class="operator">=</span> paymentService.processPayment(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">PaymentRequest</span>(order.getAmount(), command.getCardToken())</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (result.getStatus() == PaymentStatus.SUCCESS) &#123;</span><br><span class="line">            order.pay();</span><br><span class="line">            orderRepository.save(order);</span><br><span class="line">            order.getEvents().forEach(eventPublisher::publish);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BusinessException</span>(<span class="string">&quot;Payment failed&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="接口层：Controller">接口层：Controller</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api/orders&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> OrderService orderService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;String&gt; <span class="title function_">createOrder</span><span class="params">(<span class="meta">@RequestBody</span> OrderRequestDTO dto)</span> &#123;</span><br><span class="line">        <span class="type">OrderId</span> <span class="variable">id</span> <span class="operator">=</span> orderService.createOrder(<span class="keyword">new</span> <span class="title class_">CreateOrderCommand</span>(dto.getAmount()));</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok(id.getValue());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/&#123;orderId&#125;/pay&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;String&gt; <span class="title function_">payOrder</span><span class="params">(<span class="meta">@PathVariable</span> String orderId, <span class="meta">@RequestBody</span> PaymentRequestDTO dto)</span> &#123;</span><br><span class="line">        orderService.payOrder(<span class="keyword">new</span> <span class="title class_">PayOrderCommand</span>(<span class="keyword">new</span> <span class="title class_">OrderId</span>(orderId), dto.getCardToken()));</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok(<span class="string">&quot;Paid&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">如何在系统中使用 DDD 领域模型，以订单模块为例，充分展示该模型的设计和魅力。</summary>
    
    
    
    <category term="架构" scheme="https://pengline.github.io/categories/%E6%9E%B6%E6%9E%84/"/>
    
    <category term="DDD" scheme="https://pengline.github.io/categories/%E6%9E%B6%E6%9E%84/DDD/"/>
    
    
    <category term="领域模型" scheme="https://pengline.github.io/tags/%E9%A2%86%E5%9F%9F%E6%A8%A1%E5%9E%8B/"/>
    
    <category term="DDD" scheme="https://pengline.github.io/tags/DDD/"/>
    
    <category term="架构设计" scheme="https://pengline.github.io/tags/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>Redis 的数据过期删除和淘汰策略</title>
    <link href="https://pengline.github.io/2025/08/26/65a671b1723e48818f080dda25a3730f/"/>
    <id>https://pengline.github.io/2025/08/26/65a671b1723e48818f080dda25a3730f/</id>
    <published>2025-08-25T23:55:33.875Z</published>
    <updated>2025-09-06T12:36:10.218Z</updated>
    
    <content type="html"><![CDATA[<h2 id="过期清除策略">过期清除策略</h2><p>redis针对设置过期时间的key，所使用的清除策略有主动和被动两种方式。</p><h3 id="被动检测">被动检测</h3><p>被动检测，也称惰性删除。</p><p>放任键过期不管，每次从键空间中获取键时，都检查取得的键是否过期，如果过期就删除该键，否则就返回该键值。</p><blockquote><p>被动方式对于那些永远不会再访问的 key 并没有效果。不管怎么，这些 key 都应被过期淘汰，所以 Redis 周期性主动随机检查一部分被设置生存时间的 key，那些已经过期的 key 会被从 key 空间中删除。</p></blockquote><h3 id="主动检测">主动检测</h3><ul class="lvl-0"><li class="lvl-2"><p>定时删除：在设置键过期时间的同时，创建一个定时器 timer。让定时器在键的过期时间来临时，执行对键的删除操作。</p></li><li class="lvl-2"><p>定期删除：每隔100ms就对数据库进行一次随机抽查，删除里面的过期键。至于要删除多少过期键，以及要检查多少个数据库，则由算法决定。比如Redis每秒执行10次下面的操作：</p><blockquote><ol><li class="lvl-3">从带有生存时间的 key 的集合中随机选 20 进行检查。</li><li class="lvl-3">删除所有过期的key。</li><li class="lvl-3">如20里面有超过25%的key过期，立刻继续执行步骤1。</li></ol></blockquote></li></ul><h2 id="数据淘汰策略">数据淘汰策略</h2><p>Redis 的内存淘汰机制（Eviction Policy）是指当 Redis 的内存使用量达到设定的最大值（通过 <code>maxmemory</code> 配置）时，选择哪些数据被删除以释放空间来存放新数据的策略。</p><blockquote><p>由于redis定期删除是随机抽取检查，不可能扫描清除掉所有过期的key并删除，一些key由于未被请求，惰性删除也未触发。</p><p>同时存在未设置过期时间的key，这样redis的内存占用会越来越高。此时就需要内存淘汰机制。</p></blockquote><h3 id="淘汰算法">淘汰算法</h3><p>Redis 的淘汰算法有3种：</p><ul class="lvl-0"><li class="lvl-2"><p><strong>random</strong>（随机）</p></li><li class="lvl-2"><p><strong>TTL</strong>（将要过期）</p></li><li class="lvl-2"><p><strong>LRU</strong>（最近最少使用）</p></li></ul><h3 id="淘汰策略">淘汰策略</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定 Redis 能使用的最大内存，100MB限制</span></span><br><span class="line"><span class="attr">maxmemory</span> <span class="string">100mb</span></span><br><span class="line"><span class="comment"># 当内存达到限制时，Redis 回收策略（volatile-lru、volatile-ttl、volatile-random、allkeys-lru、allkeys-random、no-enviction）</span></span><br><span class="line"><span class="attr">maxmemory-policy</span> <span class="string">noeviction</span></span><br></pre></td></tr></table></figure><p><strong>Redis  支持6种淘汰策略</strong>:</p><blockquote><ol><li class="lvl-3"><p><strong>noeviction</strong>（默认）：不清除数据，只返回错误，会导致浪费掉更多内存（DEL 命令和其他的少数命令例外）</p></li><li class="lvl-3"><p><strong>allkeys-lru</strong>：从所有的数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰</p></li><li class="lvl-3"><p><strong>allkeys-random</strong>：从所有数据集（server.db[i].dict）中任意选择数据淘汰</p></li><li class="lvl-3"><p><strong>volatile-lru</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰</p></li><li class="lvl-3"><p><strong>volatile-random</strong>：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰</p></li><li class="lvl-3"><p><strong>volatile-ttl</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰，ttl值越大越优先被淘汰</p></li></ol></blockquote><p>如果没有设置 <strong>expire</strong> 的key,  那么 <strong>volatile-lru</strong>, <strong>volatile-random</strong> 和 <strong>volatile-ttl</strong> 策略的行为, 和 <strong>noeviction</strong>基本一致。</p><blockquote><p>一般来说:</p><p>​    设置 <code>expire</code> 会消耗额外的内存, 所以使用 <strong>allkeys-lru</strong> 策略, 可以更高效地利用内存 。</p><p>​    如果某个命令导致大量内存占用(一个很大的set), 在一段时间内, 内存的使用量会明显超过 maxmemory 限制。</p></blockquote><h3 id="策略选择建议">策略选择建议</h3><p>策略使用规则：</p><blockquote><ul class="lvl-1"><li class="lvl-2"><p>如果数据呈现幂律分布，也就是一部分数据访问频率高，一部分数据访问频率低，则使用 allkeys-lru。如果分为热数据与冷数据, 推荐使用 allkeys-lru 策略。 如果不确定具体的业务特征, 那么 allkeys-lru 是一个很好的选择。</p></li><li class="lvl-2"><p>如果数据呈现平等分布，也就是所有的数据访问频率都相同，则使用 allkeys-random，即读写所有元素的概率差不多。</p></li></ul></blockquote><table><thead><tr><th style="text-align:left">策略</th><th style="text-align:left">适用场景</th></tr></thead><tbody><tr><td style="text-align:left"><strong><code>allkeys-lru</code></strong></td><td style="text-align:left"><strong>通用场景，最常用</strong>。如果你的数据访问模式大致符合幂律分布（即一部分数据访问频率高，另一部分低），或者你不确定该用什么策略，选这个通常不会错。</td></tr><tr><td style="text-align:left"><strong><code>allkeys-lfu</code></strong></td><td style="text-align:left">你希望数据的访问频率对淘汰决策影响更大时。例如，一个key即使刚被访问过，但如果它历史上只被访问过一两次，而其他key被访问过成百上千次，那么它仍然可能被淘汰。</td></tr><tr><td style="text-align:left"><strong><code>volatile-ttl</code></strong></td><td style="text-align:left">你希望通过设置不同的TTL来主动管理数据的优先级，并且希望Redis优先淘汰那些快要过期的“临时”数据，保留那些TTL很长的核心数据。</td></tr><tr><td style="text-align:left"><strong><code>volatile-lru</code></strong> / <strong><code>volatile-lfu</code></strong></td><td style="text-align:left">你希望将 Redis 既用作缓存（有过期时间），又用作持久存储（无过期时间）。这样能保证永久数据不会被淘汰，只淘汰缓存数据。</td></tr><tr><td style="text-align:left"><strong><code>allkeys-random</code></strong> / <strong><code>volatile-random</code></strong></td><td style="text-align:left">所有数据被访问的概率都差不多，没有明显的热点数据。</td></tr><tr><td style="text-align:left"><strong><code>noeviction</code></strong></td><td style="text-align:left"><strong>不推荐用于缓存场景</strong>。适用于你希望数据永不被删除，并且内存足够或由应用层处理写失败的情况。</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">设置过期时间的key如何清除，以及未设置过期时间的key如何淘汰</summary>
    
    
    
    <category term="DB" scheme="https://pengline.github.io/categories/DB/"/>
    
    <category term="Redis" scheme="https://pengline.github.io/categories/DB/Redis/"/>
    
    
    <category term="Redis" scheme="https://pengline.github.io/tags/Redis/"/>
    
    <category term="Redis删除数据" scheme="https://pengline.github.io/tags/Redis%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title>Hexo + Butterfly 动态切换夜间模式</title>
    <link href="https://pengline.github.io/2025/08/15/fe387890751447178380123929a383e3/"/>
    <id>https://pengline.github.io/2025/08/15/fe387890751447178380123929a383e3/</id>
    <published>2025-08-14T16:00:00.000Z</published>
    <updated>2025-08-14T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>注意版本</strong>：框架 <a href="https://hexo.io/">Hexo 7.3.0</a>|主题 <a href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.4.3</a></p></blockquote><h2 id="JS脚本">JS脚本</h2><p>新建js脚本文件： <code>themes\butterfly\source\js\dark_mode.js</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">switchNightMode</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;body&#x27;</span>).<span class="title function_">insertAdjacentHTML</span>(<span class="string">&#x27;beforeend&#x27;</span>, <span class="string">&#x27;&lt;div class=&quot;Cuteen_DarkSky&quot;&gt;&lt;div class=&quot;Cuteen_DarkPlanet&quot;&gt;&lt;/div&gt;&lt;/div&gt;&#x27;</span>),</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;body&#x27;</span>).<span class="property">classList</span>.<span class="title function_">contains</span>(<span class="string">&#x27;DarkMode&#x27;</span>) ? (<span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;body&#x27;</span>).<span class="property">classList</span>.<span class="title function_">remove</span>(<span class="string">&#x27;DarkMode&#x27;</span>), <span class="variable language_">localStorage</span>.<span class="title function_">setItem</span>(<span class="string">&#x27;isDark&#x27;</span>, <span class="string">&#x27;0&#x27;</span>), <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;modeicon&#x27;</span>).<span class="title function_">setAttribute</span>(<span class="string">&#x27;xlink:href&#x27;</span>, <span class="string">&#x27;#icon-moon&#x27;</span>)) : (<span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;body&#x27;</span>).<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&#x27;DarkMode&#x27;</span>), <span class="variable language_">localStorage</span>.<span class="title function_">setItem</span>(<span class="string">&#x27;isDark&#x27;</span>, <span class="string">&#x27;1&#x27;</span>), <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;modeicon&#x27;</span>).<span class="title function_">setAttribute</span>(<span class="string">&#x27;xlink:href&#x27;</span>, <span class="string">&#x27;#icon-sun&#x27;</span>)),</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">          <span class="variable language_">document</span>.<span class="title function_">getElementsByClassName</span>(<span class="string">&#x27;Cuteen_DarkSky&#x27;</span>)[<span class="number">0</span>].<span class="property">style</span>.<span class="property">transition</span> = <span class="string">&#x27;opacity 3s&#x27;</span>;</span><br><span class="line">          <span class="variable language_">document</span>.<span class="title function_">getElementsByClassName</span>(<span class="string">&#x27;Cuteen_DarkSky&#x27;</span>)[<span class="number">0</span>].<span class="property">style</span>.<span class="property">opacity</span> = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">          <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">document</span>.<span class="title function_">getElementsByClassName</span>(<span class="string">&#x27;Cuteen_DarkSky&#x27;</span>)[<span class="number">0</span>].<span class="title function_">remove</span>();</span><br><span class="line">          &#125;, <span class="number">1e3</span>);</span><br><span class="line">        &#125;, <span class="number">2e3</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  <span class="keyword">const</span> nowMode = <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="title function_">getAttribute</span>(<span class="string">&#x27;data-theme&#x27;</span>) === <span class="string">&#x27;dark&#x27;</span> ? <span class="string">&#x27;dark&#x27;</span> : <span class="string">&#x27;light&#x27;</span></span><br><span class="line">  <span class="keyword">if</span> (nowMode === <span class="string">&#x27;light&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// 注意此处的版本不同，写法不同</span></span><br><span class="line">    btf.<span class="title function_">activateDarkMode</span>()</span><br><span class="line">    btf.<span class="property">saveToLocal</span>.<span class="title function_">set</span>(<span class="string">&#x27;theme&#x27;</span>, <span class="string">&#x27;dark&#x27;</span>, <span class="number">2</span>)</span><br><span class="line">    <span class="variable constant_">GLOBAL_CONFIG</span>.<span class="property">Snackbar</span> !== <span class="literal">undefined</span> &amp;&amp; btf.<span class="title function_">snackbarShow</span>(<span class="variable constant_">GLOBAL_CONFIG</span>.<span class="property">Snackbar</span>.<span class="property">day_to_night</span>)</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;modeicon&#x27;</span>).<span class="title function_">setAttribute</span>(<span class="string">&#x27;xlink:href&#x27;</span>, <span class="string">&#x27;#icon-sun&#x27;</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 注意此处的版本不同，写法不同</span></span><br><span class="line">    btf.<span class="title function_">activateLightMode</span>()</span><br><span class="line">    btf.<span class="property">saveToLocal</span>.<span class="title function_">set</span>(<span class="string">&#x27;theme&#x27;</span>, <span class="string">&#x27;light&#x27;</span>, <span class="number">2</span>)</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;body&#x27;</span>).<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&#x27;DarkMode&#x27;</span>), <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;modeicon&#x27;</span>).<span class="title function_">setAttribute</span>(<span class="string">&#x27;xlink:href&#x27;</span>, <span class="string">&#x27;#icon-moon&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// handle some cases</span></span><br><span class="line">  <span class="keyword">typeof</span> utterancesTheme === <span class="string">&#x27;function&#x27;</span> &amp;&amp; <span class="title function_">utterancesTheme</span>()</span><br><span class="line">  <span class="keyword">typeof</span> <span class="variable constant_">FB</span> === <span class="string">&#x27;object&#x27;</span> &amp;&amp; <span class="variable language_">window</span>.<span class="title function_">loadFBComment</span>()</span><br><span class="line">  <span class="variable language_">window</span>.<span class="property">DISQUS</span> &amp;&amp; <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;disqus_thread&#x27;</span>).<span class="property">children</span>.<span class="property">length</span> &amp;&amp; <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="variable language_">window</span>.<span class="title function_">disqusReset</span>(), <span class="number">200</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CSS渲染">CSS渲染</h2><p>新建styl文件：<code>themes\butterfly\source\css\_layout\dark_mode.styl</code></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.Cuteen_DarkSky</span>,</span><br><span class="line"><span class="selector-class">.Cuteen_DarkSky</span><span class="selector-pseudo">:before</span></span><br><span class="line">  <span class="attribute">content</span> &#x27;&#x27;</span><br><span class="line">  <span class="attribute">position</span> fixed</span><br><span class="line">  <span class="attribute">left</span> <span class="number">0</span></span><br><span class="line">  <span class="attribute">right</span> <span class="number">0</span></span><br><span class="line">  <span class="attribute">top</span> <span class="number">0</span></span><br><span class="line">  <span class="attribute">bottom</span> <span class="number">0</span></span><br><span class="line">  <span class="attribute">z-index</span> <span class="number">88888888</span></span><br><span class="line"></span><br><span class="line"><span class="selector-class">.Cuteen_DarkSky</span></span><br><span class="line">  <span class="attribute">background</span> linear-gradient(<span class="selector-id">#feb8b0</span>, <span class="selector-id">#fef9db</span>)</span><br><span class="line">  &amp;<span class="selector-pseudo">:before</span></span><br><span class="line">    <span class="attribute">transition</span> <span class="number">2s</span> ease <span class="attribute">all</span></span><br><span class="line">    <span class="attribute">opacity</span> <span class="number">0</span></span><br><span class="line">    <span class="attribute">background</span> linear-gradient(<span class="selector-id">#4c3f6d</span>, <span class="selector-id">#6c62bb</span>, <span class="selector-id">#93b1ed</span>)</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.DarkMode</span></span><br><span class="line">  <span class="selector-class">.Cuteen_DarkSky</span></span><br><span class="line">    &amp;<span class="selector-pseudo">:before</span></span><br><span class="line">      <span class="attribute">opacity</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="selector-class">.Cuteen_DarkPlanet</span></span><br><span class="line">  <span class="attribute">z-index</span> <span class="number">99999999</span></span><br><span class="line">  <span class="attribute">position</span> fixed</span><br><span class="line">  <span class="attribute">left</span> -<span class="number">50%</span></span><br><span class="line">  <span class="attribute">top</span> -<span class="number">50%</span></span><br><span class="line">  <span class="attribute">width</span> <span class="number">200%</span></span><br><span class="line">  <span class="attribute">height</span> <span class="number">200%</span></span><br><span class="line">  -webkit-<span class="attribute">animation</span> CuteenPlanetMove <span class="number">2s</span> cubic-bezier(<span class="number">0.7</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">  <span class="attribute">animation</span> CuteenPlanetMove <span class="number">2s</span> cubic-bezier(<span class="number">0.7</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">  <span class="attribute">transform-origin</span> center <span class="attribute">bottom</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">@-webkit-keyframes</span> CuteenPlanetMove &#123;</span><br><span class="line">  <span class="number">0%</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-tag">to</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">360deg</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@keyframes</span> CuteenPlanetMove &#123;</span><br><span class="line">  <span class="number">0%</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-tag">to</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">360deg</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.Cuteen_DarkPlanet</span></span><br><span class="line">  &amp;<span class="selector-pseudo">:after</span></span><br><span class="line">    <span class="attribute">position</span> absolute</span><br><span class="line">    <span class="attribute">left</span> <span class="number">35%</span></span><br><span class="line">    <span class="attribute">top</span> <span class="number">40%</span></span><br><span class="line">    <span class="attribute">width</span> <span class="number">9.375rem</span></span><br><span class="line">    <span class="attribute">height</span> <span class="number">9.375rem</span></span><br><span class="line">    <span class="attribute">border-radius</span> <span class="number">50%</span></span><br><span class="line">    <span class="attribute">content</span> &#x27;&#x27;</span><br><span class="line">    <span class="attribute">background</span> linear-gradient(<span class="selector-id">#fefefe</span>, <span class="selector-id">#fffbe8</span>)</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.search</span></span><br><span class="line">  <span class="selector-tag">span</span></span><br><span class="line">    <span class="attribute">display</span> <span class="attribute">none</span></span><br><span class="line"></span><br><span class="line"><span class="selector-class">.menus_item</span></span><br><span class="line">  <span class="selector-tag">a</span></span><br><span class="line">    <span class="attribute">text-decoration</span> <span class="attribute">none</span>!important</span><br><span class="line">//按钮相关，对侧栏按钮做过魔改的可以调整这里的数值</span><br><span class="line"><span class="selector-class">.icon-V</span></span><br><span class="line">  <span class="attribute">padding</span> <span class="number">5px</span></span><br></pre></td></tr></table></figure><h2 id="模板引擎-pug">模板引擎 pug</h2><p>新建pug文件：<code>themes\butterfly\layout\includes\custom\dark_mode.pug</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">svg(aria-hidden=&#x27;true&#x27;, style=&#x27;position:absolute; overflow:hidden; width:0; height:0&#x27;)</span><br><span class="line">  symbol#icon-sun(viewBox=&#x27;0 0 1024 1024&#x27;)</span><br><span class="line">    path(d=&#x27;M960 512l-128 128v192h-192l-128 128-128-128H192v-192l-128-128 128-128V192h192l128-128 128 128h192v192z&#x27;, fill=&#x27;#FFD878&#x27;, p-id=&#x27;8420&#x27;)</span><br><span class="line">    path(d=&#x27;M736 512a224 224 0 1 0-448 0 224 224 0 1 0 448 0z&#x27;, fill=&#x27;#FFE4A9&#x27;, p-id=&#x27;8421&#x27;)</span><br><span class="line">    path(d=&#x27;M512 109.248L626.752 224H800v173.248L914.752 512 800 626.752V800h-173.248L512 914.752 397.248 800H224v-173.248L109.248 512 224 397.248V224h173.248L512 109.248M512 64l-128 128H192v192l-128 128 128 128v192h192l128 128 128-128h192v-192l128-128-128-128V192h-192l-128-128z&#x27;, fill=&#x27;#4D5152&#x27;, p-id=&#x27;8422&#x27;)</span><br><span class="line">    path(d=&#x27;M512 320c105.888 0 192 86.112 192 192s-86.112 192-192 192-192-86.112-192-192 86.112-192 192-192m0-32a224 224 0 1 0 0 448 224 224 0 0 0 0-448z&#x27;, fill=&#x27;#4D5152&#x27;, p-id=&#x27;8423&#x27;)</span><br><span class="line">  symbol#icon-moon(viewBox=&#x27;0 0 1024 1024&#x27;)</span><br><span class="line">    path(d=&#x27;M611.370667 167.082667a445.013333 445.013333 0 0 1-38.4 161.834666 477.824 477.824 0 0 1-244.736 244.394667 445.141333 445.141333 0 0 1-161.109334 38.058667 85.077333 85.077333 0 0 0-65.066666 135.722666A462.08 462.08 0 1 0 747.093333 102.058667a85.077333 85.077333 0 0 0-135.722666 65.024z&#x27;, fill=&#x27;#FFB531&#x27;, p-id=&#x27;11345&#x27;)</span><br><span class="line">    path(d=&#x27;M329.728 274.133333l35.157333-35.157333a21.333333 21.333333 0 1 0-30.165333-30.165333l-35.157333 35.157333-35.114667-35.157333a21.333333 21.333333 0 0 0-30.165333 30.165333l35.114666 35.157333-35.114666 35.157334a21.333333 21.333333 0 1 0 30.165333 30.165333l35.114667-35.157333 35.157333 35.157333a21.333333 21.333333 0 1 0 30.165333-30.165333z&#x27;, fill=&#x27;#030835&#x27;, p-id=&#x27;11346&#x27;)</span><br></pre></td></tr></table></figure><h2 id="引入依赖">引入依赖</h2><p>修改文件：<code>themes\butterfly\layout\includes\head.pug</code></p><p>在末尾加入：<code>include ./custom/dark_mode.pug</code></p><h2 id="触发切换">触发切换</h2><p>修改文件：<code>themes\butterfly\layout\includes\rightside.pug</code></p><p><strong>修改前</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">when &#x27;darkmode&#x27;</span><br><span class="line">  if darkmode.enable &amp;&amp; darkmode.button</span><br><span class="line">     button#darkmode(type=&quot;button&quot; title=_p(&#x27;rightside.night_mode_title&#x27;))</span><br><span class="line">       i.fas.fa-adjust</span><br></pre></td></tr></table></figure><p><strong>修改后</strong>：注意缩进，需要使用空格，而不是Tab</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">when &#x27;darkmode&#x27;</span><br><span class="line">  if darkmode.enable &amp;&amp; darkmode.button</span><br><span class="line">    a.icon-V.hidden(onclick=&#x27;switchNightMode()&#x27;,  title=_p(&#x27;rightside.night_mode_title&#x27;))</span><br><span class="line">      svg(width=&#x27;25&#x27;, height=&#x27;25&#x27;, viewBox=&#x27;0 0 1024 1024&#x27;)</span><br><span class="line">        use#modeicon(xlink:href=&#x27;#icon-moon&#x27;)</span><br></pre></td></tr></table></figure><h2 id="配置修改">配置修改</h2><p>修改butterfly的配置文件：<code>themes\butterfly\_config.yml</code>，将 JS 引入其中：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">inject:</span></span><br><span class="line">  <span class="attr">bottom:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&lt;script</span> <span class="string">src=&quot;/js/dark_mode.js&quot;</span> <span class="string">async&gt;&lt;/script&gt;</span></span><br></pre></td></tr></table></figure><h2 id="启动测试">启动测试</h2><p>运行命令：<code>hexo clean &amp;&amp; hexo g &amp;&amp; hexo s</code></p>]]></content>
    
    
    <summary type="html">Hexo + Butterfly 实现切换夜间模式的动画效果</summary>
    
    
    
    <category term="Tools" scheme="https://pengline.github.io/categories/Tools/"/>
    
    <category term="Hexo" scheme="https://pengline.github.io/categories/Tools/Hexo/"/>
    
    
    <category term="Hexo" scheme="https://pengline.github.io/tags/Hexo/"/>
    
    <category term="Butterfly夜间模式" scheme="https://pengline.github.io/tags/Butterfly%E5%A4%9C%E9%97%B4%E6%A8%A1%E5%BC%8F/"/>
    
    <category term="Hexo夜间模式" scheme="https://pengline.github.io/tags/Hexo%E5%A4%9C%E9%97%B4%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>同时配置 Github 和 Gitee 的 SSH 免密提交</title>
    <link href="https://pengline.github.io/2025/08/14/b1cb29e686e347279ef8bd70ec59e09b/"/>
    <id>https://pengline.github.io/2025/08/14/b1cb29e686e347279ef8bd70ec59e09b/</id>
    <published>2025-08-13T16:00:00.000Z</published>
    <updated>2025-08-19T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="清除-git-的全局设置">清除 git 的全局设置</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看是否设置</span></span><br><span class="line">git config --global --list</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 删除设置</span></span><br><span class="line">git config --global --<span class="built_in">unset</span> user.name</span><br><span class="line">git config --global --<span class="built_in">unset</span> user.email</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看配置来源(本地配置覆盖全局配置)</span></span><br><span class="line">git config --list --show-origin</span><br></pre></td></tr></table></figure><h2 id="Windows-中配置">Windows 中配置</h2><h3 id="配置多个-SSH-密钥"><strong>配置多个 SSH 密钥</strong></h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 为 GitHub 生成 SSH 密钥</span></span><br><span class="line">ssh-keygen -t rsa -f %USERPROFILE%/.ssh/id_rsa_github -C <span class="string">&quot;your_email@github.com&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 为 Gitee 生成 SSH 密钥</span></span><br><span class="line">ssh-keygen -t rsa -f %USERPROFILE%/.ssh/id_rsa_gitee -C <span class="string">&quot;your_email@gitee.com&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p>完成后会在 <code>C:/Users/xxx/.ssh /</code> 目录下生成以下文件</p><ul class="lvl-1"><li class="lvl-2">id_rsa_github</li><li class="lvl-2">id_rsa_github.pub</li><li class="lvl-2">id_rsa_gitee</li><li class="lvl-2">id_rsa_gitee.pub</li></ul><p>将生成的对应.pub文件打开，将数据拷贝添加到对应平台的SSH配置中（全量拷贝）</p><p>如：id_rsa_github.pub 中的全部内容，拷贝到github 的SSH配置中</p></blockquote><h3 id="配置-SSH-Config-文件">配置 SSH Config 文件</h3><p>在 <code>C:/Users/xxx/.ssh/config</code> 文件中添加以下内容，以区分不同平台的密钥：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Gitee</span></span><br><span class="line">Host gitee.com</span><br><span class="line">HostName gitee.com</span><br><span class="line">User git</span><br><span class="line">IdentitiesOnly yes</span><br><span class="line">IdentityFile C:/Users/xxx/.ssh/id_rsa_gitee</span><br><span class="line"></span><br><span class="line"><span class="comment"># GitHub</span></span><br><span class="line">Host github.com</span><br><span class="line">AddKeysToAgent yes</span><br><span class="line">IdentitiesOnly yes</span><br><span class="line">PubkeyAuthentication yes</span><br><span class="line">HostName github.com</span><br><span class="line">User git</span><br><span class="line">IdentityFile C:/Users/xxx/.ssh/id_rsa_github</span><br></pre></td></tr></table></figure><blockquote><p>验证是否生效（在任意路径）：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@gitee.com</span><br><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><p>出现以下情况，表示成功，否则配置错误（IdentityFile需要绝对路径）：</p><p><code>Hi xxx! You've successfully authenticated, but GitHub does not provide shell access.</code></p></blockquote><h3 id="配置文件权限">配置文件权限</h3><p>config 、id_rsa_github和 id_rsa_gitee 配置文件需要删除其他用户的权限，只保留管理员和当前用户</p><blockquote><ol><li class="lvl-3"><p>右键需配置的文件，查看属性，打开“安全”一栏</p></li><li class="lvl-3"><p>打开“高级” ，“禁用继承”</p></li><li class="lvl-3"><p>返回，在“安全”一栏的“组或用户名” 中，删除非当前用户和系统管理员的账号，如：Everyone<img src="/imgs/image-20250824120719000.png" alt="image-20250824120719000"></p></li></ol></blockquote><h2 id="Linux-中配置">Linux 中配置</h2><h3 id="配置多个-SSH-密钥-2">配置多个 SSH 密钥</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 为 GitHub 生成 SSH 密钥</span></span><br><span class="line">ssh-keygen -t rsa -f ~/.ssh/id_rsa_github -C <span class="string">&quot;your_email@github.com&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 为 Gitee 生成 SSH 密钥</span></span><br><span class="line">ssh-keygen -t rsa -f ~/.ssh/id_rsa_gitee -C <span class="string">&quot;your_email@gitee.com&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p>完成后会在~/.ssh / 目录下生成以下文件</p><ul class="lvl-1"><li class="lvl-2">id_rsa_github</li><li class="lvl-2">id_rsa_github.pub</li><li class="lvl-2">id_rsa_gitee</li><li class="lvl-2">id_rsa_gitee.pub</li></ul><p>将生成的对应.pub文件打开，将数据拷贝添加到对应平台的SSH配置中（全量拷贝）</p><p>如：id_rsa_github.pub 中的全部内容，拷贝到github 的SSH配置中</p></blockquote><h3 id="配置-SSH-Config-文件-2">配置 SSH Config 文件</h3><p>在 <code>~/.ssh/config</code> 文件中添加以下内容，以区分不同平台的密钥：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Gitee</span></span><br><span class="line">Host gitee.com</span><br><span class="line">HostName gitee.com</span><br><span class="line">User git</span><br><span class="line">IdentitiesOnly yes</span><br><span class="line">IdentityFile ~/.ssh/id_rsa_gitee</span><br><span class="line"></span><br><span class="line"><span class="comment"># GitHub</span></span><br><span class="line">Host github.com</span><br><span class="line">AddKeysToAgent yes</span><br><span class="line">IdentitiesOnly yes</span><br><span class="line">PubkeyAuthentication yes</span><br><span class="line">HostName github.com</span><br><span class="line">User git</span><br><span class="line">IdentityFile ~/.ssh/id_rsa_github</span><br></pre></td></tr></table></figure><blockquote><p>验证是否生效（在任意路径）：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@gitee.com</span><br><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><p>出现以下情况，表示成功，否则配置错误（IdentityFile需要绝对路径）：</p><p><code>Hi xxx! You've successfully authenticated, but GitHub does not provide shell access.</code></p></blockquote><h3 id="配置文件权限-2">配置文件权限</h3><p>config 、id_rsa_github和 id_rsa_gitee 配置文件需要删除其他用户的权限</p><p><code>chmod 644 ~/.ssh/config</code></p><h2 id="同时推送多个远程仓库">同时推送多个远程仓库</h2><p>在本地项目中，可以同时关联 Gitee 和 GitHub 的远程仓库：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加 GitHub 远程仓库</span></span><br><span class="line">git remote add github git@github.com:username/boot-demo.git</span><br><span class="line"><span class="comment"># 推送到 GitHub</span></span><br><span class="line">git push github master</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加 Gitee 远程仓库</span></span><br><span class="line">git remote add gitee git@gitee.com:username/boot-demo.git</span><br><span class="line"><span class="comment"># 推送到 Gitee</span></span><br><span class="line">git push gitee master</span><br></pre></td></tr></table></figure><h2 id="仅推送单个远程仓库">仅推送单个远程仓库</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果只推送其中一个 github 仓库</span></span><br><span class="line">git branch -M main</span><br><span class="line">git remote add origin git@github.com:username/boot-demo.git</span><br><span class="line">git push -u origin main</span><br></pre></td></tr></table></figure><h2 id="同时配置多个-Github-账号">同时配置多个 Github 账号</h2><p>详细教程和说明，可参考：<a href="https://segmentfault.com/a/1190000043924833">博客</a></p><p>以 Linux 环境为例，再以上的基础上再添加一个 github 的账号配置</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 为 GitHub 生成 SSH 密钥</span></span><br><span class="line">ssh-keygen -t rsa -f ~/.ssh/id_rsa_github_blog -C <span class="string">&quot;your_email@github.com&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p>完成后会在~/.ssh / 目录下生成以下文件</p><ul class="lvl-1"><li class="lvl-2">id_rsa_github_blog</li><li class="lvl-2">id_rsa_github_blog.pub</li></ul><p>将生成的 id_rsa_github_blog.pub 文件打开，将数据拷贝添加到github平台的SSH配置中（全量拷贝）</p></blockquote><p>在 <code>~/.ssh/config</code> 文件中添加以下内容（注意区分Host）：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># GitHub</span></span><br><span class="line">Host github_blog</span><br><span class="line">AddKeysToAgent yes</span><br><span class="line">IdentitiesOnly yes</span><br><span class="line">PubkeyAuthentication yes</span><br><span class="line">HostName github.com</span><br><span class="line">User git</span><br><span class="line">IdentityFile ~/.ssh/id_rsa_github_blog</span><br></pre></td></tr></table></figure><p><strong>推送仓库</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注意：修改为上面配置中对应的 Host，否则会定向到之前的配置中</span></span><br><span class="line">git remote add blog git@github_blog:username/boot-demo.git</span><br><span class="line">git push -u blog main</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看会显示存在三个仓库（github、gitee、blog）</span></span><br><span class="line">git remote -v</span><br></pre></td></tr></table></figure><h2 id="SSH-连接异常（提交失败）">SSH 连接异常（提交失败）</h2><p>Git 提交时报错：</p><blockquote><p>ssh: connect to host <a href="http://github.com">github.com</a> port 22: Connection timed out<br>fatal: Could not read from remote repository.</p></blockquote><p>用以下三个命令测试，均无法连接</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br><span class="line">ping github.com</span><br><span class="line">telnet github.com 22</span><br></pre></td></tr></table></figure><p><strong>解决方法</strong>：</p><p>修改<code>~/.ssh/config</code> 配置，Port 改为 443，HostName  改为 <a href="http://ssh.github.com">ssh.github.com</a></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># GitHub</span></span><br><span class="line">Host github.com</span><br><span class="line">AddKeysToAgent yes</span><br><span class="line">IdentitiesOnly yes</span><br><span class="line">PubkeyAuthentication yes</span><br><span class="line">HostName ssh.github.com</span><br><span class="line">    Port 443</span><br><span class="line">User git</span><br><span class="line">IdentityFile ~/.ssh/id_rsa_github</span><br><span class="line">    </span><br><span class="line"><span class="comment"># GitHub</span></span><br><span class="line">Host github_blog</span><br><span class="line">AddKeysToAgent yes</span><br><span class="line">IdentitiesOnly yes</span><br><span class="line">PubkeyAuthentication yes</span><br><span class="line">HostName ssh.github.com</span><br><span class="line">    Port 443</span><br><span class="line">User git</span><br><span class="line">IdentityFile ~/.ssh/id_rsa_github_blog</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">在一台电脑中，同时配置 Github 和 Gitee 等多账户的 SSH 免密登录提交方法</summary>
    
    
    
    <category term="Tools" scheme="https://pengline.github.io/categories/Tools/"/>
    
    <category term="Git" scheme="https://pengline.github.io/categories/Tools/Git/"/>
    
    
    <category term="github" scheme="https://pengline.github.io/tags/github/"/>
    
    <category term="gitee" scheme="https://pengline.github.io/tags/gitee/"/>
    
    <category term="git-ssh" scheme="https://pengline.github.io/tags/git-ssh/"/>
    
  </entry>
  
</feed>
