<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Java 多线程之线程池原理与使用指南 | 余一叶知秋尽</title><meta name="author" content="余一叶知秋尽"><meta name="copyright" content="余一叶知秋尽"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="介绍几种线程池的基本概念、使用案例以及注意事项，和各自的底层原理实现。">
<meta property="og:type" content="article">
<meta property="og:title" content="Java 多线程之线程池原理与使用指南">
<meta property="og:url" content="https://pengline.github.io/2025/09/10/366f9754e67846f0b38a4354a634b75f/index.html">
<meta property="og:site_name" content="余一叶知秋尽">
<meta property="og:description" content="介绍几种线程池的基本概念、使用案例以及注意事项，和各自的底层原理实现。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.toopic.cn/public/uploads/small/175514400277175514400262.jpg">
<meta property="article:published_time" content="2025-09-09T16:00:00.000Z">
<meta property="article:modified_time" content="2025-09-11T05:37:49.810Z">
<meta property="article:author" content="余一叶知秋尽">
<meta property="article:tag" content="Java多线程">
<meta property="article:tag" content="ThreadPoolExecutor">
<meta property="article:tag" content="线程池">
<meta property="article:tag" content="Executors">
<meta property="article:tag" content="VirtualThreadPerTask">
<meta property="article:tag" content="WorkStealingPool">
<meta property="article:tag" content="ForkJoinTask">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.toopic.cn/public/uploads/small/175514400277175514400262.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Java 多线程之线程池原理与使用指南",
  "url": "https://pengline.github.io/2025/09/10/366f9754e67846f0b38a4354a634b75f/",
  "image": "https://www.toopic.cn/public/uploads/small/175514400277175514400262.jpg",
  "datePublished": "2025-09-09T16:00:00.000Z",
  "dateModified": "2025-09-11T05:37:49.810Z",
  "author": [
    {
      "@type": "Person",
      "name": "余一叶知秋尽",
      "url": "https://pengline.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://pengline.github.io/2025/09/10/366f9754e67846f0b38a4354a634b75f/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java 多线程之线程池原理与使用指南',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/css/font.css"><svg aria-hidden="true" style="position:absolute; overflow:hidden; width:0; height:0"><symbol id="icon-sun" viewBox="0 0 1024 1024"><path d="M960 512l-128 128v192h-192l-128 128-128-128H192v-192l-128-128 128-128V192h192l128-128 128 128h192v192z" fill="#FFD878" p-id="8420"></path><path d="M736 512a224 224 0 1 0-448 0 224 224 0 1 0 448 0z" fill="#FFE4A9" p-id="8421"></path><path d="M512 109.248L626.752 224H800v173.248L914.752 512 800 626.752V800h-173.248L512 914.752 397.248 800H224v-173.248L109.248 512 224 397.248V224h173.248L512 109.248M512 64l-128 128H192v192l-128 128 128 128v192h192l128 128 128-128h192v-192l128-128-128-128V192h-192l-128-128z" fill="#4D5152" p-id="8422"></path><path d="M512 320c105.888 0 192 86.112 192 192s-86.112 192-192 192-192-86.112-192-192 86.112-192 192-192m0-32a224 224 0 1 0 0 448 224 224 0 0 0 0-448z" fill="#4D5152" p-id="8423"></path></symbol><symbol id="icon-moon" viewBox="0 0 1024 1024"><path d="M611.370667 167.082667a445.013333 445.013333 0 0 1-38.4 161.834666 477.824 477.824 0 0 1-244.736 244.394667 445.141333 445.141333 0 0 1-161.109334 38.058667 85.077333 85.077333 0 0 0-65.066666 135.722666A462.08 462.08 0 1 0 747.093333 102.058667a85.077333 85.077333 0 0 0-135.722666 65.024z" fill="#FFB531" p-id="11345"></path><path d="M329.728 274.133333l35.157333-35.157333a21.333333 21.333333 0 1 0-30.165333-30.165333l-35.157333 35.157333-35.114667-35.157333a21.333333 21.333333 0 0 0-30.165333 30.165333l35.114666 35.157333-35.114666 35.157334a21.333333 21.333333 0 1 0 30.165333 30.165333l35.114667-35.157333 35.157333 35.157333a21.333333 21.333333 0 1 0 30.165333-30.165333z" fill="#030835" p-id="11346"></path></symbol></svg><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="余一叶知秋尽" type="application/atom+xml">
</head><body><div id="web_bg" style="background-image: url(/img/rqerwc4u0er.jpg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src= "/img/20241215205335173426721579192.jpg" data-lazy-src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">17</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">76</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">22</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> AI</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/ai/aigc/image/"><i class="fa-fw fas fa-image"></i><span> AIGC Image</span></a></li><li><a class="site-page child" href="/ai/aigc/music/"><i class="fa-fw fas fa-music"></i><span> AIGC Music</span></a></li><li><a class="site-page child" href="/ai/aigc/video/"><i class="fa-fw fas fa-video"></i><span> AIGC Video</span></a></li><li><a class="site-page child" href="/ai/agent/medical/"><i class="fa-fw fas fa-medkit"></i><span> Medical Agent</span></a></li><li><a class="site-page child" href="/ai/agent/stocks/"><i class="fa-fw fas fa-line-chart"></i><span> Stocks Agent</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fas fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://www.toopic.cn/public/uploads/small/175514400277175514400262.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src= "/img/20241215205335173426721579192.jpg" data-lazy-src="/img/logo.png" alt="Logo"><span class="site-name">余一叶知秋尽</span></a><a class="nav-page-title" href="/"><span class="site-name">Java 多线程之线程池原理与使用指南</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> AI</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/ai/aigc/image/"><i class="fa-fw fas fa-image"></i><span> AIGC Image</span></a></li><li><a class="site-page child" href="/ai/aigc/music/"><i class="fa-fw fas fa-music"></i><span> AIGC Music</span></a></li><li><a class="site-page child" href="/ai/aigc/video/"><i class="fa-fw fas fa-video"></i><span> AIGC Video</span></a></li><li><a class="site-page child" href="/ai/agent/medical/"><i class="fa-fw fas fa-medkit"></i><span> Medical Agent</span></a></li><li><a class="site-page child" href="/ai/agent/stocks/"><i class="fa-fw fas fa-line-chart"></i><span> Stocks Agent</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fas fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Java 多线程之线程池原理与使用指南</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-09-09T16:00:00.000Z" title="发表于 2025-09-10 00:00:00">2025-09-10</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-09-11T05:37:49.810Z" title="更新于 2025-09-11 13:37:49">2025-09-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/">Java</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>使用线程池的优点：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>降低资源消耗</strong>：通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</p>
</li>
<li class="lvl-2">
<p><strong>提高响应速度</strong>：当任务到达时，任务可以不需要等到线程创建就能立即执行。</p>
</li>
<li class="lvl-2">
<p><strong>提高线程的可管理性</strong>：线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控。</p>
</li>
</ul>
<blockquote>
<p>所有线程池都基于 <code>java.util.concurrent.ThreadPoolExecutor</code>，底层是操作系统线程（Platform Threads），创建和切换成本高，需池化复用。</p>
<p>Java 21 引入了虚拟线程（Virtual Threads），让“一个任务一个线程”成为 I/O 场景的最佳实践。</p>
</blockquote>
<h2 id="线程池概念结构">线程池概念结构</h2>
<h3 id="核心组件">核心组件</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>核心线程数（<strong>corePoolSize</strong>）：线程池中常驻的线程数量，即使空闲也不会被回收（除非设置 <code>allowCoreThreadTimeOut(true)</code>）。</p>
</li>
<li class="lvl-2">
<p>最大线程数（<strong>maximumPoolSize</strong>）：线程池允许创建的最大线程数量。当任务队列满且当前线程数 &lt; maximumPoolSize 时，会创建非核心线程执行任务。</p>
</li>
<li class="lvl-2">
<p>非核心线程的存活时长（<strong>keepAliveTime</strong>）：非核心线程在空闲时的存活时间。超过该时间将被回收。</p>
</li>
<li class="lvl-2">
<p>工作队列（<strong>BlockingQueue</strong><Runnable>）：当核心线程都在忙时，新任务会被放入队列等待。</p>
<ul class="lvl-2">
<li class="lvl-4"><code>LinkedBlockingQueue</code>：无界队列（默认不设上限，易 OOM）</li>
<li class="lvl-4"><code>ArrayBlockingQueue</code>：有界队列</li>
<li class="lvl-4"><code>SynchronousQueue</code>：不存储元素，直接移交任务给线程（常用于 CachedThreadPool）</li>
<li class="lvl-4"><code>PriorityBlockingQueue</code>：优先级队列</li>
</ul>
</li>
<li class="lvl-2">
<p>拒绝策略（<strong>RejectedExecutionHandler</strong>）：当线程池和队列都满了，如何处理新提交的任务，常见策略有：</p>
<ul class="lvl-2">
<li class="lvl-4"><strong>AbortPolicy</strong>： 它将直接抛出RejectedExecutionException（默认）</li>
<li class="lvl-4"><strong>CallerRunsPolicy</strong>： 它直接在execute方法的调用线程中运行被拒绝的任务。如果执行程序已关闭，则会丢弃该任务</li>
<li class="lvl-4"><strong>DiscardOldestPolicy</strong>： 它放弃最旧的未处理请求，然后重试execute执行当前任务。</li>
<li class="lvl-4"><strong>DiscardPolicy</strong>： 默认情况下它将丢弃被拒绝的任务。</li>
</ul>
</li>
</ul>
<h3 id="执行流程">执行流程</h3>
<img src= "/img/20241215205335173426721579192.jpg" data-lazy-src="/imgs/868f71cd0007cc74fd9bd0b963619a51.png" alt="深入理解线程池（详解）_线程池的工作原理-CSDN博客" style="zoom: 50%;" />
<blockquote>
<p>1.查看核心线程池是否已满，不满就创建一条线程执行任务，否则执行第二步。</p>
<p>2.查看任务队列是否已满，不满就将任务存储在任务队列中，否则执行第三步。</p>
<p>3.查看线程池是否已满，即是否达到最大线程池数，不满就创建一条线程执行任务，否则就按照策略处理无法执行的任务。</p>
<p>4.当线程池中的线程数量大于核心线程时，如果某线程空闲时间超过<strong>keepAliveTime</strong>，线程将被终止。这样，线程池可以动态的调整池中的线程数。</p>
<p>5.当设置<strong>allowCoreThreadTimeOut</strong>(true)时，线程池中corePoolSize线程空闲时间达到<strong>keepAliveTime</strong>也将关闭</p>
</blockquote>
<h3 id="线程池状态">线程池状态</h3>
<p>线程池的状态和线程的状态是完全不同的，线程池的状态有以下 5 种：</p>
<ol>
<li class="lvl-3">
<p><strong>running</strong>：运行状态，线程池创建好后会进入此状态，如不手动调用关闭方法，那线程池在整个程序运行期间都是此状态。</p>
</li>
<li class="lvl-3">
<p><strong>shutdown</strong>：关闭状态，不再接受新任务提交，但是会将已保存在任务队列中的任务处理完。</p>
</li>
<li class="lvl-3">
<p><strong>stop</strong>：停止状态，不再接受新任务提交，并且会中断当前正在执行的任务、放弃任务队列中已有的任务。</p>
</li>
<li class="lvl-3">
<p><strong>tidying</strong>：整理状态，所有的任务都执行完毕后（也包括任务队列中的任务执行完），当前线程池中的活动线程数降为 0 时的状态。到此状态之后，会调用线程池的 terminated() 方法。</p>
</li>
<li class="lvl-3">
<p><strong>terminated</strong>：销毁状态，当执行完线程池的 terminated() 方法之后就会变为此状态。</p>
</li>
</ol>
<p><img src= "/img/20241215205335173426721579192.jpg" data-lazy-src="/imgs/image-20240705162257743.png" alt="image-20240705162257743"></p>
<img src= "/img/20241215205335173426721579192.jpg" data-lazy-src="/imgs/620cc55cd9c0f63fc7aa1ddaaee8812d.png" alt="image.png" style="zoom:37%;" />
<blockquote>
<ul class="lvl-1">
<li class="lvl-2">
<p>shutdown()  不再接收新的任务，但是现有任务继续，且队列中等候的线程也将会执行。除非内部有停止标识</p>
</li>
<li class="lvl-2">
<p>shutdownNow()  不再接收新的任务，但是现有任务继续，队列中等候的线程不会再执行，将交给外部线程处理</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      checkShutdownAccess();        </span><br><span class="line">      advanceRunState(SHUTDOWN);    </span><br><span class="line">      interruptIdleWorkers();        </span><br><span class="line">      onShutdown(); </span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    tryTerminate();    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> List&lt;Runnable&gt; <span class="title function_">shutdownNow</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;Runnable&gt; tasks;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      checkShutdownAccess();</span><br><span class="line">      advanceRunState(STOP);</span><br><span class="line">      interruptWorkers();</span><br><span class="line">      tasks = drainQueue();    </span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    tryTerminate();</span><br><span class="line">    <span class="keyword">return</span> tasks;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>
<p>重写 terminated() 方法，销毁前执行一些其他操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolStateTransition</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">      <span class="type">ThreadPoolExecutor</span> <span class="variable">threadPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">10</span>, <span class="number">10</span>, <span class="number">0L</span>,</span><br><span class="line">              TimeUnit.SECONDS, <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="number">100</span>)) &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">terminated</span><span class="params">()</span> &#123;</span><br><span class="line">              <span class="built_in">super</span>.terminated();</span><br><span class="line">              System.out.println(<span class="string">&quot;执行 terminated() 方法&quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      threadPool.shutdown();</span><br><span class="line">      <span class="keyword">while</span> (!threadPool.awaitTermination(<span class="number">1</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;线程池正在运行中&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="线程池体系结构">线程池体系结构</h3>
<p><code>java.util.concurrent.Executor</code>: 负责线程的使用和调度的根接口;</p>
<blockquote>
<ul class="lvl-1">
<li class="lvl-2">
<p><code>ExecutorService</code>: 子接口,线程池的主要接口;</p>
<ul class="lvl-3">
<li class="lvl-4"><code>AbstractExecutorService</code>: 接口抽象类，维护了通用方法：线程提交和运行
<ul class="lvl-5">
<li class="lvl-6"><code>ThreadPoolExecutor</code>: 线程池的实现类; 维护了线程池参数、状态、等待队列、锁和方法实现</li>
<li class="lvl-6"><code>ForkJoinPool</code>:并行线程池的实现类; 维护了线程池参数、状态、等待队列、工作线程</li>
<li class="lvl-6"><code>DelegatedExecutorService</code>:</li>
</ul>
</li>
</ul>
</li>
<li class="lvl-2">
<p><code>ScheduledExecutorService</code>: 子接口,负责线程的调度;</p>
<ul class="lvl-3">
<li class="lvl-4"><code>ScheduledThreadPoolExecutor</code>: 继承了线程池的实现类,实现了负责线程调度的子接口;</li>
</ul>
</li>
</ul>
</blockquote>
<p>工具类:    Executors（<font color=red>慎用</font>：最大线程数过大，队列大小未做限制，会导致CPU和内存占用过大出现服务宕机问题）</p>
<blockquote>
<ul class="lvl-1">
<li class="lvl-2">
<p><code>ExecutorService=Executors.newFixedThreadPool()</code>: <strong>固定大小</strong>线程池（<strong>核心=最大=n</strong>）;</p>
</li>
<li class="lvl-2">
<p><code>ExecutorService=Executors.newCachedThreadPool()</code>: <strong>缓存</strong>线程池，<strong>核心=0，最大=MAX_INT</strong>，没有核心线程数;</p>
</li>
<li class="lvl-2">
<p><code>ExecutorService=Executors.newSingleThreadExecutor()</code>: <strong>单个</strong>线程池, 线程池只有一个线程<strong>核心=最大=1</strong>;</p>
</li>
<li class="lvl-2">
<p><code>ExecutorService=Executors.newWorkStealingPool()</code>:  <strong>并行</strong>线程池，默认核心大小为<strong>CPU核数</strong>（Runtime.getRuntime().availableProcessors()），最大默认 256</p>
</li>
<li class="lvl-2">
<p><code>ScheduledExecutorService=Executors.newScheduledThreadPool()</code>: <strong>延时或定时</strong>的执行任务，<strong>核心=n，最大=MAX_INT</strong>;</p>
</li>
</ul>
</blockquote>
<p>spring 提供的 线程池</p>
<blockquote>
<p>TaskExecutor 接口</p>
<ul class="lvl-1">
<li class="lvl-2">
<p>AsyncTaskExecutor 接口</p>
<ul class="lvl-3">
<li class="lvl-4">
<p>SchedulingTaskExecutor 接口</p>
<ul class="lvl-5">
<li class="lvl-6">
<p>ThreadPoolTaskExecutor</p>
</li>
<li class="lvl-6">
<p>ThreadPoolTaskScheduler</p>
</li>
<li class="lvl-6">
<p>ConcurrentTaskExecutor</p>
</li>
<li class="lvl-6">
<p>SimpleThreadPoolTaskExecutor</p>
</li>
</ul>
</li>
<li class="lvl-4">
<p>SimpleAsyncTaskExecutor</p>
</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="线程池使用指南">线程池使用指南</h2>
<p>使用场景和建议</p>
<table>
<thead>
<tr>
<th>线程池类型</th>
<th>适用场景</th>
<th>Java 建议（21）</th>
</tr>
</thead>
<tbody>
<tr>
<td>FixedThreadPool</td>
<td>CPU 密集、控制并发</td>
<td>仍可用，但 I/O 场景改用虚拟线程</td>
</tr>
<tr>
<td>CachedThreadPool</td>
<td>短时突发任务</td>
<td>不推荐，改用虚拟线程或限流版</td>
</tr>
<tr>
<td>SingleThreadExecutor</td>
<td>串行任务</td>
<td>仍可用，注意队列大小</td>
</tr>
<tr>
<td>ScheduledThreadPool</td>
<td>定时任务</td>
<td>仍为首选</td>
</tr>
<tr>
<td>WorkStealingPool</td>
<td>分治计算</td>
<td>仍为首选（CPU 密集）</td>
</tr>
<tr>
<td><strong>VirtualThreadPerTask</strong></td>
<td><strong>高并发 I/O</strong></td>
<td><strong>Java 21+ 首选方案</strong></td>
</tr>
</tbody>
</table>
<p>总结推荐：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>适用场景</th>
<th>推荐实现方式</th>
<th>注意事项</th>
</tr>
</thead>
<tbody>
<tr>
<td>平台线程池（ThreadPoolExecutor）</td>
<td>CPU密集型、可控并发</td>
<td>自定义 ThreadPoolExecutor 或谨慎使用 Executors 工具类</td>
<td>控制线程数、队列类型、拒绝策略，注意关闭</td>
</tr>
<tr>
<td>虚拟线程池（Virtual Threads）</td>
<td>I/O密集型、高并发短任务</td>
<td><code>Executors.newVirtualThreadPerTaskExecutor()</code></td>
<td>适合大量阻塞任务，注意异常处理，目前为预览特性</td>
</tr>
</tbody>
</table>
<h3 id="ThreadPoolExecutor">ThreadPoolExecutor</h3>
<p><strong>ThreadPoolExecutor（标准线程池）</strong>，是线程池的核心实现类。可以自定义核心线程数、最大线程数、任务队列、拒绝策略等。</p>
<blockquote>
<p>通过 <code>Executors</code> 工厂方法可以快速创建几种常用配置的线程池，但是不建议生产用，如：</p>
<ul class="lvl-1">
<li class="lvl-2"><code>newFixedThreadPool(int nThreads)</code>：固定大小的线程池。</li>
<li class="lvl-2"><code>newSingleThreadExecutor()</code>：单线程的线程池。</li>
<li class="lvl-2"><code>newCachedThreadPool()</code>：可缓存的线程池，线程数量几乎无限制，适合大量短时任务。</li>
<li class="lvl-2"><code>newScheduledThreadPool(int corePoolSize)</code>：支持定时及周期性任务调度。</li>
</ul>
</blockquote>
<h4 id="配置示例">配置示例</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAsync</span> <span class="comment">// 开启对异步任务的支持</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadAsyncConfigurer</span> <span class="keyword">implements</span> <span class="title class_">AsyncConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果当前运行的线程数小于corePoolSize，那么就创建线程来执行任务（执行时需要获取全局锁）。</span></span><br><span class="line"><span class="comment">     * 如果运行的线程大于或等于corePoolSize，那么就把task加入BlockQueue。</span></span><br><span class="line"><span class="comment">     * 如果创建的线程数量大于BlockQueue的最大容量，且线程小于maxPoolSize，那么创建新线程来执行该任务。</span></span><br><span class="line"><span class="comment">     * 如果创建线程导致当前运行的线程数超过maximumPoolSize，就根据饱和策略来拒绝该任务。</span></span><br><span class="line"><span class="comment">     * 如果允许关闭所有核心线程，则等待keepAliveSeconds 将关闭</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Executor <span class="title function_">getAsyncExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">         <span class="comment">//通过Runtime方法来获取当前服务器cpu内核，根据cpu内核来创建核心线程数和最大线程数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">threadCount</span> <span class="operator">=</span> Runtime.getRuntime().availableProcessors();</span><br><span class="line"></span><br><span class="line">        <span class="type">ThreadPoolTaskExecutor</span> <span class="variable">threadPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolTaskExecutor</span>();</span><br><span class="line">        <span class="comment">// 设置核心线程数（若使用的线程数大于核心线程且小于最大线程时，只有当队列满时才创建新的线程执行任务）</span></span><br><span class="line">        <span class="comment">// 若小于核心线程数，则创建新线程执行任务</span></span><br><span class="line">        threadPool.setCorePoolSize(threadCount + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 设置最大线程数，若线程已达到最大线程数，且队列已满，则根据设置的中止策略执行后面的任务</span></span><br><span class="line">        threadPool.setMaxPoolSize(threadCount * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 线程池所使用的缓冲队列</span></span><br><span class="line">        threadPool.setQueueCapacity(<span class="number">500</span>);</span><br><span class="line">        <span class="comment">// 是否允许线程池中corePoolSize线程空闲时间达到keepAliveTime关闭        </span></span><br><span class="line">        threadPool.setAllowCoreThreadTimeOut(<span class="literal">false</span>);</span><br><span class="line">        <span class="comment">// 等待任务在关机时完成--表明等待所有线程执行完</span></span><br><span class="line">        threadPool.setWaitForTasksToCompleteOnShutdown(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">// 等待时间 （默认为0，此时立即停止），并没等待xx秒后强制停止</span></span><br><span class="line">        threadPool.setAwaitTerminationSeconds(<span class="number">60</span> * <span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 线程名称前缀</span></span><br><span class="line">        threadPool.setThreadNamePrefix(<span class="string">&quot;taskExector-&quot;</span>);</span><br><span class="line">        <span class="comment">//    设置中止策略(达到最大线程数后，队列已满且无线程可用于处理后面的任务时的策略)</span></span><br><span class="line">         <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。</span></span><br><span class="line"><span class="comment">         * ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。</span></span><br><span class="line"><span class="comment">         * ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）</span></span><br><span class="line"><span class="comment">         * ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        threadPool.setRejectedExecutionHandler(<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy());</span><br><span class="line">        <span class="comment">// 初始化线程</span></span><br><span class="line">        threadPool.initialize();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// keepAliveTime  当超过核心线程数的线程执行完任务后，需要等待的时间，超过该时间则销毁</span></span><br><span class="line">        <span class="keyword">return</span> threadPool;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 或者以下方式</span></span><br><span class="line">    <span class="meta">@Lazy</span></span><br><span class="line">    <span class="meta">@Bean(name = &quot;executorService&quot;, destroyMethod = &quot;shutdown&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ExecutorService <span class="title function_">executorService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//核心线程数（获取硬件）：线程池创建时候初始化的线程数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">corePoolSize</span> <span class="operator">=</span> Runtime.getRuntime().availableProcessors();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(corePoolSize + <span class="number">1</span>, corePoolSize * <span class="number">2</span> + <span class="number">1</span>, <span class="number">20</span>, TimeUnit.SECONDS, <span class="keyword">new</span> <span class="title class_">LinkedBlockingDeque</span>&lt;&gt;(<span class="number">2000</span>), <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用案例">使用案例</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">corePoolSize</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxPoolSize</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">keepAliveTime</span> <span class="operator">=</span> <span class="number">60L</span>;</span><br><span class="line">        <span class="type">TimeUnit</span> <span class="variable">timeUnit</span> <span class="operator">=</span> TimeUnit.SECONDS;</span><br><span class="line">        <span class="type">int</span> <span class="variable">queueCapacity</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用有界队列</span></span><br><span class="line">        BlockingQueue&lt;Runnable&gt; workQueue = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(queueCapacity);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 可选：自定义线程工厂（给线程设置有意义的名字）</span></span><br><span class="line">        <span class="type">ThreadFactory</span> <span class="variable">threadFactory</span> <span class="operator">=</span> Executors.defaultThreadFactory(); <span class="comment">// 或自定义</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 可选：自定义拒绝策略</span></span><br><span class="line">        <span class="type">RejectedExecutionHandler</span> <span class="variable">rejectionHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy(); <span class="comment">// 默认抛异常</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建 ThreadPoolExecutor</span></span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">                corePoolSize,</span><br><span class="line">                maxPoolSize,</span><br><span class="line">                keepAliveTime,</span><br><span class="line">                timeUnit,</span><br><span class="line">                workQueue,</span><br><span class="line">                threadFactory,</span><br><span class="line">                rejectionHandler</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提交任务示例</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">taskId</span> <span class="operator">=</span> i;</span><br><span class="line">            executor.execute(() -&gt; &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;执行任务 &quot;</span> + taskId + <span class="string">&quot;，线程：&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 优雅关闭线程池</span></span><br><span class="line">        executor.shutdown(); <span class="comment">// 不再接受新任务，等待已提交任务完成</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!executor.awaitTermination(<span class="number">60</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">                executor.shutdownNow(); <span class="comment">// 强制终止</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            executor.shutdownNow();</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="注意事项">注意事项</h4>
<ol>
<li class="lvl-3">
<p>不要盲目使用 <code>Executors</code> 提供的快捷方法，尤其是 <code>newCachedThreadPool()</code>，可能导致线程数无限增长。</p>
</li>
<li class="lvl-3">
<p>明确任务特性（CPU密集型 or I/O密集型）来设置合理的线程数：</p>
<blockquote>
<ul class="lvl-3">
<li class="lvl-2">
<p>CPU密集型：线程数 ≈ CPU核心数</p>
</li>
<li class="lvl-2">
<p>I/O密集型：线程数可以设高一些，如 CPU核心数 * (1 + 平均等待时间/平均计算时间)</p>
</li>
</ul>
<p>合理选择任务队列，比如：</p>
<ul class="lvl-3">
<li class="lvl-2">
<p>有界队列（如 ArrayBlockingQueue）可以防止资源耗尽，但可能触发拒绝策略；</p>
</li>
<li class="lvl-2">
<p>无界队列（如 LinkedBlockingQueue）可能导致内存问题。</p>
</li>
</ul>
<p>一定要妥善处理线程池的关闭，调用 <code>shutdown()</code> 或 <code>shutdownNow()</code>，避免资源泄漏。</p>
</blockquote>
</li>
</ol>
<p>（1）<code>FixedThreadPool</code> — 固定大小线程池，无界队列</p>
<p><strong>适用</strong>：控制并发数，适合 CPU 密集或稳定负载，<strong>风险</strong>：任务堆积 → OOM</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产建议:</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">4</span>, <span class="number">4</span>, <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">1000</span>), <span class="comment">// 有界队列</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy());</span><br></pre></td></tr></table></figure>
<p>（2）<code>CachedThreadPool</code> — 弹性线程池，大量线程</p>
<p><strong>适用</strong>：大量短生命周期任务（如 HTTP 请求），<strong>风险</strong>：线程爆炸 → CPU/内存耗尽</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产建议：限制最大线程数 + 监控</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, <span class="number">200</span>, <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;&gt;(),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">CustomThreadFactory</span>(<span class="string">&quot;cached-pool&quot;</span>),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy());</span><br></pre></td></tr></table></figure>
<p>（3）<code>SingleThreadExecutor</code> — 单线程串行池，无界队列</p>
<p><strong>适用</strong>：日志写入、顺序消费、串行化任务，<strong>风险</strong>：任务堆积 → OOM</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line"><span class="comment">//生产建议：改用有界队列 + 拒绝策略</span></span><br></pre></td></tr></table></figure>
<p>（4）<code>ScheduledThreadPool</code> — 定时任务池</p>
<p><strong>适用</strong>：定时心跳、轮询、延迟任务，<strong>注意</strong>：任务执行超时 → 后续任务延迟堆积（不会并发），未捕获异常 → 任务终止</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ScheduledExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">executor.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        heartbeat();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;心跳失败&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="number">0</span>, <span class="number">30</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>
<p>（5）<code>WorkStealingPool</code>（Java 8+）— 工作窃取池</p>
<p><strong>实现</strong>：<code>ForkJoinPool</code>，<strong>适用</strong>：递归、分治、CPU 密集型计算（如并行流底层），<strong>注意</strong>：任务应无阻塞、无状态，不适合 I/O 密集型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newWorkStealingPool();</span><br><span class="line"><span class="comment">// 或 Executors.newWorkStealingPool(4);</span></span><br></pre></td></tr></table></figure>
<h3 id="ForkJoinTask（并行任务）">ForkJoinTask（并行任务）</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>可递归拆分的任务（如：排序、搜索、矩阵运算、树遍历）；</p>
</li>
<li class="lvl-2">
<p>CPU 密集型计算；</p>
</li>
<li class="lvl-2">
<p>大量细粒度任务（任务执行时间 &gt; 调度开销）；</p>
</li>
<li class="lvl-2">
<p>需要结果合并的场景（RecursiveTask）。</p>
</li>
</ul>
<h4 id="使用案例-2">使用案例</h4>
<p>使用案例：不带返回值的fork-join计算：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintTask</span> <span class="keyword">extends</span> <span class="title class_">RecursiveAction</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">THRESHOLD</span> <span class="operator">=</span> <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> start;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> end;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PrintTask</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.start = start;</span><br><span class="line">        <span class="built_in">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (end - start &lt; THRESHOLD) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt;= end; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;,i=&quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">middle</span> <span class="operator">=</span> (start + end) / <span class="number">2</span>;</span><br><span class="line">            <span class="type">PrintTask</span> <span class="variable">firstTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintTask</span>(start, middle);</span><br><span class="line">            <span class="type">PrintTask</span> <span class="variable">secondTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintTask</span>(middle + <span class="number">1</span>, end);</span><br><span class="line">            invokeAll(firstTask, secondTask);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">ForkJoinPool</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span>();</span><br><span class="line">        pool.submit(<span class="keyword">new</span> <span class="title class_">PrintTask</span>(<span class="number">1</span>,<span class="number">50</span>));</span><br><span class="line">        pool.awaitTermination(<span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line">        pool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用案例：带返回值的计算</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CalculateTask</span> <span class="keyword">extends</span> <span class="title class_">RecursiveTask</span>&lt;Integer&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">THRESHOLD</span> <span class="operator">=</span> <span class="number">49</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> start;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> end;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CalculateTask</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.start = start;</span><br><span class="line">        <span class="built_in">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Integer <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (end - start &lt;= THRESHOLD) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt;= end; i++) &#123;</span><br><span class="line">                result += i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">middle</span> <span class="operator">=</span> (start + end) / <span class="number">2</span>;</span><br><span class="line">            <span class="type">CalculateTask</span> <span class="variable">firstTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CalculateTask</span>(start, middle);</span><br><span class="line">            <span class="type">CalculateTask</span> <span class="variable">secondTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CalculateTask</span>(middle + <span class="number">1</span>, end);</span><br><span class="line">            invokeAll(firstTask, secondTask);</span><br><span class="line">            <span class="keyword">return</span> firstTask.join() + secondTask.join();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result1</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">            result1 += i;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;循环计算 1-1000000 累加值：&quot;</span> + result1);</span><br><span class="line"></span><br><span class="line">        <span class="type">ForkJoinPool</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span>();</span><br><span class="line">        ForkJoinTask&lt;Integer&gt; task = pool.submit(<span class="keyword">new</span> <span class="title class_">CalculateTask</span>(<span class="number">1</span>, <span class="number">1000000</span>));</span><br><span class="line">        <span class="type">int</span> <span class="variable">result2</span> <span class="operator">=</span> task.get();</span><br><span class="line">        System.out.println(<span class="string">&quot;并行计算 1-1000000 累加值：&quot;</span> + result2);</span><br><span class="line">        pool.awaitTermination(<span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line">        pool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="调优建议">调优建议</h4>
<ol>
<li class="lvl-3">
<p><strong>合理设置并行度</strong>：一般 = CPU 核数；若任务有阻塞，可适当增加；</p>
</li>
<li class="lvl-3">
<p><strong>任务粒度控制</strong>：太小 → 调度开销大；太大 → 无法充分利用多核；</p>
</li>
<li class="lvl-3">
<p><strong>避免在任务中阻塞</strong>：如必须阻塞，使用 <code>ForkJoinPool.managedBlock(...)</code>；</p>
</li>
<li class="lvl-3">
<p><strong>监控 commonPool</strong>：避免被阻塞任务拖垮整个应用；</p>
</li>
<li class="lvl-3">
<p><strong>自定义 ForkJoinPool</strong>：隔离业务，避免相互影响。</p>
</li>
</ol>
<h4 id="注意事项-2">注意事项</h4>
<p>不适用场景，且在 ForkJoinTask 中执行阻塞 I/O 或 synchronized，会严重降低性能！</p>
<blockquote>
<ul class="lvl-1">
<li class="lvl-2">
<p>I/O 阻塞任务（会阻塞工作线程，影响窃取效率）；</p>
</li>
<li class="lvl-2">
<p>任务不可拆分或拆分成本高；</p>
</li>
<li class="lvl-2">
<p>任务间强依赖，无法并行。</p>
</li>
</ul>
</blockquote>
<h3 id="VirtualThreadPerTask">VirtualThreadPerTask</h3>
<p>虚拟线程适合高并发、I/O 密集型任务，能极大提升系统吞吐量且资源开销极小。</p>
<blockquote>
<ul class="lvl-1">
<li class="lvl-2">
<p>虚拟线程不是由 OS 管理，而是由 JVM 调度，挂起和恢复开销极低。</p>
</li>
<li class="lvl-2">
<p>每个虚拟线程占用内存极少（约 1KB~2KB），而平台线程通常需要 MB 级栈空间。</p>
</li>
<li class="lvl-2">
<p>虚拟线程适合大量并发的阻塞任务（如 HTTP 请求、数据库访问等）。</p>
</li>
</ul>
</blockquote>
<h4 id="使用方式">使用方式</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>直接通过 <code>Executors.newVirtualThreadPerTaskExecutor()</code> 创建一个“每任务一个虚拟线程”的执行器。</p>
</li>
<li class="lvl-2">
<p>或者使用 <code>Thread.ofVirtual().factory()</code> 构建虚拟线程工厂，再传入 <code>ThreadPoolExecutor</code>。</p>
</li>
</ul>
<p>使用 <code>Executors.newVirtualThreadPerTaskExecutor()</code> 可以简单地为每个任务分配一个虚拟线程，无需手动管理线程数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">var</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newVirtualThreadPerTaskExecutor()) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10_000</span>; i++) &#123;</span><br><span class="line">        executor.submit(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 模拟 I/O：数据库查询、HTTP 调用等</span></span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;result&quot;</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">// 自动关闭</span></span><br></pre></td></tr></table></figure>
<blockquote>
<ul class="lvl-1">
<li class="lvl-2">
<p>每个任务一个虚拟线程，无池化，自动回收</p>
<ul class="lvl-3">
<li class="lvl-4">无需调优线程池参数</li>
<li class="lvl-4">无队列堆积、无拒绝策略问题</li>
<li class="lvl-4">高吞吐、低延迟（尤其 I/O 场景）</li>
</ul>
</li>
</ul>
</blockquote>
<p><strong>虚拟线程 + 平台线程混合使用</strong>（高级场景）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 平台线程池处理 CPU 密集任务</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">cpuPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(</span><br><span class="line">    Runtime.getRuntime().availableProcessors()</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 虚拟线程处理 I/O 任务</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">ioPool</span> <span class="operator">=</span> Executors.newVirtualThreadPerTaskExecutor();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组合使用</span></span><br><span class="line">ioPool.submit(() -&gt; &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> fetchDataFromNetwork(); <span class="comment">// I/O</span></span><br><span class="line">    cpuPool.submit(() -&gt; processData(data)); <span class="comment">// CPU</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="使用案例-3">使用案例</h4>
<p>简单的使用场景：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Web 服务（Spring Boot 3.2+ 支持虚拟线程）</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyController</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newVirtualThreadPerTaskExecutor();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/data&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> CompletableFuture&lt;String&gt; <span class="title function_">getData</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 模拟数据库查询（阻塞）</span></span><br><span class="line">            <span class="keyword">try</span> &#123; Thread.sleep(<span class="number">100</span>); &#125; <span class="keyword">catch</span> (Exception e) &#123;&#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;result&quot;</span>;</span><br><span class="line">        &#125;, executor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="注意事项-3">注意事项</h4>
<p>虚拟线程适合用于大量并发的、会阻塞的任务，例如网络请求、文件读写等。不适合用于计算密集型任务，因为虚拟线程仍然运行在有限的物理线程上，过多计算仍会竞争。</p>
<ol>
<li class="lvl-3">
<p><strong>不适合 CPU 密集型任务</strong></p>
<ul class="lvl-2">
<li class="lvl-5">
<p>虚拟线程运行在平台线程上，CPU 密集会阻塞 Carrier 线程</p>
</li>
<li class="lvl-5">
<p>应提交给 <code>ForkJoinPool</code> 或固定大小平台线程池</p>
</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>避免在虚拟线程中使用 <code>synchronized</code></strong></p>
<ul class="lvl-2">
<li class="lvl-5">
<p><code>synchronized</code> 会 pin 住底层平台线程，失去虚拟线程优势</p>
</li>
<li class="lvl-5">
<p>改用 <code>ReentrantLock</code>、<code>StampedLock</code>、<code>Semaphore</code> 等</p>
</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>ThreadLocal 使用需谨慎</strong></p>
<ul class="lvl-2">
<li class="lvl-5">
<p>虚拟线程数量巨大 → ThreadLocal 内存泄漏风险</p>
</li>
<li class="lvl-5">
<p>使用后及时 <code>remove()</code>，或改用 <code>ScopedValue</code>（Java 21 新增）</p>
</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>不要将虚拟线程放入传统线程池</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐：虚拟线程放入传统线程池无意义</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">pool.submit(() -&gt; Thread.startVirtualThread(task)); <span class="comment">// 多此一举</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确：直接使用虚拟线程执行器</span></span><br><span class="line">virtualExecutor.submit(task);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="线程池原理详解">线程池原理详解</h2>
<h3 id="ThreadPoolExecutor（标准常用）">ThreadPoolExecutor（标准常用）</h3>
<p>通过构造器设置核心参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="type">int</span> corePoolSize,      // 核心线程数</span></span><br><span class="line"><span class="params">    <span class="type">int</span> maximumPoolSize,   // 最大线程数</span></span><br><span class="line"><span class="params">    <span class="type">long</span> keepAliveTime,    // 空闲线程存活时间</span></span><br><span class="line"><span class="params">    TimeUnit unit,         // 时间单位</span></span><br><span class="line"><span class="params">    BlockingQueue&lt;Runnable&gt; workQueue, // 任务队列</span></span><br><span class="line"><span class="params">    ThreadFactory threadFactory,       // 线程工厂</span></span><br><span class="line"><span class="params">    RejectedExecutionHandler handler   // 拒绝策略</span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure>
<p><code>ThreadPoolExecutor</code> 使用一个 <code>AtomicInteger</code> 类型的字段 <code>ctl</code> 来同时表示 <strong>线程池状态</strong> 和 <strong>工作线程数量</strong>：</p>
<blockquote>
<ul class="lvl-1">
<li class="lvl-2">
<p>高3位：线程池运行状态（runState）</p>
</li>
<li class="lvl-2">
<p>低29位：工作线程数（workerCount）</p>
</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">RUNNING</span>    <span class="operator">=</span> -<span class="number">1</span> &lt;&lt; COUNT_BITS; <span class="comment">// 接受新任务，处理队列中任务</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SHUTDOWN</span>   <span class="operator">=</span>  <span class="number">0</span> &lt;&lt; COUNT_BITS; <span class="comment">// 不接受新任务，处理队列中任务</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">STOP</span>       <span class="operator">=</span>  <span class="number">1</span> &lt;&lt; COUNT_BITS; <span class="comment">// 不接受新任务，不处理队列任务，中断进行中任务</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TIDYING</span>    <span class="operator">=</span>  <span class="number">2</span> &lt;&lt; COUNT_BITS; <span class="comment">// 所有任务终止，workerCount=0，将调用 terminated()</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TERMINATED</span> <span class="operator">=</span>  <span class="number">3</span> &lt;&lt; COUNT_BITS; <span class="comment">// terminated() 已执行完毕</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 状态转换:</span></span><br><span class="line">RUNNING → SHUTDOWN （调用 shutdown()）</span><br><span class="line">          ↓</span><br><span class="line">        STOP （调用 shutdownNow()）</span><br><span class="line">          ↓</span><br><span class="line">       TIDYING （任务和线程都清空）</span><br><span class="line">          ↓</span><br><span class="line">     TERMINATED （terminated() 执行完毕）</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>内部定义了一个内部类 <code>Worker</code>，继承自 <code>AbstractQueuedSynchronizer（AQS）</code>，实现了简单的不可重入独占锁，用于控制线程执行任务时的状态。</p>
<p><strong>Worker 的作用</strong>：</p>
<blockquote>
<ul class="lvl-1">
<li class="lvl-2">
<p>封装工作线程（Thread）；</p>
</li>
<li class="lvl-2">
<p>持有第一个要执行的任务（firstTask）；</p>
</li>
<li class="lvl-2">
<p>统计已完成任务数；</p>
</li>
<li class="lvl-2">
<p>通过 AQS 实现任务执行时的“锁定”，避免中断正在运行的任务。</p>
</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 继承AQS，使用CAS实现线程状态控制</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Worker</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="comment">/** Thread this worker is running in.  Null if factory fails. */</span></span><br><span class="line">    <span class="keyword">final</span> Thread thread;</span><br><span class="line">    <span class="comment">/** Initial task to run.  Possibly null. */</span></span><br><span class="line">    Runnable firstTask;</span><br><span class="line">    <span class="comment">/** Per-thread task counter */</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">long</span> completedTasks;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates with given first task and thread from ThreadFactory.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> firstTask the first task (null if none)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Worker(Runnable firstTask) &#123;</span><br><span class="line">        setState(-<span class="number">1</span>); <span class="comment">// inhibit interrupts until runWorker</span></span><br><span class="line">        <span class="built_in">this</span>.firstTask = firstTask;</span><br><span class="line">        <span class="built_in">this</span>.thread = getThreadFactory().newThread(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        runWorker(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通过CAS判断是否有线程在运行</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> unused)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 释放线程</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> unused)</span> &#123;</span><br><span class="line">        setExclusiveOwnerThread(<span class="literal">null</span>);</span><br><span class="line">        setState(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span>        &#123; acquire(<span class="number">1</span>); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">()</span>  &#123; <span class="keyword">return</span> tryAcquire(<span class="number">1</span>); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span>      &#123; release(<span class="number">1</span>); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isLocked</span><span class="params">()</span> &#123; <span class="keyword">return</span> getState() != <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">interruptIfStarted</span><span class="params">()</span> &#123;</span><br><span class="line">        Thread t;</span><br><span class="line">        <span class="keyword">if</span> (getState() &gt;= <span class="number">0</span> &amp;&amp; (t = thread) != <span class="literal">null</span> &amp;&amp; !t.isInterrupted()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t.interrupt();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="VirtualThreadPerTask（虚拟线程）">VirtualThreadPerTask（虚拟线程）</h3>
<p>虚拟线程是轻量级线程，由 JVM 管理，底层使用少量平台线程（OS线程）调度大量虚拟线程。</p>
<table>
<thead>
<tr>
<th>维度</th>
<th>传统线程池（平台线程）</th>
<th>虚拟线程（Java 21+）</th>
</tr>
</thead>
<tbody>
<tr>
<td>线程成本</td>
<td>高（MB 级栈，OS 管理）</td>
<td>极低（KB 级，JVM 管理）</td>
</tr>
<tr>
<td>最大并发数</td>
<td>通常几百~几千</td>
<td>可达百万级</td>
</tr>
<tr>
<td>适用场景</td>
<td>CPU 密集型、定时任务</td>
<td>I/O 密集型（首选）</td>
</tr>
<tr>
<td>是否需要池化</td>
<td>必须池化复用</td>
<td>无需池化，按需创建（每个任务新建虚拟线程）</td>
</tr>
<tr>
<td>阻塞影响</td>
<td>阻塞 = 浪费线程</td>
<td>阻塞 = 自动挂起，不占平台线程</td>
</tr>
<tr>
<td>调优复杂度</td>
<td>高（队列、线程数、拒绝策略）</td>
<td>低（无需调优）</td>
</tr>
</tbody>
</table>
<blockquote>
<ul class="lvl-1">
<li class="lvl-2">
<p>轻量级线程，由 JVM 管理，不是 OS 线程</p>
</li>
<li class="lvl-2">
<p>创建成本极低（可创建百万级）</p>
</li>
<li class="lvl-2">
<p>阻塞时不阻塞底层 OS 线程（自动挂起/恢复）</p>
</li>
<li class="lvl-2">
<p>适用于高并发 I/O 密集型场景</p>
</li>
</ul>
</blockquote>
<h4 id="虚拟线程的本质"><strong>虚拟线程的本质</strong></h4>
<p>虚拟线程是 <strong>Project Loom</strong> 引入的轻量级线程，由 JVM 而非操作系统管理：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>每个虚拟线程在 Java 堆中只是一个对象（约几百字节）；</p>
</li>
<li class="lvl-2">
<p>虚拟线程映射到少量平台线程（Carrier Threads）上运行；</p>
</li>
<li class="lvl-2">
<p>虚拟线程在执行阻塞操作（如 I/O、sleep、锁等待）时会自动 <strong>“卸载”（unmount）</strong>，让出底层平台线程，等可继续执行时再 <strong>“挂载”（mount）</strong> 到任意平台线程上继续执行。</p>
</li>
</ul>
<h4 id="虚拟线程的实现"><strong>虚拟线程的实现</strong></h4>
<p><code>Executors.newVirtualThreadPerTaskExecutor()</code> 返回的是一个 <code>ThreadPerTaskExecutor</code> 实例（内部类）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实例化 ThreadPerTaskExecutor</span></span><br><span class="line"><span class="keyword">public</span> ThreadPerTaskExecutor <span class="title function_">newVirtualThreadPerTaskExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPerTaskExecutor</span>(Thread.ofVirtual().factory());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ThreadPerTaskExecutor 核心逻辑：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ThreadPerTaskExecutor</span> <span class="keyword">implements</span> <span class="title class_">Executor</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadFactory factory;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ThreadPerTaskExecutor</span><span class="params">(ThreadFactory factory)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.factory = factory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable task)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(task);</span><br><span class="line">        factory.newThread(task).start(); <span class="comment">// 每次新建虚拟线程并启动</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建并启动线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable task)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> Thread.ofVirtual().unstarted(task);</span><br><span class="line">    thread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul class="lvl-1">
<li class="lvl-2">
<p>每次 <code>execute(task)</code> → 创建一个全新的虚拟线程；</p>
</li>
<li class="lvl-2">
<p>启动该线程执行任务；</p>
</li>
<li class="lvl-2">
<p>任务执行完毕 → 虚拟线程自动销毁（GC 回收）；</p>
</li>
<li class="lvl-2">
<p><strong>无队列、无线程池、无复用、无拒绝策略。</strong></p>
</li>
</ul>
</blockquote>
<h4 id="虚拟线程的特点"><strong>虚拟线程的特点</strong></h4>
<ol>
<li class="lvl-3">
<p>创建成本极低</p>
<ul class="lvl-2">
<li class="lvl-5">创建百万个虚拟线程内存开销仅几十 MB；</li>
<li class="lvl-5">对比：创建 1000 个平台线程可能就耗尽内存或 OS 线程限制。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>阻塞不阻塞平台线程</strong></p>
<ul class="lvl-2">
<li class="lvl-5">当虚拟线程执行 <code>socket.read()</code>, <code>Thread.sleep()</code>, <code>synchronized</code>, <code>Lock.lock()</code> 等操作时，JVM 会自动将其从 Carrier Thread 上卸载，让 Carrier Thread 去执行其他虚拟线程；</li>
<li class="lvl-5">当 I/O 完成或锁可用时，虚拟线程被重新调度执行；</li>
<li class="lvl-5"><strong>平台线程始终处于忙碌状态，无“线程饥饿”问题。</strong></li>
</ul>
</li>
<li class="lvl-3">
<p><strong>无需线程池管理</strong></p>
<ul class="lvl-2">
<li class="lvl-5">传统线程池是为了复用昂贵的平台线程；</li>
<li class="lvl-5">虚拟线程足够便宜，复用无意义，反而增加复杂度；</li>
<li class="lvl-5">“一个任务一个线程”变成最优实践。</li>
</ul>
</li>
</ol>
<h3 id="ForkJoinPool-（并行窃取）">ForkJoinPool （并行窃取）</h3>
<p>Java 7 引入的并发工具类，位于 <code>java.util.concurrent</code> 包中，专为 <strong>分治算法（Divide and Conquer）</strong> 和 <strong>并行任务处理</strong> 设计。它在 Java 8 的 <code>parallelStream()</code>、<code>CompletableFuture</code> 默认线程池中被广泛使用，是现代 Java 高性能并行计算的核心基础设施。</p>
<blockquote>
<p>其主旨是将大任务分成若干小任务，之后再并行对这些小任务进行计算，最终汇总这些任务的结果。 类似map-reduce</p>
</blockquote>
<h4 id="核心思想"><strong>核心思想</strong></h4>
<p>ForkJoinPool采取<strong>工作窃取算法</strong>（<strong>work-stealing</strong>），以避免工作线程由于拆分了任务之后的join等待过程。这样处于空闲的工作线程将从其他工作线程的队列中主动去窃取任务来执行。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>工作窃取（Work-Stealing）</strong>：空闲线程从其他线程的任务队列“偷”任务执行，提高 CPU 利用率；</p>
</li>
<li class="lvl-2">
<p><strong>轻量级任务调度</strong>：避免传统线程池中任务入队/出队的锁竞争；</p>
</li>
<li class="lvl-2">
<p><strong>递归任务分解</strong>：支持任务“fork”拆分子任务，“join”合并结果。</p>
</li>
</ul>
<blockquote>
<p><strong>工作窃取</strong>：当某个线程的任务队列中没有可执行任务的时候，从其他线程的任务队列中窃取任务来执行，以充分利用工作线程的计算能力，减少线程由于获取不到任务而造成的空闲浪费。</p>
<p>ForkJoinPool中的所有线程都会尝试查找并执行提交到线程池中由其他活动创建的任务，如果不存在这些任务，则进行阻塞</p>
<p>在 ForkJoinPool 中，线程池中每个工作线程（ForkJoinWorkerThread）都对应一个任务队列（WorkQueue），工作线程优先处理来自自身队列的任务（LIFO或FIFO顺序，参数 mode 决定），然后以FIFO的顺序随机窃取其他队列中的任务。</p>
<p>在ForkJoinpool中，工作任务的队列都采用双端队列Deque容器。在通常使用队列都在队尾插入，在队头消费以实现FIFO。而为了实现工作窃取，会改成工作线程在工作队列上LIFO,而窃取其他线程的任务的时候，从队列头部取获取。</p>
</blockquote>
<p><strong>其中的核心类</strong>：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ForkJoinPool</code></td>
<td>线程池主类，管理线程、调度任务</td>
</tr>
<tr>
<td><code>ForkJoinWorkerThread</code></td>
<td>工作线程，每个线程绑定一个 WorkQueue</td>
</tr>
<tr>
<td><code>WorkQueue</code></td>
<td>双端队列（Deque），存储待执行任务，支持 LIFO（本线程取）和 FIFO（其他线程偷）</td>
</tr>
<tr>
<td><code>ForkJoinTask</code></td>
<td>任务抽象基类（类似 Runnable），支持 fork/join</td>
</tr>
<tr>
<td><code>RecursiveTask&lt;T&gt;</code></td>
<td>有返回值的递归任务（继承 ForkJoinTask）</td>
</tr>
<tr>
<td><code>RecursiveAction</code></td>
<td>无返回值的递归任务</td>
</tr>
</tbody>
</table>
<h4 id="工作窃取机制">工作窃取机制</h4>
<p><strong>WorkQueue 结构</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>每个 <code>ForkJoinWorkerThread</code> 拥有一个 <code>WorkQueue</code>；</p>
</li>
<li class="lvl-2">
<p><code>WorkQueue</code> 是 <strong>双端队列（Deque）</strong>；</p>
</li>
<li class="lvl-2">
<p>本线程操作队列尾部（LIFO）→ 减少竞争，利于缓存局部性；</p>
</li>
<li class="lvl-2">
<p>其他线程偷任务从队列头部（FIFO）→ 避免偷“刚提交的大任务”，偷“老任务”更公平；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runState bits: SHUTDOWN must be negative, others arbitrary powers of two</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>  <span class="variable">RSLOCK</span>     <span class="operator">=</span> <span class="number">1</span>;        <span class="comment">//</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>  <span class="variable">RSIGNAL</span>    <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">1</span>;    <span class="comment">//    信号</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>  <span class="variable">STARTED</span>    <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">2</span>;    <span class="comment">//    开始</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>  <span class="variable">STOP</span>       <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">29</span>;    <span class="comment">//    停止</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>  <span class="variable">TERMINATED</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">30</span>;    <span class="comment">//    销毁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>  <span class="variable">SHUTDOWN</span>   <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">31</span>;    <span class="comment">//    关闭</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 工作队列</span></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">WorkQueue</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INITIAL_QUEUE_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">13</span>; <span class="comment">// 初始容量 8k</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXIMUM_QUEUE_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">26</span>; <span class="comment">// 最大容量 64M</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> scanState;    <span class="comment">// versioned, &lt;0: inactive; odd:scanning</span></span><br><span class="line">    <span class="type">int</span> stackPred;             <span class="comment">// pool stack (ctl) predecessor</span></span><br><span class="line">    <span class="type">int</span> nsteals;               <span class="comment">// 抢断次数</span></span><br><span class="line">    <span class="type">int</span> hint;                  <span class="comment">// 随机化和窃取的索引</span></span><br><span class="line">    <span class="type">int</span> config;                <span class="comment">// pool index and mode</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> qlock;        <span class="comment">// 1: locked, &lt; 0: terminate; else 0</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> base;         <span class="comment">// index of next slot for poll</span></span><br><span class="line">    <span class="type">int</span> top;                   <span class="comment">// index of next slot for push</span></span><br><span class="line">    ForkJoinTask&lt;?&gt;[] array;   <span class="comment">// the elements (initially unallocated)</span></span><br><span class="line">    <span class="keyword">final</span> ForkJoinPool pool;   <span class="comment">// the containing pool (may be null)</span></span><br><span class="line">    <span class="keyword">final</span> ForkJoinWorkerThread owner; <span class="comment">// 工作线程，默认线程数量等于处理器的核心数</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread parker;    <span class="comment">// == owner during call to park; else null</span></span><br><span class="line">    <span class="keyword">volatile</span> ForkJoinTask&lt;?&gt; currentJoin;  <span class="comment">// task being joined in awaitJoin</span></span><br><span class="line">    <span class="keyword">volatile</span> ForkJoinTask&lt;?&gt; currentSteal; <span class="comment">// mainly used by helpStealer</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>工作窃取（Work-Stealing）流程</strong></p>
<blockquote>
<p>线程A空闲<br>
│<br>
▼<br>
随机选择一个其他线程B的 WorkQueue<br>
│<br>
▼<br>
从线程B的 WorkQueue 头部窃取一个任务<br>
│<br>
▼<br>
执行窃取的任务</p>
</blockquote>
<p>窃取操作是无锁或低竞争的（通过 CAS + 位运算优化），极大减少线程间同步开销。</p>
<h4 id="内部状态与调度">内部状态与调度</h4>
<ol>
<li class="lvl-3">
<p><strong>ctl（控制状态）</strong></p>
<p>类似 <code>ThreadPoolExecutor</code>，<code>ForkJoinPool</code> 使用一个 <code>long</code> 类型字段 <code>ctl</code> 表示：</p>
<ul class="lvl-2">
<li class="lvl-5">
<p>低 32 位：活跃/空闲线程数；</p>
</li>
<li class="lvl-5">
<p>高 32 位：用于唤醒、创建线程等信号。</p>
</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>任务提交方式</strong></p>
<p>外部队列是 FIFO，内部队列是 LIFO + 支持窃取。</p>
<ul class="lvl-2">
<li class="lvl-5">
<p><strong>外部提交（External Submissions）</strong>：如 <code>pool.submit(task)</code> → 进入 <code>Submission Queue</code>（共享队列）；</p>
</li>
<li class="lvl-5">
<p><strong>内部 fork（Internal Forks）</strong>：如 <code>task.fork()</code> → 进入当前线程的 <code>WorkQueue</code> 尾部。</p>
</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>线程唤醒机制</strong></p>
<p>当任务提交到空队列或新任务到来时，<code>ForkJoinPool</code> 会尝试：</p>
<ul class="lvl-2">
<li class="lvl-5">
<p>唤醒一个空闲线程，或创建新线程（不超过最大并行度）；</p>
</li>
<li class="lvl-5">
<p>使用“缓存行填充” + “伪共享避免”优化并发性能。</p>
</li>
</ul>
</li>
</ol>
<h4 id="fork-与-join-原理">fork() 与 join() 原理</h4>
<p>任务拆分+合并</p>
<blockquote>
<p>在ForkJoinPool中，任务的拆分和合并是通过继承自RecursiveAction或RecursiveTask的类来实现的。</p>
<p>开发者需要实现compute方法来定义任务的处理逻辑。</p>
<ol>
<li class="lvl-3">
<p>当一个大任务被拆分成多个小任务时，这些小任务会被提交到ForkJoinPool中并行执行。</p>
</li>
<li class="lvl-3">
<p>当所有小任务都执行完成后，它们的结果会被合并起来得到大任务的处理结果。</p>
</li>
</ol>
</blockquote>
<p><strong>fork()</strong></p>
<p>如果是 ForkJoinWorkerThread  推入自己的 WorkQueue（LIFO）。否则提交到公共队列（common pool 的 submission queue）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> ForkJoinTask&lt;V&gt; <span class="title function_">fork</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="keyword">if</span> (t <span class="keyword">instanceof</span> ForkJoinWorkerThread)</span><br><span class="line">        ((ForkJoinWorkerThread) t).workQueue.push(<span class="built_in">this</span>); <span class="comment">// 推入当前线程队列尾部</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ForkJoinPool.common.externalPush(<span class="built_in">this</span>); <span class="comment">// 外部线程提交到共享队列</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>join()</strong></p>
<p>调用 doJoin()  如果任务未完成，当前线程会尝试帮助执行其他任务，或阻塞等待（通过 <code>ManagedBlocker</code> 或 <code>park</code>）；</p>
<p><strong>不会傻等，而是“帮助执行”或“窃取任务”，提高 CPU 利用率。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title function_">join</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> s;</span><br><span class="line">    <span class="keyword">if</span> ((s = doJoin() &amp; DONE_MASK) != NORMAL)</span><br><span class="line">        reportException(s);</span><br><span class="line">    <span class="keyword">return</span> getRawResult();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="并行度（Parallelism）">并行度（Parallelism）</h4>
<p>默认并行度 = <code>Runtime.getRuntime().availableProcessors()</code>；可通过构造函数指定：</p>
<blockquote>
<ul class="lvl-1">
<li class="lvl-2">
<p>并行度 ≠ 线程数：线程数可能略多（补偿阻塞），但活跃线程数 ≈ 并行度；</p>
</li>
<li class="lvl-2">
<p>可通过 <code>ForkJoinPool.commonPool()</code> 获取全局共享池（默认并行度）。</p>
</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认构造器</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ForkJoinPool</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(Math.min(MAX_CAP, Runtime.getRuntime().availableProcessors()), <span class="comment">// CPU核心数</span></span><br><span class="line">         defaultForkJoinWorkerThreadFactory, <span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置并行度参数</span></span><br><span class="line"><span class="keyword">private</span> <span class="title function_">ForkJoinPool</span><span class="params">(<span class="type">int</span> parallelism,                         // 并行度：最大 <span class="number">32767</span></span></span><br><span class="line"><span class="params">                     ForkJoinWorkerThreadFactory factory,  	  // 线程创建工厂类</span></span><br><span class="line"><span class="params">                     UncaughtExceptionHandler handler,        // 异常处理接口（因未捕获异常突然终止时执行）</span></span><br><span class="line"><span class="params">                     <span class="type">int</span> mode,                                // 异步模式：FIFO_QUEUE，LIFO_QUEUE,默认LIFO</span></span><br><span class="line"><span class="params">                     String workerNamePrefix)</span> &#123;               <span class="comment">//工作线程名称前缀</span></span><br><span class="line">    <span class="built_in">this</span>.workerNamePrefix = workerNamePrefix;</span><br><span class="line">    <span class="built_in">this</span>.factory = factory;</span><br><span class="line">    <span class="built_in">this</span>.ueh = handler;</span><br><span class="line">    <span class="built_in">this</span>.config = (parallelism &amp; SMASK) | mode;</span><br><span class="line">    <span class="type">long</span> <span class="variable">np</span> <span class="operator">=</span> (<span class="type">long</span>)(-parallelism); <span class="comment">// offset ctl counts</span></span><br><span class="line">    <span class="built_in">this</span>.ctl = ((np &lt;&lt; AC_SHIFT) &amp; AC_MASK) | ((np &lt;&lt; TC_SHIFT) &amp; TC_MASK);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认线程池工厂类</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">DefaultForkJoinWorkerThreadFactory</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">ForkJoinWorkerThreadFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> ForkJoinWorkerThread <span class="title function_">newThread</span><span class="params">(ForkJoinPool pool)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ForkJoinWorkerThread</span>(pool);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="其他说明">其他说明</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>Java 8+ 中的 <code>parallelStream() </code> 默认使用 <code>ForkJoinPool.commonPool()</code>，任务被自动拆分为 <code>ForkJoinTask</code> 并并行执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.parallelStream().map(...).filter(...).collect(...); </span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-3">
<p>CompletableFuture（默认异步执行器），默认使用  <code>ForkJoinPool.commonPool()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture.supplyAsync(() -&gt; task());</span><br><span class="line"><span class="comment">// 如果 commonPool 被阻塞（如大量 IO），会影响所有 parallelStream 和 CompletableFuture，可引入自定义线程池</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span>(<span class="number">8</span>);</span><br><span class="line">CompletableFuture.supplyAsync(() -&gt; task(), pool);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://pengline.github.io">余一叶知秋尽</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://pengline.github.io/2025/09/10/366f9754e67846f0b38a4354a634b75f/">https://pengline.github.io/2025/09/10/366f9754e67846f0b38a4354a634b75f/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://pengline.github.io" target="_blank">余一叶知秋尽</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/">Java多线程</a><a class="post-meta__tags" href="/tags/ThreadPoolExecutor/">ThreadPoolExecutor</a><a class="post-meta__tags" href="/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/">线程池</a><a class="post-meta__tags" href="/tags/Executors/">Executors</a><a class="post-meta__tags" href="/tags/VirtualThreadPerTask/">VirtualThreadPerTask</a><a class="post-meta__tags" href="/tags/WorkStealingPool/">WorkStealingPool</a><a class="post-meta__tags" href="/tags/ForkJoinTask/">ForkJoinTask</a></div><div class="post-share"><div class="social-share" data-image="https://www.toopic.cn/public/uploads/small/175514400277175514400262.jpg" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/09/11/64e3ec6a2be5436b9bd931ad7a023235/" title="系统架构设计的实施考量和演进过程"><img class="cover" src= "/img/20241215205335173426721579192.jpg" data-lazy-src="https://www.toopic.cn/public/uploads/small/1757474425779175747442528.png" onerror="onerror=null;src='/img/k3zssqvjw2d.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">系统架构设计的实施考量和演进过程</div></div><div class="info-2"><div class="info-item-1">介绍了架构设计的基本维度和设计考量，以及具体的实施流程和架构演进的详细过程，以电商系统为例。</div></div></div></a><a class="pagination-related" href="/2025/09/09/84c118df8b3e4db4a1e3557e7633f8e8/" title="Ubuntu 系统如何搭建 Kubernetes 集群"><img class="cover" src= "/img/20241215205335173426721579192.jpg" data-lazy-src="https://www.toopic.cn/public/uploads/small/1712590388795171259038894.jpg" onerror="onerror=null;src='/img/k3zssqvjw2d.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Ubuntu 系统如何搭建 Kubernetes 集群</div></div><div class="info-2"><div class="info-item-1">Ubuntu24安装k8s集群，配置网络插件，使用containerd容器搭建Nginx服务，安装Dashboard可视化插件。</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/08/28/6d4b4511bd2443af994ec8e5982eb34a/" title="Java 多线程之等待全部执行完成"><img class="cover" src= "/img/20241215205335173426721579192.jpg" data-lazy-src="https://www.toopic.cn/public/uploads/small/1658047056104165804705638.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-08-28</div><div class="info-item-2">Java 多线程之等待全部执行完成</div></div><div class="info-2"><div class="info-item-1">多线程如何实现“等待全部执行完成”，才能继续执行下一步。</div></div></div></a><a class="pagination-related" href="/2025/08/28/ab60513384f74cac8ff0ab36a98cc1a6/" title="Java 多线程之等待至少一个执行完成"><img class="cover" src= "/img/20241215205335173426721579192.jpg" data-lazy-src="https://www.toopic.cn/public/uploads/small/1704296745781170429674563.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-08-28</div><div class="info-item-2">Java 多线程之等待至少一个执行完成</div></div><div class="info-2"><div class="info-item-1">多线程如何实现“等待至少一个执行完成”，就可执行下一步。</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="giscus-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%A6%82%E5%BF%B5%E7%BB%93%E6%9E%84"><span class="toc-number">1.</span> <span class="toc-text">线程池概念结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6"><span class="toc-number">1.1.</span> <span class="toc-text">核心组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-number">1.2.</span> <span class="toc-text">执行流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%8A%B6%E6%80%81"><span class="toc-number">1.3.</span> <span class="toc-text">线程池状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-number">1.4.</span> <span class="toc-text">线程池体系结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97"><span class="toc-number">2.</span> <span class="toc-text">线程池使用指南</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ThreadPoolExecutor"><span class="toc-number">2.1.</span> <span class="toc-text">ThreadPoolExecutor</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E7%A4%BA%E4%BE%8B"><span class="toc-number">2.1.1.</span> <span class="toc-text">配置示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B"><span class="toc-number">2.1.2.</span> <span class="toc-text">使用案例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">2.1.3.</span> <span class="toc-text">注意事项</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ForkJoinTask%EF%BC%88%E5%B9%B6%E8%A1%8C%E4%BB%BB%E5%8A%A1%EF%BC%89"><span class="toc-number">2.2.</span> <span class="toc-text">ForkJoinTask（并行任务）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B-2"><span class="toc-number">2.2.1.</span> <span class="toc-text">使用案例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E4%BC%98%E5%BB%BA%E8%AE%AE"><span class="toc-number">2.2.2.</span> <span class="toc-text">调优建议</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-2"><span class="toc-number">2.2.3.</span> <span class="toc-text">注意事项</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#VirtualThreadPerTask"><span class="toc-number">2.3.</span> <span class="toc-text">VirtualThreadPerTask</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">2.3.1.</span> <span class="toc-text">使用方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B-3"><span class="toc-number">2.3.2.</span> <span class="toc-text">使用案例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-3"><span class="toc-number">2.3.3.</span> <span class="toc-text">注意事项</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3"><span class="toc-number">3.</span> <span class="toc-text">线程池原理详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ThreadPoolExecutor%EF%BC%88%E6%A0%87%E5%87%86%E5%B8%B8%E7%94%A8%EF%BC%89"><span class="toc-number">3.1.</span> <span class="toc-text">ThreadPoolExecutor（标准常用）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#VirtualThreadPerTask%EF%BC%88%E8%99%9A%E6%8B%9F%E7%BA%BF%E7%A8%8B%EF%BC%89"><span class="toc-number">3.2.</span> <span class="toc-text">VirtualThreadPerTask（虚拟线程）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="toc-number">3.2.1.</span> <span class="toc-text">虚拟线程的本质</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.2.2.</span> <span class="toc-text">虚拟线程的实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">3.2.3.</span> <span class="toc-text">虚拟线程的特点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ForkJoinPool-%EF%BC%88%E5%B9%B6%E8%A1%8C%E7%AA%83%E5%8F%96%EF%BC%89"><span class="toc-number">3.3.</span> <span class="toc-text">ForkJoinPool （并行窃取）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3"><span class="toc-number">3.3.1.</span> <span class="toc-text">核心思想</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E7%AA%83%E5%8F%96%E6%9C%BA%E5%88%B6"><span class="toc-number">3.3.2.</span> <span class="toc-text">工作窃取机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E7%8A%B6%E6%80%81%E4%B8%8E%E8%B0%83%E5%BA%A6"><span class="toc-number">3.3.3.</span> <span class="toc-text">内部状态与调度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#fork-%E4%B8%8E-join-%E5%8E%9F%E7%90%86"><span class="toc-number">3.3.4.</span> <span class="toc-text">fork() 与 join() 原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E8%A1%8C%E5%BA%A6%EF%BC%88Parallelism%EF%BC%89"><span class="toc-number">3.3.5.</span> <span class="toc-text">并行度（Parallelism）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E8%AF%B4%E6%98%8E"><span class="toc-number">3.3.6.</span> <span class="toc-text">其他说明</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 By 余一叶知秋尽</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.4.3</a></span></div><div class="footer_custom_text"><p><a style="margin-inline:5px"target="_blank"href="https://github.com/"><img src= "/img/20241215205335173426721579192.jpg" data-lazy-src="https://img.shields.io/badge/Hosted-Github-brightgreen?style=flat&logo=GitHub"title="本站项目由Gtihub托管"></a><a style="margin-inline:5px"target="_blank"href="https://hexo.io/"><img src= "/img/20241215205335173426721579192.jpg" data-lazy-src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&logo=hexo"title="博客框架为Hexo"></a><a style="margin-inline:5px"target="_blank"href="https://butterfly.js.org/"><img src= "/img/20241215205335173426721579192.jpg" data-lazy-src="https://img.shields.io/badge/Theme-Butterfly-6513df?logoColor=white&style=flat&logo=buefy"title="主题采用butterfly"></a><a style="margin-inline:5px"target="_blank"href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img src= "/img/20241215205335173426721579192.jpg" data-lazy-src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&logo=Claris"title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"></a></p></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><a class="icon-V hidden" onclick="switchNightMode()" title="日间和夜间模式切换"><svg width="25" height="25" viewBox="0 0 1024 1024"><use id="modeicon" xlink:href="#icon-moon"></use></svg></a><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = {"mapping":"pathname","reactions_enabled":1,"emit_metadata":0,"input_position":"top","theme":"preferred_color_scheme","crossorigin":"anonymous","async":true}

  const getGiscusTheme = theme => theme === 'dark' ? 'dark' : 'light'

  const createScriptElement = config => {
    const ele = document.createElement('script')
    Object.entries(config).forEach(([key, value]) => {
      ele.setAttribute(key, value)
    })
    return ele
  }

  const loadGiscus = (el = document, key) => {
    const mappingConfig = isShuoshuo
      ? { 'data-mapping': 'specific', 'data-term': key }
      : { 'data-mapping': (option && option['data-mapping']) || 'pathname' }

    const giscusConfig = {
      src: 'https://giscus.app/client.js?lang=zh-CN',
      'data-repo': 'pengline/pengline.github.io',
      'data-repo-id': 'R_kgDOPqG50w',
      'data-category-id': 'DIC_kwDOPqG5084Cu_K9',
      'data-theme': getGiscusTheme(document.documentElement.getAttribute('data-theme')),
      'data-reactions-enabled': '1',
      crossorigin: 'anonymous',
      lang: 'zh-CN',
      async: true,
      ...option,
      ...mappingConfig
    }

    const scriptElement = createScriptElement(giscusConfig)

    el.querySelector('#giscus-wrap').appendChild(scriptElement)

    if (isShuoshuo) {
      window.shuoshuoComment.destroyGiscus = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }
  }

  const changeGiscusTheme = theme => {
    const iframe = document.querySelector('#giscus-wrap iframe')
    if (iframe) {
      const message = {
        giscus: {
          setConfig: {
            theme: getGiscusTheme(theme),
            lang: 'zh-CN'  // 强制中文
          }
        }
      }
      iframe.contentWindow.postMessage(message, 'https://giscus.app')
    }
  }

  btf.addGlobalFn('themeChange', changeGiscusTheme, 'giscus')

  if (isShuoshuo) {
    'Giscus' === 'Giscus'
      ? window.shuoshuoComment = { loadComment: loadGiscus }
      : window.loadOtherComment = loadGiscus
    return
  }

  if ('Giscus' === 'Giscus' || !false) {
    if (false) btf.loadComment(document.getElementById('giscus-wrap'), loadGiscus)
    else loadGiscus()
  } else {
    window.loadOtherComment = loadGiscus
  }
})()</script></div><script src="/js/sun_moon.js" async></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>