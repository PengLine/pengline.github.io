<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Java 中各种锁的概念和应用场景 | 余一叶知秋尽</title><meta name="author" content="余一叶知秋尽"><meta name="copyright" content="余一叶知秋尽"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Java 提供了多种类型的锁，各自有何特性，如何合理使用这些锁？JVM 层面理解锁的原理和优化过程。">
<meta property="og:type" content="article">
<meta property="og:title" content="Java 中各种锁的概念和应用场景">
<meta property="og:url" content="https://pengline.github.io/2025/09/12fcec526d85480c91adb7dc237cd547/index.html">
<meta property="og:site_name" content="余一叶知秋尽">
<meta property="og:description" content="Java 提供了多种类型的锁，各自有何特性，如何合理使用这些锁？JVM 层面理解锁的原理和优化过程。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://pengline.github.io/img/essay/1745746436650174574643686.webp">
<meta property="article:published_time" content="2025-09-15T16:00:00.000Z">
<meta property="article:modified_time" content="2025-11-23T04:24:01.386Z">
<meta property="article:author" content="余一叶知秋尽">
<meta property="article:tag" content="Java 锁">
<meta property="article:tag" content="锁升级">
<meta property="article:tag" content="锁消除">
<meta property="article:tag" content="Synchronized">
<meta property="article:tag" content="Atomic">
<meta property="article:tag" content="Lock">
<meta property="article:tag" content="死锁检查">
<meta property="article:tag" content="偏向锁">
<meta property="article:tag" content="轻量级锁">
<meta property="article:tag" content="乐观锁">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pengline.github.io/img/essay/1745746436650174574643686.webp"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Java 中各种锁的概念和应用场景",
  "url": "https://pengline.github.io/2025/09/12fcec526d85480c91adb7dc237cd547/",
  "image": "https://pengline.github.io/img/essay/1745746436650174574643686.webp",
  "datePublished": "2025-09-15T16:00:00.000Z",
  "dateModified": "2025-11-23T04:24:01.386Z",
  "author": [
    {
      "@type": "Person",
      "name": "余一叶知秋尽",
      "url": "https://pengline.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://pengline.github.io/2025/09/12fcec526d85480c91adb7dc237cd547/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":30,"languages":{"author":"作者: 余一叶知秋尽","link":"链接: ","source":"来源: 余一叶知秋尽","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java 中各种锁的概念和应用场景',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/css/font.css"><svg aria-hidden="true" style="position:absolute; overflow:hidden; width:0; height:0"><symbol id="icon-sun" viewBox="0 0 1024 1024"><path d="M960 512l-128 128v192h-192l-128 128-128-128H192v-192l-128-128 128-128V192h192l128-128 128 128h192v192z" fill="#FFD878" p-id="8420"></path><path d="M736 512a224 224 0 1 0-448 0 224 224 0 1 0 448 0z" fill="#FFE4A9" p-id="8421"></path><path d="M512 109.248L626.752 224H800v173.248L914.752 512 800 626.752V800h-173.248L512 914.752 397.248 800H224v-173.248L109.248 512 224 397.248V224h173.248L512 109.248M512 64l-128 128H192v192l-128 128 128 128v192h192l128 128 128-128h192v-192l128-128-128-128V192h-192l-128-128z" fill="#4D5152" p-id="8422"></path><path d="M512 320c105.888 0 192 86.112 192 192s-86.112 192-192 192-192-86.112-192-192 86.112-192 192-192m0-32a224 224 0 1 0 0 448 224 224 0 0 0 0-448z" fill="#4D5152" p-id="8423"></path></symbol><symbol id="icon-moon" viewBox="0 0 1024 1024"><path d="M611.370667 167.082667a445.013333 445.013333 0 0 1-38.4 161.834666 477.824 477.824 0 0 1-244.736 244.394667 445.141333 445.141333 0 0 1-161.109334 38.058667 85.077333 85.077333 0 0 0-65.066666 135.722666A462.08 462.08 0 1 0 747.093333 102.058667a85.077333 85.077333 0 0 0-135.722666 65.024z" fill="#FFB531" p-id="11345"></path><path d="M329.728 274.133333l35.157333-35.157333a21.333333 21.333333 0 1 0-30.165333-30.165333l-35.157333 35.157333-35.114667-35.157333a21.333333 21.333333 0 0 0-30.165333 30.165333l35.114666 35.157333-35.114666 35.157334a21.333333 21.333333 0 1 0 30.165333 30.165333l35.114667-35.157333 35.157333 35.157333a21.333333 21.333333 0 1 0 30.165333-30.165333z" fill="#030835" p-id="11346"></path></symbol></svg><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="余一叶知秋尽" type="application/atom+xml">
</head><body><div id="web_bg" style="background-image: url(/img/202511222121.webp);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src= "/img/20241215205335173426721579192.webp" data-lazy-src="/img/butterfly-icon.webp" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">46</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">195</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">39</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list-ul"></i><span> 归档</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-outdent"></i><span> AI</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/ai/aigc/"><i class="fa-fw fas fa-cubes"></i><span> AIGC 创意平台</span></a></li><li><a class="site-page child" href="/ai/agent/medical/"><i class="fa-fw fas fa-medkit"></i><span> 医疗问答Agent</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://github.com/HengLine/ai-stocks-agent"><i class="fa-fw fas fa-line-chart"></i><span> 股票分析Agent</span></a></li><li><a class="site-page child" href="/ai/agent/video/"><i class="fa-fw fas fa-cut"></i><span> 视频混剪Agent</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://github.com/HengLine/video-shot-agent"><i class="fa-fw fas fa-file-video"></i><span> 剧本分镜Agent</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-cogs"></i><span> 工具</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/tools/json/"><i class="fa-fw fas fa-cog"></i><span> JSON 工具集</span></a></li><li><a class="site-page child" href="/tools/image/compressor/"><i class="fa-fw fas fa-image"></i><span> 图像批量压缩</span></a></li><li><a class="site-page child" href="/tools/image/watermark/"><i class="fa-fw fas fa-image"></i><span> 图像添加水印</span></a></li><li><a class="site-page child" href="/tools/image/convert/"><i class="fa-fw fas fa-image"></i><span> 图像格式转换</span></a></li><li><a class="site-page child" href="/tools/video/cropping/"><i class="fa-fw fas fa-cut"></i><span> 视频范围裁剪</span></a></li><li><a class="site-page child" href="/tools/video/watermark/"><i class="fa-fw fas fa-video"></i><span> 视频水印打码</span></a></li><li><a class="site-page child" href="/tools/download/"><i class="fa-fw fas fa-download"></i><span> 批量下载媒体</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-pencil-square"></i><span> 文学</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/literature/poems"><i class="fa-fw fas fa-align-center"></i><span> 三行诗集</span></a></li><li><a class="site-page child" href="/literature/classical"><i class="fa-fw fas fa-align-justify"></i><span> 诗词歌赋</span></a></li><li><a class="site-page child" href="/literature/modern"><i class="fa-fw fas fa-align-left"></i><span> 现代诗歌</span></a></li><li><a class="site-page child" href="/literature/journal"><i class="fa-fw fas fa-align-right"></i><span> 随心随笔</span></a></li><li><a class="site-page child" href="/literature/incomplete"><i class="fa-fw fas fa-columns"></i><span> 忘梦残句</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-commenting"></i><span> 交流</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></li><li><a class="site-page child" href="/messageboard/"><i class="fa-fw fas fa-paper-plane"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/essay/1745746436650174574643686.webp);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src= "/img/20241215205335173426721579192.webp" data-lazy-src="/img/logo.png" alt="Logo"><span class="site-name">余一叶知秋尽</span></a><a class="nav-page-title" href="/"><span class="site-name">Java 中各种锁的概念和应用场景</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list-ul"></i><span> 归档</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-outdent"></i><span> AI</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/ai/aigc/"><i class="fa-fw fas fa-cubes"></i><span> AIGC 创意平台</span></a></li><li><a class="site-page child" href="/ai/agent/medical/"><i class="fa-fw fas fa-medkit"></i><span> 医疗问答Agent</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://github.com/HengLine/ai-stocks-agent"><i class="fa-fw fas fa-line-chart"></i><span> 股票分析Agent</span></a></li><li><a class="site-page child" href="/ai/agent/video/"><i class="fa-fw fas fa-cut"></i><span> 视频混剪Agent</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://github.com/HengLine/video-shot-agent"><i class="fa-fw fas fa-file-video"></i><span> 剧本分镜Agent</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-cogs"></i><span> 工具</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/tools/json/"><i class="fa-fw fas fa-cog"></i><span> JSON 工具集</span></a></li><li><a class="site-page child" href="/tools/image/compressor/"><i class="fa-fw fas fa-image"></i><span> 图像批量压缩</span></a></li><li><a class="site-page child" href="/tools/image/watermark/"><i class="fa-fw fas fa-image"></i><span> 图像添加水印</span></a></li><li><a class="site-page child" href="/tools/image/convert/"><i class="fa-fw fas fa-image"></i><span> 图像格式转换</span></a></li><li><a class="site-page child" href="/tools/video/cropping/"><i class="fa-fw fas fa-cut"></i><span> 视频范围裁剪</span></a></li><li><a class="site-page child" href="/tools/video/watermark/"><i class="fa-fw fas fa-video"></i><span> 视频水印打码</span></a></li><li><a class="site-page child" href="/tools/download/"><i class="fa-fw fas fa-download"></i><span> 批量下载媒体</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-pencil-square"></i><span> 文学</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/literature/poems"><i class="fa-fw fas fa-align-center"></i><span> 三行诗集</span></a></li><li><a class="site-page child" href="/literature/classical"><i class="fa-fw fas fa-align-justify"></i><span> 诗词歌赋</span></a></li><li><a class="site-page child" href="/literature/modern"><i class="fa-fw fas fa-align-left"></i><span> 现代诗歌</span></a></li><li><a class="site-page child" href="/literature/journal"><i class="fa-fw fas fa-align-right"></i><span> 随心随笔</span></a></li><li><a class="site-page child" href="/literature/incomplete"><i class="fa-fw fas fa-columns"></i><span> 忘梦残句</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-commenting"></i><span> 交流</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></li><li><a class="site-page child" href="/messageboard/"><i class="fa-fw fas fa-paper-plane"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Java 中各种锁的概念和应用场景</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-09-15T16:00:00.000Z" title="发表于 2025-09-16 00:00:00">2025-09-16</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-11-23T04:24:01.386Z" title="更新于 2025-11-23 12:24:01">2025-11-23</time></span></div><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/">Java</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a></span><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h2 id="锁的种类">锁的种类</h2>
<img src= "/img/20241215205335173426721579192.webp" data-lazy-src="/imgs/image-20250917085547942.png" alt="image-20250917085547942" style="zoom: 80%;" />
<h3 id="乐观锁-VS-悲观锁">乐观锁 VS 悲观锁</h3>
<p><strong>悲观锁</strong>：认为在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。Java中，synchronized关键字和Lock的实现类都是悲观锁，还有数据库的    <code>for UPDATE</code>。</p>
<p><strong>乐观锁</strong>：认为自己在使用数据时不会有别的线程修改数据，所以不会添加锁，只是在更新数据的时候去判断之前有没有别的线程更新了这个数据。（如果已被修改则重试或提交异常）。</p>
<p>乐观锁机为无锁机制，如atomic类的cas算法自旋实现，版本号机制，如数据库version字段。</p>
<blockquote>
<ul class="lvl-1">
<li class="lvl-2">
<p>悲观锁适合写操作多的场景，先加锁可以保证写操作时数据正确。</p>
<p>对于资源竞争严重（线程冲突严重）的情况，CAS自旋的概率会比较大，从而浪费更多的CPU资源，效率低于synchronized等同步悲观锁。</p>
</li>
<li class="lvl-2">
<p>乐观锁适合读操作多的场景，不加锁的特点能够使其读操作的性能大幅提升，增加吞吐量。</p>
<p>对于资源竞争较少（线程冲突较轻）的情况，使用synchronized同步锁进行线程阻塞和唤醒切换（用户态、内核态间的切换操作额外浪费消耗cpu资源）；而CAS基于硬件实现，不需要进入内核，不需要切换线程，操作自旋几率较少，可以获得更高的性能</p>
</li>
</ul>
</blockquote>
<img src= "/img/20241215205335173426721579192.webp" data-lazy-src="/imgs/20181122101946394.png" alt="img" style="zoom:67%;" />
<h3 id="自旋锁-VS-阻塞锁">自旋锁 VS 阻塞锁</h3>
<p>阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间。如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长。</p>
<blockquote>
<p>在许多场景中，同步资源的锁定时间很短，为了这一小段时间去切换线程，线程挂起和恢复现场的花费可能会让系统得不偿失。如果物理机器有多个处理器，能够让两个或以上的线程同时并行执行，我们就可以让后面那个请求锁的线程不放弃CPU的执行时间，看看持有锁的线程是否很快就会释放锁。</p>
</blockquote>
<img src= "/img/20241215205335173426721579192.webp" data-lazy-src="/imgs/2018112210212894.png" alt="img" style="zoom:67%;" />
<blockquote>
<p>自旋等待虽然避免了线程切换的开销，但它要占用处理器时间。如果锁被占用的时间很短，自旋等待的效果就会非常好。反之，如果锁被占用的时间很长，那么自旋的线程只会白浪费处理器资源。所以，自旋等待的时间必须要有一定的限度，如果自旋超过了限定次数（默认是10次，可以使用-XX:PreBlockSpin来更改）没有成功获得锁，就应当挂起线程。</p>
</blockquote>
<p>自旋锁的实现原理同样也是CAS，AtomicInteger中调用unsafe进行自增操作的源码中的do-while循环就是一个自旋操作，如果修改数值失败则通过循环来执行自旋，直至修改成功。</p>
<p><img src= "/img/20241215205335173426721579192.webp" data-lazy-src="/imgs/20181122104052869.png" alt="img"></p>
<blockquote>
<p>**自适自旋锁：**自旋的时间（次数）不再固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也是很有可能再次成功，进而它将允许自旋等待持续相对更长的时间。如果对于某个锁，自旋很少成功获得过，那在以后尝试获取这个锁时将可能省略掉自旋过程，直接阻塞线程，避免浪费处理器资源。</p>
</blockquote>
<p>java中自旋锁的简单实现方式:</p>
<p>当有第二个线程调用lock操作时由于owner值不为空，导致循环一直被执行，直至第一个线程调用unlock函数将owner设置为null，第二个线程才能进入临界区。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpinLock</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> AtomicReference&lt;Thread&gt; cas = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;Thread&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="comment">// 让当前线程不停地的在循环体内执行实现的，当循环的条件被其他线程改变时 才能进入临界区</span></span><br><span class="line">        <span class="keyword">while</span> (!cas.compareAndSet(<span class="literal">null</span>, current)) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        cas.compareAndSet(current, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自旋锁的其他种类： 在自旋锁中 另有三种常见的锁形式:   <strong>TicketLock ，CLHlock ，MCSlock</strong></p>
<p><strong>自旋锁的优点</strong>：</p>
<blockquote>
<ol>
<li class="lvl-3">
<p>自旋锁不会使线程状态发生切换，一直处于用户态，即线程一直都是active的；不会使线程进入阻塞状态，减少了不必要的上下文切换，执行速度快</p>
</li>
<li class="lvl-3">
<p>非自旋锁在获取不到锁的时候会进入阻塞状态，从而进入内核态，当获取到锁的时候需要从内核态恢复，需要线程上下文切换。 （线程被阻塞后便进入内核（Linux）调度状态，这个会导致系统在用户态与内核态之间来回切换，严重影响锁的性能）</p>
</li>
</ol>
</blockquote>
<p><strong>自旋锁的缺点</strong>：</p>
<blockquote>
<ol>
<li class="lvl-3">
<p>消耗CPU：如果某个线程持有锁的时间过长，就会导致其它等待获取锁的线程进入循环等待。使用不当会造成CPU使用率极高。</p>
</li>
<li class="lvl-3">
<p>非公平：自旋锁不是公平的，即无法满足等待时间最长的线程优先获取锁。不公平的锁就会存在“线程饥饿”问题。</p>
</li>
</ol>
</blockquote>
<p>Ticket锁主要解决的是访问顺序的问题（<strong>公平性</strong>），主要的问题是在多核cpu上。</p>
<p>最先请求获取锁的线程可以最先获取到锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TicketLock</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">AtomicInteger</span> <span class="variable">serviceNum</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">AtomicInteger</span> <span class="variable">ticketNum</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Integer&gt; LOCAL = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">myticket</span> <span class="operator">=</span> ticketNum.getAndIncrement();</span><br><span class="line">        LOCAL.set(myticket); <span class="comment">// 防止被外部修改myticket值</span></span><br><span class="line">  <span class="comment">// 每次都要查询一个serviceNum 服务号，影响性能（必须要到主内存读取，并阻止其他cpu修改）。</span></span><br><span class="line">        <span class="keyword">while</span> (myticket != serviceNum.get()) &#123; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">myticket</span> <span class="operator">=</span> LOCAL.get();</span><br><span class="line">        serviceNum.compareAndSet(myticket, myticket + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>TicketLock存在的问题:</strong></p>
<p>多处理器系统上，每个进程/线程占用的处理器都在读写同一个变量serviceNum ，每次读写操作都必须在多个处理器缓存之间进行缓存同步，这会导致繁重的系统总线和内存的流量，大大降低系统整体的性能。</p>
<p>CLHLock 和MCSLock 则是两种类型相似的公平锁，采用链表的形式进行排序，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CLHLock</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">CLHNode</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">isLocked</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> CLHNode     tail;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;CLHNode&gt; LOCAL = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;CLHNode&gt;();</span><br><span class="line">    <span class="comment">// 将指定类型的指定的volatile引用字段进行原子更新(tail获取、设定值两个操作是非原子的)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicReferenceFieldUpdater&lt;CLHLock, CLHNode&gt; UPDATER = AtomicReferenceFieldUpdater.newUpdater(CLHLock.class, CLHNode.class, <span class="string">&quot;tail&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">CLHNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CLHNode</span>();</span><br><span class="line">        LOCAL.set(node);</span><br><span class="line">        <span class="type">CLHNode</span> <span class="variable">preNode</span> <span class="operator">=</span> UPDATER.getAndSet(<span class="built_in">this</span>, node);</span><br><span class="line">        <span class="keyword">if</span> (preNode != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (preNode.isLocked) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            preNode = <span class="literal">null</span>;</span><br><span class="line">            LOCAL.set(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">CLHNode</span> <span class="variable">node</span> <span class="operator">=</span> LOCAL.get();</span><br><span class="line">        <span class="keyword">if</span> (!UPDATER.compareAndSet(<span class="built_in">this</span>, node, <span class="literal">null</span>)) &#123;</span><br><span class="line">            node.isLocked = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        node = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>CLHlock是不停的查询前驱变量， 导致不适合在NUMA 架构下使用（在这种结构下，每个线程分布在不同的物理内存区域）</p>
<p>MCSLock则是对本地变量的节点进行循环。不存在CLHlock 的问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MCSLock</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MCSNode</span> &#123;</span><br><span class="line">        <span class="keyword">volatile</span> MCSNode next;</span><br><span class="line">        <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">isLocked</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;MCSNode&gt; NODE = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;MCSNode&gt;();</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unused&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> MCSNode queue;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicReferenceFieldUpdater&lt;MCSLock, MCSNode&gt; UPDATER = AtomicReferenceFieldUpdater.newUpdater(MCSLock.class, MCSNode.class, <span class="string">&quot;queue&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">MCSNode</span> <span class="variable">currentNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MCSNode</span>();</span><br><span class="line">        NODE.set(currentNode);</span><br><span class="line">        <span class="type">MCSNode</span> <span class="variable">preNode</span> <span class="operator">=</span> UPDATER.getAndSet(<span class="built_in">this</span>, currentNode);</span><br><span class="line">        <span class="keyword">if</span> (preNode != <span class="literal">null</span>) &#123;</span><br><span class="line">            preNode.next = currentNode;</span><br><span class="line">            <span class="keyword">while</span> (currentNode.isLocked) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">MCSNode</span> <span class="variable">currentNode</span> <span class="operator">=</span> NODE.get();</span><br><span class="line">        <span class="keyword">if</span> (currentNode.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (UPDATER.compareAndSet(<span class="built_in">this</span>, currentNode, <span class="literal">null</span>)) &#123;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (currentNode.next == <span class="literal">null</span>) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            currentNode.next.isLocked = <span class="literal">false</span>;</span><br><span class="line">            currentNode.next = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul class="lvl-1">
<li class="lvl-2">
<p>CLH 的队列是隐式的队列，没有真实的后继结点属性。</p>
</li>
<li class="lvl-2">
<p>MCS 的队列是显式的队列，有真实的后继结点属性。</p>
</li>
</ul>
</blockquote>
<p>JAVA中，能够进入\退出、阻塞状态或包含阻塞锁的方法有 ，<strong>synchronized</strong> ，<strong>ReentrantLock</strong>，<strong>Object.wait()和notify()</strong>,   <strong>LockSupport.park()和unpart()</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CLHLock</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">CLHNode</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> Thread isLocked;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> CLHNode tail;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;CLHNode&gt; LOCAL = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;CLHNode&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicReferenceFieldUpdater&lt;CLHLock, CLHNode&gt; UPDATER = AtomicReferenceFieldUpdater.newUpdater(CLHLock.class, CLHNode.class, <span class="string">&quot;tail&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">CLHNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CLHNode</span>();</span><br><span class="line">        LOCAL.set(node);</span><br><span class="line">        <span class="type">CLHNode</span> <span class="variable">preNode</span> <span class="operator">=</span> UPDATER.getAndSet(<span class="built_in">this</span>, node);</span><br><span class="line">        <span class="keyword">if</span> (preNode != <span class="literal">null</span>) &#123;</span><br><span class="line">            preNode.isLocked = Thread.currentThread();</span><br><span class="line">            LockSupport.park(<span class="built_in">this</span>);</span><br><span class="line">            preNode = <span class="literal">null</span>;</span><br><span class="line">            LOCAL.set(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">CLHNode</span> <span class="variable">node</span> <span class="operator">=</span> LOCAL.get();</span><br><span class="line">        <span class="keyword">if</span> (!UPDATER.compareAndSet(<span class="built_in">this</span>, node, <span class="literal">null</span>)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;unlock\t&quot;</span> + node.isLocked.getName());</span><br><span class="line">            LockSupport.unpark(node.isLocked);</span><br><span class="line">        &#125;</span><br><span class="line">        node = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>阻塞锁的优势在于，阻塞的线程不会占用cpu时间， 不会导致 CPu占用率过高，但进入时间以及恢复时间都要比自旋锁略慢。在竞争激烈的情况下 阻塞锁的性能要明显高于 自旋锁。</p>
</blockquote>
<p><strong>在线程竞争不激烈的情况下，使用自旋锁，竞争激烈的情况下使用阻塞锁</strong>。</p>
<h3 id="无锁-VS-偏向锁"><a target="_blank" rel="noopener" href="https://www.cnblogs.com/jyroy/p/11365935.html">无锁 VS 偏向锁 </a></h3>
<p>偏向锁实际上是一种锁优化的，其目的是为了减少数据在无竞争情况下的性能消耗。</p>
<p>核心思想就是<strong>锁会偏向第一个获取它的线程</strong>，在接下来的执行过程中该锁没有其他的线程获取，则持有偏向锁的线程永远不需要再同步。</p>
<blockquote>
<p><strong>偏向锁的获取</strong><br>
当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里储存锁偏向的线程ID。以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需要检查当前Mark Word中储存的线程是否指向当前线程，如果成功，表示已经获得对象锁；如果检测失败，则需要再测试一下Mark Word中偏向锁的标志是否已经被置为1（表示当前锁是偏向锁）：如果没有则使用CAS操作竞争锁，如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程。</p>
</blockquote>
<blockquote>
<p><strong>偏向锁的撤销</strong><br>
偏向锁使用一种等待竞争出现才释放锁的机制，所以当有其他线程尝试获得锁时，才会释放锁。</p>
<p>偏向锁的撤销，需要等到安全点。它首先会暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着，如果不处于活动状态，则将对象头设置为无锁状态；如果依然活动，拥有偏向锁的栈会被执行，遍历偏向对象的锁记录，栈中的锁记录和对象头的Mark Word要么重新偏向其他线程，要么恢复到无锁或者标记对象不合适作为偏向锁（膨胀为轻量级锁），最后唤醒暂停的线程。</p>
</blockquote>
<blockquote>
<p><strong>关闭偏向锁</strong><br>
偏向锁在Java运行环境中默认开启，但是不会随着程序启动立即生效，而是在启动几秒种后才激活，可以使用参数关闭延迟：<br>
<strong>-XX：BiasedLockingStartupDelay=0</strong><br>
同样可以关闭偏向锁（程序默认进入轻量级锁）<br>
<strong>-XX：UseBiasedLocking=false</strong></p>
</blockquote>
<h3 id="轻量级锁-VS-重量级锁">轻量级锁 VS 重量级锁</h3>
<p>重量级锁就是最开始的线程阻塞操作，又叫悲观锁。</p>
<p>相对轻量级而言，重量级锁的阻塞挂起/唤醒线程需要从底层的的<strong>用户态</strong>转为<strong>内核态</strong> ，消耗CPU资源。</p>
<blockquote>
<p>轻量级锁是JDK1.6之中加入的新型锁机制，它并不是来代替重量级锁的，他的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。</p>
</blockquote>
<p><strong>轻量级锁加锁</strong></p>
<blockquote>
<p>线程在执行同步块之前，JVM会现在当前线程的栈帧中创建用于储存锁记录的空间（LockRecord），并将对象头的Mark Word信息复制到锁记录中。然后线程尝试使用CAS将对象头的MarkWord替换为指向锁记录的指针。</p>
<p>如果成功，当前线程获得锁，并且对象的锁标志位转变为“00”，如果失败，表示其他线程竞争锁，当前线程便会尝试自旋获取锁。</p>
<p><strong>如果有两条以上的线程竞争同一个锁，那么轻量级锁就不再有效</strong>，要膨胀为重量级锁，锁标志的状态变为“10”，MarkWord中储存的就是指向重量级锁（互斥量）的指针，后面等待的线程也要进入阻塞状态。</p>
</blockquote>
<p><strong>轻量级锁解锁</strong></p>
<blockquote>
<p>轻量级锁解锁时，同样通过CAS操作将对象头换回来。如果成功，则表示没有竞争发生。如果失败，说明有其他线程尝试过获取该锁，锁同样会膨胀为重量级锁。在释放锁的同时，唤醒被挂起的线程。</p>
</blockquote>
<h3 id="公平锁-VS-非公平锁">公平锁 VS 非公平锁</h3>
<p><strong>公平锁（Fair Lock）：</strong> 若等待队列非空，则直接入队；否则尝试获取锁</p>
<blockquote>
<ul class="lvl-1">
<li class="lvl-2">
<p>当一个线程尝试获取锁时，<strong>即使当前锁是可用的（没有被占用）</strong>，它也会<strong>先检查等待队列中是否有其他线程在排队</strong>。</p>
</li>
<li class="lvl-2">
<p>如果有排队线程，当前线程会<strong>直接进入队列末尾排队</strong>，而不是“插队”获取锁。</p>
</li>
<li class="lvl-2">
<p>保证了“先来先得”的公平性，避免线程饥饿。</p>
</li>
</ul>
</blockquote>
<p>**非公平锁（Non-fair Lock）：**先尝试获取锁，获取失败后，放入队列</p>
<blockquote>
<ul class="lvl-1">
<li class="lvl-2">
<p>当一个线程尝试获取锁时，<strong>不管等待队列中是否有其他线程</strong>，它都会<strong>首先尝试直接获取锁（CAS 抢占）</strong>。</p>
</li>
<li class="lvl-2">
<p>如果抢锁成功 → 直接获得锁，不管队列里有没有“老员工”在排队。</p>
</li>
<li class="lvl-2">
<p>如果抢锁失败 → 才进入等待队列排队。</p>
</li>
<li class="lvl-2">
<p>这样可能导致“插队”，但<strong>吞吐量通常更高</strong>，因为减少了线程挂起/唤醒的开销。</p>
</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ReentrantLock</span> <span class="variable">fairLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(<span class="literal">true</span>);   <span class="comment">// 公平锁</span></span><br><span class="line"><span class="type">ReentrantLock</span> <span class="variable">unfairLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();     <span class="comment">// 非公平锁（默认）</span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>特性</th>
<th>公平锁</th>
<th>非公平锁</th>
</tr>
</thead>
<tbody>
<tr>
<td>获取锁时行为</td>
<td>检查队列，有排队则入队</td>
<td>直接尝试抢锁，失败才入队</td>
</tr>
<tr>
<td>吞吐量</td>
<td>较低（频繁上下文切换）</td>
<td>较高（减少排队，直接抢占）</td>
</tr>
<tr>
<td>公平性</td>
<td>保证 FIFO，无饥饿</td>
<td>不保证，可能插队</td>
</tr>
<tr>
<td>默认</td>
<td>否</td>
<td>是</td>
</tr>
</tbody>
</table>
<h3 id="可重入锁-VS-非可重入锁">可重入锁 VS 非可重入锁</h3>
<p>可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁（前提是锁对象是同一个对象或者class），不会因为之前已经获取过还没释放而阻塞。</p>
<blockquote>
<ul class="lvl-1">
<li class="lvl-2">
<p>Java中<code>ReentrantLock</code>和<code>synchronized</code>都是可重入锁，可重入锁的一个优点是可一定程度避免死锁。</p>
</li>
<li class="lvl-2">
<p>非可重入锁<code>NonReentrantLock</code>。</p>
</li>
</ul>
</blockquote>
<p>为什么可重入锁就可以在嵌套调用时可以自动获得锁呢？</p>
<blockquote>
<p>举例：有多个人在排队打水，此时管理员允许锁和同一个人的多个水桶绑定。这个人用多个水桶打水时，第一个水桶和锁绑定并打完水之后，第二个水桶也可以直接和锁绑定并开始打水，所有的水桶都打完水之后打水人才会将锁还给管理员。这个人的所有打水流程都能够成功执行，后续等待的人也能够打到水。</p>
<img src= "/img/20241215205335173426721579192.webp" data-lazy-src="/imgs/2018112210434386.png" alt="img" style="zoom:50%;" />
</blockquote>
<p><strong>可重入锁的实现</strong></p>
<p>可重入锁，也叫做递归锁，指的是同一线程，在外层函数获得锁之后 ，内层递归函数仍然可以获取该锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getId() + <span class="string">&quot;--&gt; get&quot;</span>);</span><br><span class="line">        set();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getId() + <span class="string">&quot;--&gt; set&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Test</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(ss).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(ss).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(ss).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>可重入锁最大的作用是避免死锁</strong></p>
<p>对于自旋锁来说， 若有同一线程两次调用<code>lock()</code> ，会导致第二次调用lock位置进行自旋，产生了死锁。说明这个锁并不是可重入的。</p>
<p><strong>自旋锁实现可重入锁</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpinLock1</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> AtomicReference&lt;Thread&gt; owner = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="keyword">if</span> (current == owner.get()) &#123;</span><br><span class="line">            count++; <span class="comment">// 线程计数</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!owner.compareAndSet(<span class="literal">null</span>, current)) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="keyword">if</span> (current == owner.get()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (count != <span class="number">0</span>) &#123;</span><br><span class="line">                count--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                owner.compareAndSet(current, <span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="独享锁（互斥）-VS-共享锁">独享锁（互斥） VS 共享锁</h3>
<p><strong>独享锁</strong>（Exclusive Lock / 互斥锁）</p>
<p>同一时刻<strong>只允许一个线程</strong>持有该锁，其他线程必须等待锁释放后才能获取。</p>
<blockquote>
<ul class="lvl-1">
<li class="lvl-2">
<p>互斥性：保证线程安全，避免数据竞争。</p>
</li>
<li class="lvl-2">
<p>适用于写操作或需要独占资源的场景。</p>
</li>
<li class="lvl-2">
<p>性能较低（因为并发度低），但安全性高。</p>
</li>
</ul>
</blockquote>
<p>Java 中的实现：</p>
<blockquote>
<ul class="lvl-1">
<li class="lvl-2">
<p><code>synchronized</code> 关键字（隐式锁）</p>
</li>
<li class="lvl-2">
<p><code>ReentrantLock</code>（显式锁，默认是独享锁）</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 同一时刻只有一个线程能执行 `increment()` 方法。 </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>共享锁</strong>（Shared Lock / 读锁）</p>
<p>允许多个线程<strong>同时持有该锁</strong>，前提是这些线程的操作是“兼容”的（如多个读操作）。</p>
<blockquote>
<ul class="lvl-1">
<li class="lvl-2">
<p>允许多个线程并发读取，提高并发性能。</p>
</li>
<li class="lvl-2">
<p>不允许与写操作（独享锁）同时进行。</p>
</li>
<li class="lvl-2">
<p>适用于“读多写少”的场景。</p>
</li>
</ul>
</blockquote>
<p>Java 中的实现：</p>
<blockquote>
<ul class="lvl-1">
<li class="lvl-2">
<p><code>ReentrantReadWriteLock.ReadLock</code>（共享锁）</p>
</li>
<li class="lvl-2">
<p><code>ReentrantReadWriteLock.WriteLock</code>（独享锁）</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 多个线程可同时调用 `read()`，但调用 `write()` 时，其他读/写线程都必须等待。 </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Data</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String value;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantReadWriteLock</span> <span class="variable">rwLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读操作 - 共享锁</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">read</span><span class="params">()</span> &#123;</span><br><span class="line">        rwLock.readLock().lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            rwLock.readLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写操作 - 独享锁</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(String newValue)</span> &#123;</span><br><span class="line">        rwLock.writeLock().lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.value = newValue;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            rwLock.writeLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<table>
<thead>
<tr>
<th>特性</th>
<th>独享锁（互斥锁）</th>
<th>共享锁（读锁）</th>
</tr>
</thead>
<tbody>
<tr>
<td>持有者数量</td>
<td>只能被一个线程持有</td>
<td>可被多个线程同时持有</td>
</tr>
<tr>
<td>适用场景</td>
<td>写操作、修改资源</td>
<td>读操作、查询资源</td>
</tr>
<tr>
<td>并发性</td>
<td>低（串行化）</td>
<td>高（允许多读）</td>
</tr>
<tr>
<td>典型实现</td>
<td><code>synchronized</code>,<code>ReentrantLock</code></td>
<td><code>ReentrantReadWriteLock.ReadLock</code></td>
</tr>
<tr>
<td>与对方的兼容性</td>
<td>不能与其他任何锁共存</td>
<td>可与其他共享锁共存，但不能与独享锁共存</td>
</tr>
<tr>
<td>性能</td>
<td>较低（阻塞其他线程）</td>
<td>较高（读操作可并发）</td>
</tr>
</tbody>
</table>
<blockquote>
<ul class="lvl-1">
<li class="lvl-2">
<p><strong>读 &gt;&gt; 写</strong> ➜ 用 <code>ReentrantReadWriteLock</code>（共享读 + 独占写）</p>
</li>
<li class="lvl-2">
<p><strong>写频繁 或 读写差不多</strong> ➜ 用 <code>ReentrantLock</code> 或 <code>synchronized</code>（简单高效）</p>
</li>
<li class="lvl-2">
<p><strong>追求极致性能 + 读多写少</strong> ➜ 甚至可以考虑 <code>StampedLock</code>（Java 8+，支持乐观读）</p>
</li>
</ul>
</blockquote>
<h2 id="如何避免死锁">如何避免死锁</h2>
<p>活锁：线程的状态可以改变但是却不能继续执行</p>
<p><strong>死锁发生四个条件</strong>：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>互斥条件</strong>：一个资源每次只能被一个线程使用。要求对所分配的资源（如打印机）进行排他性控制，即在一段时间内某 资源仅为一个线程所占有。此时若有其他线程请求该资源，则请求线程只能等待。</p>
</li>
<li class="lvl-2">
<p><strong>请求与保持条件</strong>：一个线程因请求资源而阻塞时，对已获得的资源保持不放（线程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其他线程占有，此时请求线程被阻塞，但对自己已获得的资源保持不放）。</p>
</li>
<li class="lvl-2">
<p><strong>不剥夺条件</strong>：线程已获得的资源，在末使用完之前，不能强行剥夺（只能是主动释放)。</p>
</li>
<li class="lvl-2">
<p><strong>循环等待条件</strong>：若干线程之间形成一种头尾相接的循环等待资源关系。</p>
</li>
</ul>
<blockquote>
<p>当以上四个条件均满足，必然会造成死锁，发生死锁的线程无法进行下去，它们所持有的资源也无法释放。这样会导致CPU的吞吐量下降。当多个线程需要相同的一些锁，但是按照不同的顺序加锁，死锁就很容易发生。</p>
</blockquote>
<h3 id="避免死锁">避免死锁</h3>
<p>（破坏其中一个条件即可）：</p>
<p>最简单的方法就是阻止循环等待条件。将系统中所有的资源设置标志位、排序，规定所有的线程申请资源必须以一定的顺序（升序或降序）做操作来避免死锁，获取所有锁的顺序保持一致。</p>
<blockquote>
<ul class="lvl-1">
<li class="lvl-2">
<p>让一个线程一次性申请所有的资源（破坏请求与保持条件）</p>
</li>
<li class="lvl-2">
<p>加锁添加时限或通过 Lock 可重入锁，释放线程占用的锁（线程尝试获取锁的时候加上一定的时限，超过时限则放弃对该锁的请求，并释放自己占有的锁）（破坏不剥夺条件）</p>
</li>
<li class="lvl-2">
<p>加锁顺序保持一致（线程按照一定的顺序加锁，确保所有的线程都是按照相同的顺序获得锁）（破坏循环等待条件）</p>
</li>
</ul>
</blockquote>
<h3 id="死锁检查">死锁检查</h3>
<p>死锁可能导致线程池满，线程无法销毁，一直占用。服务假死状态，CPU飙升</p>
<p>使用<code>jps</code>， <code>jstack</code> 或 <code>jconsole</code> 工具<code>dump</code>线程分析，它是 jdk 自带的线程堆栈分析工具。</p>
<p>arthas 分析线程</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">jps -l        #用jps来找到当前java的进程号,l表示列出路径</span><br><span class="line">jstack -l 14804 # 查看进程下所有线程状态（直接列出异常线程状态：Found one Java-level deadlock）</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">JConsole是一个图形化的监控工具！通过 线程 -&gt; 检测死锁    ，可查看死锁</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">jvisualvm是一个图形化的监控工具！ 线程中以红色表示异常线程</span></span><br></pre></td></tr></table></figure>
<h3 id="死锁复现">死锁复现</h3>
<p>解决一下死锁，只需要将加锁顺序改成一样，即都先加锁o1，再加锁o2</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一个简单的死锁类：加锁顺序不一致，且互相等待/争夺锁资源</span></span><br><span class="line"><span class="comment"> * 当DeadLock类的对象flag==1时（td1），先锁定o1,睡眠500毫秒</span></span><br><span class="line"><span class="comment"> * 而td1在睡眠的时候另一个flag==0的对象（td2）线程启动，先锁定o2,睡眠500毫秒</span></span><br><span class="line"><span class="comment"> * td1睡眠结束后需要锁定o2才能继续执行，而此时o2已被td2锁定；</span></span><br><span class="line"><span class="comment"> * td2睡眠结束后需要锁定o1才能继续执行，而此时o1已被td1锁定；</span></span><br><span class="line"><span class="comment"> * td1、td2相互等待，都需要得到对方锁定的资源才能继续执行，从而死锁。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadLock</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//静态对象是类的所有对象共享的  </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">o1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">o2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;flag=&quot;</span> + flag);</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (o1) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (o2) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (o2) &#123; <span class="comment">// 此处改为o1</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (o1) &#123;  <span class="comment">// 此处改为o2，即可避免死锁</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">DeadLock</span> <span class="variable">td1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeadLock</span>();</span><br><span class="line">        <span class="type">DeadLock</span> <span class="variable">td2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeadLock</span>();</span><br><span class="line">        td1.flag = <span class="number">1</span>;</span><br><span class="line">        td2.flag = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//td1,td2都处于可执行状态，但JVM线程调度先执行哪个线程是不确定的。  </span></span><br><span class="line">        <span class="comment">//td2的run()可能在td1的run()之前运行  </span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(td1).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(td2).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<h2 id="对象头与锁">对象头与锁</h2>
<p>锁就保存在对象头中。</p>
<p>Hotpot虚拟机的对象头分两部分信息：<strong>Mark Word（标记字段）、Klass Pointer（类型指针）</strong>。</p>
<p>Mark Word：</p>
<blockquote>
<p>默认存储对象的<u>HashCode，分代年龄和锁标志位</u>信息。这些信息都是与对象自身定义无关的数据，所以Mark Word被设计成一个非固定的数据结构以便在极小的空间内存存储尽量多的数据。它会根据对象的状态复用自己的存储空间，也就是说在运行期间Mark Word里存储的<u>数据会随着锁标志位的变化而变化</u>。这部分数据长度在32位和64位虚拟机中分别为32bit和64bit，它又称为“MarkWord”，它是实现锁的关键。</p>
</blockquote>
<p>Klass Point：</p>
<blockquote>
<p>对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。如果是数组的话，还有一个额外的空间储存数组长度。</p>
</blockquote>
<p>它的变化状态如下所示<br>
<img src= "/img/20241215205335173426721579192.webp" data-lazy-src="/imgs/20151217151455512" alt="img" style="zoom:67%;" /></p>
<p>如：synchronized是悲观锁，在操作同步资源之前需要给同步资源先加锁，这把锁就是存在Java对象头里的</p>
<h3 id="锁优化">锁优化</h3>
<p>主要是jdk中针对 Synchronized 关键字的优化。</p>
<p>Java 中的 <code>synchronized</code> 是最常用的同步机制，但早期版本（JDK 1.5 之前）性能较差，因为每次加锁/解锁都要调用操作系统内核的 Mutex（互斥量），涉及<strong>用户态到内核态切换</strong>，开销大。</p>
<p>从 JDK 1.6 开始，JVM 对 <code>synchronized</code> 做了大量优化，引入了  <strong>“锁优化”</strong> 手段：</p>
<blockquote>
<ul class="lvl-1">
<li class="lvl-2">
<p>锁消除（Lock Elimination）</p>
</li>
<li class="lvl-2">
<p>锁粗化（Lock Coarsening）</p>
</li>
<li class="lvl-2">
<p>自旋锁 &amp; 自适应自旋（Spin Lock）</p>
</li>
<li class="lvl-2">
<p>偏向锁（Biased Locking）</p>
</li>
<li class="lvl-2">
<p>轻量级锁（Lightweight Locking）</p>
</li>
<li class="lvl-2">
<p>重量级锁（Heavyweight Locking）→ 即“锁膨胀”</p>
</li>
</ul>
</blockquote>
<h3 id="锁消除">锁消除</h3>
<p>JVM 在 JIT 编译时，通过<strong>逃逸分析（Escape Analysis）</strong> 发现某个锁对象<strong>不会被多个线程访问</strong>（即“未逃逸”），则直接<strong>移除不必要的加锁操作</strong>。</p>
<blockquote>
<ul class="lvl-1">
<li class="lvl-2">
<p>对象是局部变量，且不会被其他线程访问。</p>
</li>
<li class="lvl-2">
<p>字符串拼接中 <code>StringBuffer</code> 的 <code>append()</code> 方法（内部有 <code>synchronized</code>，但局部使用时可消除）。</p>
</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// append() 是同步方法，但因为 sb 是局部变量，不会被其他线程访问，JVM 会消除锁，等价于用 StringBuilder。 </span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">concat</span><span class="params">(String s1, String s2)</span> &#123;</span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(); <span class="comment">// 局部变量，不逃逸</span></span><br><span class="line">    sb.append(s1);</span><br><span class="line">    sb.append(s2);</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认开启（JDK 1.6+），可通过参数控制：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:+DoEscapeAnalysis      # 开启逃逸分析（默认开启）</span><br><span class="line">-XX:+EliminateLocks        # 开启锁消除（默认开启）</span><br></pre></td></tr></table></figure>
<h3 id="锁粗化">锁粗化</h3>
<p>如果一段代码中<strong>对同一个对象反复加锁、解锁</strong>（如循环内），JVM 会将多个加锁操作<strong>合并成一个范围更大的锁</strong>，减少加解锁次数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 源代码</span></span><br><span class="line"><span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">    doSomething1();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">    doSomething2();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">    doSomething3();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// JVM 优化为：</span></span><br><span class="line"><span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">    doSomething1();</span><br><span class="line">    doSomething2();</span><br><span class="line">    doSomething3();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实际代码</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (String.class)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// JIT优化后</span></span><br><span class="line"><span class="keyword">synchronized</span> (String.class) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="锁升级（锁膨胀）">锁升级（锁膨胀）</h3>
<p>指锁从<strong>轻量级 → 重量级</strong>的升级过程。这是 <code>synchronized</code> 实现的核心机制之一。</p>
<p>Java 对象头中有一个 <strong>Mark Word</strong>，用于存储锁状态。锁有四种状态（按竞争强度升级）</p>
<blockquote>
<p>在Java中，锁共有4种状态，级别从低到高依次为：无状态锁，偏向锁，轻量级锁和重量级锁状态，这几个状态会随着竞争情况逐渐升级。锁可以升级但不能降级。</p>
<p>锁的四种状态由低到高依次为：<strong>无锁    -&gt;    偏向锁    -&gt;    轻量级锁    -&gt;    重量级锁</strong></p>
</blockquote>
<img src= "/img/20241215205335173426721579192.webp" data-lazy-src="/imgs/20210205103013432.png" alt="img" style="zoom: 67%;" />
<p>并且四种状态会随着竞争的情况逐渐升级，而且是<strong>不可逆</strong>的过程</p>
<img src= "/img/20241215205335173426721579192.webp" data-lazy-src="/imgs/20200603161323889.png" alt="img" style="zoom: 80%;" />
<table>
<thead>
<tr>
<th>锁</th>
<th>优点</th>
<th>缺点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>偏向锁</td>
<td>加锁和解锁不需要额外的消耗，和执行非同步方法相比仅存在纳秒级的差距</td>
<td>如果线程间存在锁竞争，会带来额外的锁撤销的消耗</td>
<td>适用于只有一个线程访问同步块场景</td>
</tr>
<tr>
<td>轻量级锁</td>
<td>竞争的线程不会阻塞，提高了程序的响应速度</td>
<td>如果始终得不到索竞争的线程，使用自旋会消耗CPU</td>
<td>追求响应速度，同步块执行速度非常快</td>
</tr>
<tr>
<td>重量级锁</td>
<td>线程竞争不使用自旋，不会消耗CPU</td>
<td>线程阻塞，响应时间缓慢</td>
<td>追求吞吐量，同步块执行速度较慢</td>
</tr>
</tbody>
</table>
<blockquote>
<ul class="lvl-1">
<li class="lvl-2">
<p><strong>无锁</strong>：指<strong>没有对资源进行锁定</strong>，所有的线程都能访问并修改同一个资源，但同时只有一个线程能修改成功。果有多个线程修改同一个值，必定会有一个线程能修改成功，而其他修改失败的线程会不断重试直到修改成功。</p>
</li>
<li class="lvl-2">
<p><strong>偏向锁</strong>：指当<strong>一段同步代码一直被同一个线程所访问</strong>时，即不存在多个线程的竞争时，那么该线程在后续访问时便会自动获得锁，从而降低获取锁带来的消耗，即提高性能。</p>
<ul class="lvl-3">
<li class="lvl-4">初次执行到synchronized代码块的时候，锁对象变成偏向锁（通过CAS修改对象头里的锁标志位。执行完同步代码块后，线程并不会主动释放偏向锁，当第二次到达同步代码块时，线程会判断此时持有锁的线程是否就是自己，如果是则正常往下执行。由于之前没有释放锁，也就没有额外开销。偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程是不会主动释放偏向锁的。</li>
<li class="lvl-4">关于偏向锁的撤销，需要等待全局安全点，即在某个时间点上没有字节码正在执行时，它会先暂停拥有偏向锁的线程，然后判断锁对象是否处于被锁定状态。如果线程不处于活动状态，则将对象头设置成无锁状态，并撤销偏向锁，恢复到无锁（标志位为01）或轻量级锁（标志位为00）的状态。</li>
</ul>
</li>
<li class="lvl-2">
<p><strong>轻量级锁</strong>：指当锁是偏向锁的时候，却<strong>被另外的线程所访问。存在少量锁竞争</strong>，此时偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，线程不会阻塞，从而提高性能（JVM默认自旋次数为 -XX:PreBlockSpin=10）。</p>
<ul class="lvl-3">
<li class="lvl-4">轻量级锁的获取主要由两种情况：<br>
① 当关闭偏向锁功能时；<br>
② 由于多个线程竞争偏向锁导致偏向锁升级为轻量级锁。</li>
</ul>
</li>
<li class="lvl-2">
<p><strong>重量级锁</strong>：是指当有一个线程获取锁之后，其余<strong>所有等待获取该锁的线程都会处于阻塞状态</strong>（用户态 - 内核态）。由操作系统来负责线程间的调度和线程的状态变更。而这样会出现频繁地对线程运行状态的切换，线程的挂起和唤醒，从而消耗大量的系统资计数器记录自旋次数，达到最大自旋次数的线程，会将轻量级锁升级为重量级锁，当后续线程尝试获取锁时，发现被占用的锁是重量级锁，则直接将自己挂起（而不是忙等），等待将来被唤醒。</p>
</li>
</ul>
</blockquote>
<img src= "/img/20241215205335173426721579192.webp" data-lazy-src="/imgs/20200606123648335.png" alt="img" style="zoom:80%;" />
<p><strong>锁升级过程详解</strong>：</p>
<p>① <strong>无锁 → 偏向锁</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>第一个线程访问同步块时，JVM 会将对象 Mark Word 设置为偏向该线程 ID。</p>
</li>
<li class="lvl-2">
<p>后续该线程再进入，无需任何同步操作（零成本）。</p>
</li>
<li class="lvl-2">
<p>若有其他线程竞争 → 撤销偏向锁 → 升级为轻量级锁。</p>
</li>
</ul>
<blockquote>
<p><strong>注意：JDK 15 开始默认禁用偏向锁，JDK 17+ 已移除。</strong></p>
</blockquote>
<p>② <strong>轻量级锁</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>通过 <strong>CAS（Compare And Swap）</strong> 尝试将对象头指向当前线程栈中的 Lock Record。</p>
</li>
<li class="lvl-2">
<p>成功 → 获取锁。</p>
</li>
<li class="lvl-2">
<p>失败 → 自旋重试（自适应自旋）。</p>
</li>
<li class="lvl-2">
<p>自旋多次失败 → 升级为重量级锁。</p>
</li>
</ul>
<p>③ <strong>重量级锁</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>调用操作系统 Mutex，线程挂起进入阻塞队列。</p>
</li>
<li class="lvl-2">
<p>由 OS 调度唤醒，开销最大。</p>
</li>
<li class="lvl-2">
<p>但适合长时间持有锁或高竞争场景。</p>
</li>
</ul>
<h2 id="Java-提供的锁">Java 提供的锁</h2>
<p>造成线程安全问题的主要诱因：一是存在共享数据(也称临界资源)，二是存在多条线程共同操作共享数据</p>
<h3 id="Synchronized">Synchronized</h3>
<p>又称 <strong>对象监视器（Object Monitor）</strong>。</p>
<p>当一个线程正在访问一个对象的 synchronized 实例方法，那么其他线程不能访问该对象的其他 synchronized 方法（一个对象只有一把锁），同一线程内是可重入的，如果两个实例对象获取同一把锁，则会出现锁失效：</p>
<p>Synchronized关键字会让没有得到锁资源的线程进入<strong>BLOCKED</strong>状态，而后在争夺到锁资源后恢复为<strong>RUNNABLE</strong>状态，这个过程中涉及到操作系统<strong>用户模式</strong>和<strong>内核模式</strong>的转换，代价比较高（优化：增加了从<strong>偏向锁</strong>到<strong>轻量级锁</strong>再到<strong>重量级锁</strong>的过度）</p>
<h4 id="锁定范围">锁定范围</h4>
<p>Synchronized 的使用不同，加锁范围会有所不同：</p>
<blockquote>
<ol>
<li class="lvl-3">
<p>修饰一个代码块，被修饰的代码块称为同步语句块，其作用的范围是大括号{}括起来的代码，作用的对象是<strong>调用这个代码块的对象（一个线程访问一个对象中的synchronized(this)同步代码块时，其他试图访问该对象的线程将被阻塞），如果为参数对象（synchronized (dto.getLock())）,则只会锁定阻塞同一对象</strong>；</p>
</li>
<li class="lvl-3">
<p>修饰一个方法，被修饰的方法称为同步方法，其作用的范围是整个方法，作用的对象是<strong>调用这个方法的对象（两个对象间不会锁）</strong>；</p>
</li>
<li class="lvl-3">
<p>修饰一个静态的方法，其作用的范围是整个静态方法，作用的对象是这个<strong>类对象</strong>；</p>
</li>
<li class="lvl-3">
<p>修饰一个类，其作用的范围是synchronized后面括号括起来的部分，作用主的对象是这个类的所有对象。</p>
</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 同步线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SyncThread</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyThreadDto</span> <span class="variable">lock1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThreadDto</span>();</span><br><span class="line">        <span class="type">MyThreadDto</span> <span class="variable">lock2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThreadDto</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">MySyncThread</span> <span class="variable">syncThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MySyncThread</span>(lock1);</span><br><span class="line">        <span class="type">MySyncThread</span> <span class="variable">syncThread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MySyncThread</span>(lock2);</span><br><span class="line"></span><br><span class="line">            <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(syncThread, <span class="string">&quot;SyncThread-1=&quot;</span> + i);</span><br><span class="line">            thread1.start();</span><br><span class="line"></span><br><span class="line">            <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(syncThread2, <span class="string">&quot;SyncThread-2=&quot;</span> + i);</span><br><span class="line">            thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MySyncThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> count;</span><br><span class="line">    <span class="keyword">private</span> MyThreadDto packageAccessLock;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MySyncThread</span><span class="params">(MyThreadDto accessLock)</span> &#123;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        packageAccessLock = accessLock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 此处获得的是参数中的锁，只有同一对象的该参数才会阻塞</span></span><br><span class="line">        <span class="keyword">synchronized</span> (packageAccessLock.getLock()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + (count++));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThreadDto</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如下：出现结果为小于2000000，获得两个不同实例对象的锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountingSyncBad</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">increase</span><span class="params">()</span>&#123;    <span class="comment">// static 修饰，锁为当前类对象</span></span><br><span class="line">        i++;</span><br><span class="line">    &#125; <span class="comment">// 修饰实例方法，此时的锁对象为实例对象（如new AccountingSyncBad()）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">1000000</span>;j++)&#123;</span><br><span class="line">            increase();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;        <span class="comment">//new新实例</span></span><br><span class="line">        <span class="comment">// 获得两个不同对象的锁</span></span><br><span class="line">        Thread t1=<span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">AccountingSyncBad</span>());                <span class="comment">//new新实例</span></span><br><span class="line">        Thread t2=<span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">AccountingSyncBad</span>());</span><br><span class="line">        <span class="comment">// 获得同一把锁</span></span><br><span class="line">   <span class="comment">//     AccountingSyncBad instance = new AccountingSyncBad();</span></span><br><span class="line">   <span class="comment">//     Thread t1 = new Thread(instance);</span></span><br><span class="line">    <span class="comment">//    Thread t2 = new Thread(instance);</span></span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();                <span class="comment">//join含义:当前线程A等待thread线程终止之后才能从thread.join()返回</span></span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 同步线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SyncThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SyncThread</span><span class="params">()</span> &#123;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + (count++));</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SyncThread</span> <span class="variable">syncThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SyncThread</span>(); <span class="comment">// 同一个对象阻塞</span></span><br><span class="line">        <span class="comment">// SyncThread syncThread2 = new SyncThread(); // 不同对象不阻塞</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(syncThread, <span class="string">&quot;SyncThread-1&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(syncThread, <span class="string">&quot;SyncThread-2&quot;</span>);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>synchronized可保证一个线程的变化(主要是共享数据的变化)被其他线程所看到（保证可见性，完全可以替代Volatile功能）</p>
<p><strong>应用方式：</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>修饰实例方法，作用于当前实例加锁，进入同步代码前要获得当前实例的锁</p>
</li>
<li class="lvl-2">
<p>修饰静态方法，作用于当前类对象加锁，进入同步代码前要获得当前类对象的锁</p>
</li>
<li class="lvl-2">
<p>修饰代码块，指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。</p>
</li>
</ul>
<p><strong>作用：</strong></p>
<blockquote>
<ol>
<li class="lvl-3">
<p>原子性：确保线程互斥的访问同步代码；</p>
</li>
<li class="lvl-3">
<p>可见性：保证共享变量的修改能够及时可见，其实是通过Java内存模型中的 “<strong>对一个变量unlock操作之前，必须要同步到主内存中；如果对一个变量进行lock操作，则将会清空工作内存中此变量的值，在执行引擎使用此变量前，需要重新从主内存中load操作或assign操作初始化变量值</strong>” 来保证的；</p>
</li>
<li class="lvl-3">
<p>有序性：有效解决重排序问题，即 “一个unlock操作先行发生(happen-before)于后面对同一个锁的lock操作”；</p>
</li>
</ol>
</blockquote>
<h4 id="原理实现">原理实现</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javap -v -p XXX.class    # 执行编译，查看字节码</span><br></pre></td></tr></table></figure>
<p>如果synchronized修饰的是方法，会生成一个  <mark>ACC_SYNCHRONIZED</mark>  指令，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    s++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src= "/img/20241215205335173426721579192.webp" data-lazy-src="/imgs/image-20210621192740860.png" alt="image-20210621192740860" style="zoom: 50%;" />
<p>如果synchronized修饰的是代码块，会生成一个  <mark>monitorenter</mark>  和  <mark>monitorexit</mark> 指令，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        s++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码正常结束或抛出异常都会执行  monitorexit  退出监控锁。</p>
<img src= "/img/20241215205335173426721579192.webp" data-lazy-src="/imgs/image-20210621192947651.png" alt="image-20210621192947651" style="zoom: 67%;" />
<p>monitor对象主要由以下几个字段来组成。</p>
<blockquote>
<ul class="lvl-1">
<li class="lvl-2">
<p><strong>count</strong>  记录个数</p>
</li>
<li class="lvl-2">
<p><strong>wanitset</strong>   处于wait状态，会被加入到 waitset</p>
</li>
<li class="lvl-2">
<p><strong>entryList</strong>    处于等待锁状态的线程，会被加入到entryList中。</p>
</li>
</ul>
<p>当monitor对象被线程持有时，count会加1，当线程释放monitor对象时，count会减1，用count表示monitor对象是否被持有。</p>
<p>而且synchronized有可重入性，当一个线程重复持有锁时，count会一直加，释放时候，会一直减，直到为0时，才算这块执行完。</p>
</blockquote>
<h4 id="重量级优化">重量级优化</h4>
<p>通常我们称Sychronized锁是一种重量级锁，是因为在互斥状态下，没有得到锁的线程会被挂起阻塞，而挂起线程和恢复线程的操作都需要在<strong>用户态</strong>和 <strong>内核态</strong>之间相互转换，而状态转换很耗费处理器时间，故称为重量级。</p>
<p>为了消除<strong>用户态</strong>和 <strong>内核态</strong>的开销转换，引入自旋，所谓的自旋，就是让没有获得锁的线程自己运行一段时间的自循环，这就是自旋锁。</p>
<blockquote>
<p>自旋锁在JDK6以后已经默认开启，可以通过-XX:+UseSpinning参数来开启。不挂起线程的代价就是该线程会一直占用处理器。如果锁被占用的时间很短，自旋等待的效果就会很好，反之，自旋会消耗大量处理器资源。因此，自旋的等待时间必须有一定的限度，如果超过限度还没有获得锁，就要挂起线程，这个限度默认是10次，可以使用-XX：PreBlockSpin改变。</p>
<p>在JDK6以后又引入了自适应自旋锁，也就说自旋的时间限度不是一个固定值了，而是由上一次同一个锁的自旋时间及锁的拥有者状态来决定。虚拟机认为，如果同一个锁对象自旋刚刚成功获得锁，那么下一次很可能获得锁，所以允许这次自旋锁自旋很长时间、而如果某个锁很少获得锁，那么以后在获取锁的过程中可能忽略到自旋过程。</p>
</blockquote>
<h3 id="Volatile">Volatile</h3>
<p>Java虚拟机提供的轻量级的同步机制，被volatile修饰的共享变量，就具有了以下两点特性：</p>
<blockquote>
<p><strong>1 . 保证了不同线程对该变量操作的内存可见性</strong>（当一个线程修改了被volatile修饰的值，新值总数可以被其他线程立即得知。）;</p>
<p><strong>2 . 禁止指令重排序</strong>（避免多线程环境下程序出现乱序执行的现象）。</p>
</blockquote>
<p><strong>并不保证安全性，不具有原子性</strong>（如果第二个线程在第一个线程读取旧值和写回新值期间读取i的域值）</p>
<blockquote>
<p>在线程执行时，首先会从主存中read变量值，再load到工作内存中的副本中，然后再传给处理器执行，执行完毕后再给工作内存中的副本赋值，随后工作内存再把值传回给主存，主存中的值才更新。</p>
<p>两个线程操作（修改），可能出现缓存不一致的问题。（只有一个线程修改操作，其他线程只读取，不存在原子性问题，但是i++操作就不行了）</p>
</blockquote>
<h4 id="使用场景">使用场景</h4>
<blockquote>
<p>只能在有限的情形下使用 volatile 变量替代锁。要使 volatile 变量提供理想的线程安全，必须同时满足下面两个条件：</p>
<ul class="lvl-1">
<li class="lvl-2">对变量的写操作不依赖于当前值。</li>
<li class="lvl-2">该变量没有包含在具有其他变量的不变式中。</li>
</ul>
</blockquote>
<h4 id="指令重排">指令重排</h4>
<p><strong>什么是指令重排序？</strong><br>
<strong>在虚拟机层面</strong></p>
<blockquote>
<p>为了尽可能减少*<u>内存操作速度远慢于CPU运行速度</u>*所带来的CPU空置的影响，虚拟机会按照自己的一些规则，将程序编写顺序打乱——即写在后面的代码在时间顺序上可能会先执行，而写在前面的代码会后执行——以尽可能充分地利用CPU。</p>
<p>拿上面的例子来说：假如不是a=1的操作，而是<code>a=new byte[1024*1024]</code>(分配1M空间)`，那么它会运行地很慢，此时CPU是等待其执行结束呢，还是先执行下面那句flag=true呢？显然，先执行flag=true可以提前使用CPU，加快整体效率，当然这样的前提是不会产生错误。</p>
<p>虽然这里有两种情况：后面的代码先于前面的代码开始执行；前面的代码先开始执行，但当效率较慢的时候，后面的代码开始执行并先于前面的代码执行结束。不管谁先开始，总之后面的代码在一些情况下存在先结束的可能。</p>
</blockquote>
<p><strong>在硬件层面</strong></p>
<blockquote>
<p>CPU会将接收到的一批指令按照其规则重排序，同样是基于CPU速度比缓存速度快的原因，和上一点的目的类似，只是硬件处理的话，每次只能在接收到的有限指令范围内重排序，而虚拟机可以在更大层面、更多指令范围内重排序。硬件的重排序机制参见《从JVM并发看CPU内存指令重排序(Memory Reordering)》</p>
</blockquote>
<h4 id="原理实现-2">原理实现</h4>
<p><strong>volatile如何让变量立即可见</strong></p>
<blockquote>
<p>当写一个volatile变量时，JMM会把该线程对应的工作内存中的共享变量值刷新到主内存中，当读取一个volatile变量时，JMM会把该线程对应的工作内存置为无效，那么该线程将只能从主内存中重新读取共享变量。volatile变量正是通过这种写-读方式实现对其他线程可见（但其内存语义实现则是通过内存屏障）</p>
</blockquote>
<p><strong>volatile禁止指令重排优化</strong></p>
<p><mark>内存屏障</mark>，又称内存栅栏，是一个CPU指令，它的作用有两个，一是保证特定操作的执行顺序，二是保证某些变量的内存可见性。</p>
<blockquote>
<p>由于编译器和处理器都能执行指令重排优化</p>
<p>如果在指令间插入一条Memory Barrier则会告诉编译器和CPU，不管什么指令都不能和这条Memory Barrier指令重排序，也就是说通过插入内存屏障禁止在内存屏障前后的指令执行重排序优化。</p>
<p>Memory Barrier的另外一个作用是强制刷出各种CPU的缓存数据，因此任何CPU上的线程都能读取到这些数据的最新版本</p>
</blockquote>
<p>典型的禁止重排优化的例子DCL</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DoubleCheckLock</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> DoubleCheckLock instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> DoubleCheckLock <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (instance==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (DoubleCheckLock.class)&#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>)&#123;</span><br><span class="line">                    <span class="comment">//多线程环境下可能会出现问题的地方</span></span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">DoubleCheckLock</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>字节码会生成一个 <mark>ACC_VOLATILE</mark></p>
<img src= "/img/20241215205335173426721579192.webp" data-lazy-src="/imgs/image-20210622094704147.png" alt="image-20210622094704147" style="zoom:67%;" />
<h3 id="Lock">Lock</h3>
<p>API层面的可重入锁，包含<strong>ReentrantLock、ReadLock、ReadLockView、WriteLock、WriteLockView</strong></p>
<img src= "/img/20241215205335173426721579192.webp" data-lazy-src="/imgs/aHR0cDo2ZtdD1qcGVn" alt="img" style="zoom: 80%;" />
<p>如果n个线程持有的为同一把锁，则需要竞争且阻塞，否则有各自的锁时，不会阻塞。如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 同步线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SyncThread</span> &#123;</span><br><span class="line">    <span class="comment">// 所有对象在同一SyncThread对象中将持有该同一把锁，发生阻塞</span></span><br><span class="line">   <span class="comment">// private final Lock lock = new ReentrantLock();</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 以下实例化两个对象，两个对象的两把锁。互不影响</span></span><br><span class="line">        <span class="type">MyThreadDto</span> <span class="variable">lock1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThreadDto</span>();</span><br><span class="line">        <span class="type">MyThreadDto</span> <span class="variable">lock2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThreadDto</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">MySyncThread</span> <span class="variable">syncThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MySyncThread</span>(lock1);</span><br><span class="line">        <span class="type">MySyncThread</span> <span class="variable">syncThread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MySyncThread</span>(lock2);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(syncThread, <span class="string">&quot;SyncThread-1&quot;</span>);</span><br><span class="line">        thread1.start();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(syncThread2, <span class="string">&quot;SyncThread-2&quot;</span>);</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MySyncThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> count;</span><br><span class="line">    <span class="keyword">private</span> MyThreadDto packageAccessLock;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MySyncThread</span><span class="params">(MyThreadDto accessLock)</span> &#123;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        packageAccessLock = accessLock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                packageAccessLock.getReentrantLock().lockInterruptibly();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + (count++));</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                  packageAccessLock.getReentrantLock().unlock();</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThreadDto</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">// 每个MyThreadDto对象都有各自的一把锁，当为同一个MyThreadDto对象时，将会被阻塞。不同对象不会竞争</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">reentrantLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="实现原理（AQS）">实现原理（<a target="_blank" rel="noopener" href="https://www.cnblogs.com/weiqihome/p/9665718.html">AQS</a>）</h4>
<p>用一个CAS操作，判断state是否是0（表示当前锁未被占用），如果是0则把它+1，并且设置当前线程为该锁的独占线程，表示获取锁成功。当多个线程同时尝试占用同一个锁时，CAS操作只能保证一个线程操作成功，剩下的只能乖乖的去排队 。</p>
<p>“非公平”即体现在这里，如果占用锁的线程刚释放锁，state置为0，而排队等待锁的线程还未唤醒时，新来的线程就直接抢占了该锁，那么就“插队”了。</p>
<p><strong>源码分析</strong></p>
<p>公平锁：若等待队列非空，则直接入队；否则尝试获取锁</p>
<p>非公平锁：先尝试获取锁，获取失败后，放入队列</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置 volatile int state = 1 成功表示加锁，0时释放锁，大于1表示重复加锁</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))    <span class="comment">// 通过CAS尝试变量从0设置为1</span></span><br><span class="line">setExclusiveOwnerThread(Thread.currentThread());    <span class="comment">// 设置变量为当前线程</span></span><br><span class="line"><span class="keyword">else</span> <span class="comment">// 加锁失败，放入等待队列（列表尾部）</span></span><br><span class="line">acquire(<span class="number">1</span>); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以独占模式获取，忽略中断。 通过至少调用一次tryAcquire ，成功返回。 否则线程会排队，可能会反复阻塞和解除阻塞，调用tryAcquire直到成功。 此方法可用于实现方法Lock.lock 。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp; <span class="comment">// 先尝试加锁</span></span><br><span class="line"><span class="comment">// 以独占不间断模式获取已在队列中的线程。 由条件等待方法以及获取使用。</span></span><br><span class="line">acquireQueued(addWaiter(Node.EXCLUSIVE), arg))    </span><br><span class="line">selfInterrupt(); <span class="comment">// 中断当前线程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加锁失败后放入排队队列，至尾部，并中断当前加锁线程</span></span><br><span class="line"><span class="keyword">private</span> Node <span class="title function_">addWaiter</span><span class="params">(Node mode)</span> &#123;</span><br><span class="line"><span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Thread.currentThread(), mode);</span><br><span class="line"><span class="type">Node</span> <span class="variable">pred</span> <span class="operator">=</span> tail;</span><br><span class="line"><span class="keyword">if</span> (pred != <span class="literal">null</span>) &#123;</span><br><span class="line">node.prev = pred;</span><br><span class="line"><span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">   pred.next = node;</span><br><span class="line">   <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">enq(node); <span class="comment">// 加入队尾</span></span><br><span class="line"><span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>加锁</strong></p>
<blockquote>
<p>第一步。尝试去获取锁。如果尝试获取锁成功，方法直接返回。非公平锁tryAcquire的流程是：检查state字段，若为0，表示锁未被占用，那么尝试占用，若不为0，检查当前锁是否被自己占用，若被自己占用，则更新state字段，表示重入锁的次数。如果以上两点都没有成功，则获取锁失败，返回false。</p>
<p>第二步，入队。其他线程占用锁，执行tryAcquire失败，并且入等待队列线程先入等待队列，然后开始自旋，尝试获取锁，获取成功就返回，失败则在队列里找一个安全点把自己挂起直到超时时间过期。这里为什么还需要循环呢？因为当前线程节点的前驱状态可能不是SIGNAL，那么在当前这一轮循环中线程不会被挂起，然后更新超时时间，开始新一轮的尝试。</p>
<p>第三步，挂起。已经入队的线程尝试获取锁，若失败则会被挂起。线程入队后能够挂起的前提是，它的前驱节点的状态为SIGNAL。若符合则返回true，将自己挂起。如果不符合，再看前驱节点是否&gt;0(CANCELLED)，若是向前遍历直到找到第一个符合要求的前驱，若不是则将前驱节点的状态设置为SIGNAL。</p>
</blockquote>
<p><strong>解锁</strong></p>
<blockquote>
<p>先尝试释放锁，若释放成功，那么查看头结点的状态是否为SIGNAL，如果是则唤醒头结点的下个节点关联的线程，如果释放失败那么返回false表示解锁失败</p>
<p>当前释放锁的线程若不持有锁，则抛出异常。若持有锁，计算释放后的state值是否为0，若为0表示锁已经被成功释放，并且则清空独占线程，最后更新state值，返回free。</p>
</blockquote>
<p>ReentrantLock#lock的原理流程图大致如下</p>
<p><img src= "/img/20241215205335173426721579192.webp" data-lazy-src="/imgs/aHR0cDovL21tYmd3hfZm10PWpwZWc" alt="img"></p>
<h3 id="Atomic（CAS）">Atomic（CAS）</h3>
<p>属于乐观锁，自旋等待直到成功，可设置自旋次数。</p>
<p>并发越高，失败的次数会越多，CAS如果长时间不成功，会极大的增加CPU的开销。因此CAS不适合竞争十分频繁的场景。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自旋</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndAddInt</span><span class="params">(Object var1, <span class="type">long</span> var2, <span class="type">int</span> var4)</span> &#123;</span><br><span class="line">    <span class="type">int</span> var5;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        var5 = <span class="built_in">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="built_in">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>CAS由于是在硬件层面保证的原子性，不会锁住当前线程，它的效率是很高的。</p>
<h4 id="ABA-问题">ABA 问题</h4>
<p>避免ABA问题的版本号机制，如AtomicStampedReference。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">overTimeWaitMin</span><span class="params">(AbstractBaseGssp baseGssp, BaseDictDto dto, Map&lt;String, AtomicStampedReference&lt;AbstractBaseGssp&gt;&gt; mapReference)</span> <span class="keyword">throws</span> ParseException &#123;</span><br><span class="line">    <span class="keyword">if</span> (dto == <span class="literal">null</span> || baseGssp == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> dto.getCode() + BaseConstants.SEPARATOR_06 + baseGssp.getGpsSn();</span><br><span class="line">    <span class="type">int</span> <span class="variable">stayMin</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mapReference.containsKey(key)) &#123;</span><br><span class="line">        <span class="comment">// 获得旧对象</span></span><br><span class="line">        AtomicStampedReference&lt;AbstractBaseGssp&gt; gsspReference = mapReference.get(key);</span><br><span class="line">        <span class="type">AbstractBaseGssp</span> <span class="variable">lastGssp</span> <span class="operator">=</span> gsspReference.getReference();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 有移动</span></span><br><span class="line">        <span class="keyword">if</span> (GsspUtil.hasMoved(lastGssp.getLongitude(), lastGssp.getLatitude(), baseGssp.getLongitude(), baseGssp.getLatitude())) &#123;</span><br><span class="line">            <span class="comment">// 比较stamp版本 并重新设值</span></span><br><span class="line">            gsspReference.compareAndSet(lastGssp, baseGssp, gsspReference.getStamp(), gsspReference.getStamp() + <span class="number">1</span>);</span><br><span class="line">            mapReference.put(key, gsspReference);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            stayMin = GsspUtil.timeIntervalMin(lastGssp.getGpsTime(), baseGssp.getGpsTime());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        mapReference.put(key, <span class="keyword">new</span> <span class="title class_">AtomicStampedReference</span>&lt;&gt;(baseGssp, <span class="number">0</span>)); <span class="comment">// 初始值及版本</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> stayMin;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://pengline.github.io">余一叶知秋尽</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://pengline.github.io/2025/09/12fcec526d85480c91adb7dc237cd547/">https://pengline.github.io/2025/09/12fcec526d85480c91adb7dc237cd547/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://pengline.github.io" target="_blank">余一叶知秋尽</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java-%E9%94%81/">Java 锁</a><a class="post-meta__tags" href="/tags/%E9%94%81%E5%8D%87%E7%BA%A7/">锁升级</a><a class="post-meta__tags" href="/tags/%E9%94%81%E6%B6%88%E9%99%A4/">锁消除</a><a class="post-meta__tags" href="/tags/Synchronized/">Synchronized</a><a class="post-meta__tags" href="/tags/Atomic/">Atomic</a><a class="post-meta__tags" href="/tags/Lock/">Lock</a><a class="post-meta__tags" href="/tags/%E6%AD%BB%E9%94%81%E6%A3%80%E6%9F%A5/">死锁检查</a><a class="post-meta__tags" href="/tags/%E5%81%8F%E5%90%91%E9%94%81/">偏向锁</a><a class="post-meta__tags" href="/tags/%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81/">轻量级锁</a><a class="post-meta__tags" href="/tags/%E4%B9%90%E8%A7%82%E9%94%81/">乐观锁</a></div><div class="post-share"><div class="social-share" data-image="/img/essay/1745746436650174574643686.webp" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/09/ba484d8d518d4691bc0c1737da33d517/" title="表达式的概念和求值实现"><img class="cover" src= "/img/20241215205335173426721579192.webp" data-lazy-src="/img/essay/171084628467171084628487.webp" onerror="onerror=null;src='/img/k3zssqvjw2d.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">表达式的概念和求值实现</div></div><div class="info-2"><div class="info-item-1">三种表达式的概念特性，以及如何计算出人类熟知表达式的值（中缀表达式）。</div></div></div></a><a class="pagination-related" href="/2025/09/35f4ef2aabae45d4b9f215b1a36ac023/" title="VMware 如何扩展 Centos7 的磁盘容量"><img class="cover" src= "/img/20241215205335173426721579192.webp" data-lazy-src="/img/essay/small204229In3bP1756557749.webp" onerror="onerror=null;src='/img/k3zssqvjw2d.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">VMware 如何扩展 Centos7 的磁盘容量</div></div><div class="info-2"><div class="info-item-1">VMware 虚拟机 Centos7 系统扩展磁盘后，系统并没有显示扩容的容量（df命令），如何给系统扩容。</div></div></div></a></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="giscus-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%81%E7%9A%84%E7%A7%8D%E7%B1%BB"><span class="toc-number">1.</span> <span class="toc-text">锁的种类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%90%E8%A7%82%E9%94%81-VS-%E6%82%B2%E8%A7%82%E9%94%81"><span class="toc-number">1.1.</span> <span class="toc-text">乐观锁 VS 悲观锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E6%97%8B%E9%94%81-VS-%E9%98%BB%E5%A1%9E%E9%94%81"><span class="toc-number">1.2.</span> <span class="toc-text">自旋锁 VS 阻塞锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E9%94%81-VS-%E5%81%8F%E5%90%91%E9%94%81"><span class="toc-number">1.3.</span> <span class="toc-text">无锁 VS 偏向锁 </span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81-VS-%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81"><span class="toc-number">1.4.</span> <span class="toc-text">轻量级锁 VS 重量级锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AC%E5%B9%B3%E9%94%81-VS-%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81"><span class="toc-number">1.5.</span> <span class="toc-text">公平锁 VS 非公平锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81-VS-%E9%9D%9E%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81"><span class="toc-number">1.6.</span> <span class="toc-text">可重入锁 VS 非可重入锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8B%AC%E4%BA%AB%E9%94%81%EF%BC%88%E4%BA%92%E6%96%A5%EF%BC%89-VS-%E5%85%B1%E4%BA%AB%E9%94%81"><span class="toc-number">1.7.</span> <span class="toc-text">独享锁（互斥） VS 共享锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81"><span class="toc-number">2.</span> <span class="toc-text">如何避免死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81"><span class="toc-number">2.1.</span> <span class="toc-text">避免死锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E6%A3%80%E6%9F%A5"><span class="toc-number">2.2.</span> <span class="toc-text">死锁检查</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E5%A4%8D%E7%8E%B0"><span class="toc-number">2.3.</span> <span class="toc-text">死锁复现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%A4%B4%E4%B8%8E%E9%94%81"><span class="toc-number">3.</span> <span class="toc-text">对象头与锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E4%BC%98%E5%8C%96"><span class="toc-number">3.1.</span> <span class="toc-text">锁优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E6%B6%88%E9%99%A4"><span class="toc-number">3.2.</span> <span class="toc-text">锁消除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E7%B2%97%E5%8C%96"><span class="toc-number">3.3.</span> <span class="toc-text">锁粗化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E5%8D%87%E7%BA%A7%EF%BC%88%E9%94%81%E8%86%A8%E8%83%80%EF%BC%89"><span class="toc-number">3.4.</span> <span class="toc-text">锁升级（锁膨胀）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-%E6%8F%90%E4%BE%9B%E7%9A%84%E9%94%81"><span class="toc-number">4.</span> <span class="toc-text">Java 提供的锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Synchronized"><span class="toc-number">4.1.</span> <span class="toc-text">Synchronized</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%81%E5%AE%9A%E8%8C%83%E5%9B%B4"><span class="toc-number">4.1.1.</span> <span class="toc-text">锁定范围</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E7%90%86%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.1.2.</span> <span class="toc-text">原理实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E9%87%8F%E7%BA%A7%E4%BC%98%E5%8C%96"><span class="toc-number">4.1.3.</span> <span class="toc-text">重量级优化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Volatile"><span class="toc-number">4.2.</span> <span class="toc-text">Volatile</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">4.2.1.</span> <span class="toc-text">使用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92"><span class="toc-number">4.2.2.</span> <span class="toc-text">指令重排</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E7%90%86%E5%AE%9E%E7%8E%B0-2"><span class="toc-number">4.2.3.</span> <span class="toc-text">原理实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lock"><span class="toc-number">4.3.</span> <span class="toc-text">Lock</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%88AQS%EF%BC%89"><span class="toc-number">4.3.1.</span> <span class="toc-text">实现原理（AQS）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Atomic%EF%BC%88CAS%EF%BC%89"><span class="toc-number">4.4.</span> <span class="toc-text">Atomic（CAS）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ABA-%E9%97%AE%E9%A2%98"><span class="toc-number">4.4.1.</span> <span class="toc-text">ABA 问题</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 By 余一叶知秋尽</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.4.3</a></span></div><div class="footer_custom_text"><p><a style="margin-inline:5px"target="_blank"href="https://github.com/"><img src= "/img/20241215205335173426721579192.webp" data-lazy-src="https://img.shields.io/badge/Hosted-Github-brightgreen?style=flat&logo=GitHub"title="本站项目由Gtihub托管"></a><a style="margin-inline:5px"target="_blank"href="https://hexo.io/"><img src= "/img/20241215205335173426721579192.webp" data-lazy-src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&logo=hexo"title="博客框架为Hexo"></a><a style="margin-inline:5px"target="_blank"href="https://butterfly.js.org/"><img src= "/img/20241215205335173426721579192.webp" data-lazy-src="https://img.shields.io/badge/Theme-Butterfly-6513df?logoColor=white&style=flat&logo=buefy"title="主题采用butterfly"></a><a style="margin-inline:5px"target="_blank"href="https://giscus.app/zh-CN/"><img src= "/img/20241215205335173426721579192.webp" data-lazy-src="https://img.shields.io/badge/Comment-Giscus-2873df?logoColor=white&style=flat&logo=git"title="评论系统为Giscus"></a><a style="margin-inline:5px"target="_blank"href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img src= "/img/20241215205335173426721579192.webp" data-lazy-src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&logo=Claris"title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"></a></p></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><a class="icon-V hidden" onclick="switchNightMode()" title="日间和夜间模式切换"><svg width="25" height="25" viewBox="0 0 1024 1024"><use id="modeicon" xlink:href="#icon-moon"></use></svg></a><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const getGiscusTheme = theme => theme === 'dark' ? 'dark' : 'light'

  const createScriptElement = config => {
    const ele = document.createElement('script')
    Object.entries(config).forEach(([key, value]) => {
      ele.setAttribute(key, value)
    })
    return ele
  }

  const loadGiscus = (el = document, key) => {
    const mappingConfig = isShuoshuo
      ? { 'data-mapping': 'specific', 'data-term': key }
      : { 'data-mapping': (option && option['data-mapping']) || 'pathname' }

    const giscusConfig = {
      src: 'https://giscus.app/client.js',
      'data-repo': 'pengline/pengline.github.io',
      'data-repo-id': 'R_kgDOPqG50w',
      'data-category-id': 'DIC_kwDOPqG5084Cu_K9',
      'data-theme': getGiscusTheme(document.documentElement.getAttribute('data-theme')),
      'data-reactions-enabled': '1',
      crossorigin: 'anonymous',
      'data-lang': 'zh-CN',
      'data-input-position': 'top',
      async: true,
      ...option,
      ...mappingConfig
    }

    const scriptElement = createScriptElement(giscusConfig)

    el.querySelector('#giscus-wrap').appendChild(scriptElement)

    if (isShuoshuo) {
      window.shuoshuoComment.destroyGiscus = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }
  }

  const changeGiscusTheme = theme => {
    const iframe = document.querySelector('#giscus-wrap iframe')
    if (iframe) {
      const message = {
        giscus: {
          setConfig: {
            theme: getGiscusTheme(theme),
            lang: 'zh-CN'
          }
        }
      }
      iframe.contentWindow.postMessage(message, 'https://giscus.app')
    }
  }

  btf.addGlobalFn('themeChange', changeGiscusTheme, 'giscus')

  if (isShuoshuo) {
    'Giscus' === 'Giscus'
      ? window.shuoshuoComment = { loadComment: loadGiscus }
      : window.loadOtherComment = loadGiscus
    return
  }

  if ('Giscus' === 'Giscus' || !false) {
    if (false) btf.loadComment(document.getElementById('giscus-wrap'), loadGiscus)
    else loadGiscus()
  } else {
    window.loadOtherComment = loadGiscus
  }
})()</script></div><script src="/js/custom/sun_moon.js" async></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>